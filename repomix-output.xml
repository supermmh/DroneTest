This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.clang-format
.cproject
.eide/eide.yml
.eide/files.options.yml
.gitignore
.mxproject
.project
.repomixignore
Core/Inc/dma.h
Core/Inc/FreeRTOSConfig.h
Core/Inc/gpio.h
Core/Inc/i2c.h
Core/Inc/main.h
Core/Inc/spi.h
Core/Inc/stm32h7xx_hal_conf.h
Core/Inc/stm32h7xx_it.h
Core/Inc/tim.h
Core/Src/dma.c
Core/Src/freertos.c
Core/Src/gpio.c
Core/Src/i2c.c
Core/Src/main.c
Core/Src/spi.c
Core/Src/stm32h7xx_hal_msp.c
Core/Src/stm32h7xx_hal_timebase_tim.c
Core/Src/stm32h7xx_it.c
Core/Src/syscalls.c
Core/Src/sysmem.c
Core/Src/system_stm32h7xx.c
Core/Src/tim.c
Core/Startup/startup_stm32h743vitx.s
MyCore/Inc/AttitudeESKF.hpp
MyCore/Inc/DataStructConfig.hpp
MyCore/Inc/DebugMonitor.hpp
MyCore/Inc/DTCMinit.h
MyCore/Inc/Mydelay.hpp
MyCore/Inc/QueueConfig.hpp
MyCore/Inc/Sensors.hpp
MyCore/Inc/TaskConfig.hpp
MyCore/Src/AttitudeESKF.cpp
MyCore/Src/Callback.cpp
MyCore/Src/DataStructConfig.cpp
MyCore/Src/DebugMonitor.cpp
MyCore/Src/DTCMinit.c
MyCore/Src/Mydelay.cpp
MyCore/Src/QueueConfig.cpp
MyCore/Src/Sensors.cpp
MyCore/Src/TaskConfig.cpp
MyDrone.code-workspace
MyDrone.ioc
STM32H743VITX_FLASH.ld
STM32H743VITX_RAM.ld
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="MyCore/Inc/AttitudeESKF.hpp">
#pragma once
#include "main.h"
#include "DataStructConfig.hpp"

#ifdef __cplusplus
extern "C" {
#endif

// FreeRTOS 任务入口暴露给 C 环境
void AttitudeEstimator_Init(void);

#ifdef __cplusplus
}

class ESKF {
public:
    ESKF();
    void Init(float initial_yaw, float initial_alt);
    
    // 核心卡尔曼循环
    void PredictIMU(const float acc[3], const float gyro[3], float dt);
    void UpdateBaro(float alt);
    void UpdateMag(const float mag[3]);
    void UpdateFlow(float flow_dx, float flow_dy, float dt);
    void UpdateAccel(const float acc[3]);
    void UpdateZUPT(void);
    VehicleState_t GetState(uint64_t timestamp);

    float base_baro;
    bool is_inited;
    
private:
    float p[3];      // 名义位置 NED
    float v[3];      // 名义速度 NED
    float q[4];      // 名义四元数
    float bg[3];     // 陀螺仪零偏
    float ba[3];     // 加速度零偏
    float P[15][15]; // 误差状态协方差矩阵
    
    float last_gyro[3]; 

    void GetRotationMatrix(float Rmat[3][3]);
    void ScalarUpdate(const float H[15], float y, float R_var);
    void InjectError(const float dx[15]);
    
};
#endif
</file>

<file path="MyCore/Src/AttitudeESKF.cpp">
#include "AttitudeESKF.hpp"
#include "QueueConfig.hpp"
#include "FreeRTOS.h"
#include "task.h"
#include <math.h>
#include <string.h>
#include "DebugMonitor.hpp"

#ifndef M_PI
#define M_PI 3.14159265358979323846f
#endif

// 放入 DTCM 极速内存，避免占用 FreeRTOS 任务栈
DTCM_DATA ESKF eskf;
DTCM_DATA static StackType_t ESKFTaskStack[1024];
DTCM_DATA static StaticTask_t ESKFTaskTCB;
TaskHandle_t ESKFTaskHandle = NULL;

ESKF::ESKF()
{
    is_inited = false;
    base_baro = 101325.0f;
}

void ESKF::Init(float initial_yaw, float initial_alt)
{
    memset(p, 0, sizeof(p));
    memset(v, 0, sizeof(v));
    memset(bg, 0, sizeof(bg));
    memset(ba, 0, sizeof(ba));

    p[2] = -initial_alt; // NED坐标系，Z向下为正

    q[0] = cosf(initial_yaw * 0.5f);
    q[1] = 0.0f;
    q[2] = 0.0f;
    q[3] = sinf(initial_yaw * 0.5f);

    memset(P, 0, sizeof(P));
    for (int i = 0; i < 15; i++) {
        if (i < 9)
            P[i][i] = 1e-2f; // 位置、速度、姿态初始方差
        else
            P[i][i] = 1e-4f; // 零偏初始方差较小
    }
    is_inited = true;
}

void ESKF::GetRotationMatrix(float R[3][3])
{
    float qw = q[0], qx = q[1], qy = q[2], qz = q[3];
    R[0][0] = 1.0f - 2.0f * (qy * qy + qz * qz);
    R[0][1] = 2.0f * (qx * qy - qw * qz);
    R[0][2] = 2.0f * (qx * qz + qw * qy);
    R[1][0] = 2.0f * (qx * qy + qw * qz);
    R[1][1] = 1.0f - 2.0f * (qx * qx + qz * qz);
    R[1][2] = 2.0f * (qy * qz - qw * qx);
    R[2][0] = 2.0f * (qx * qz - qw * qy);
    R[2][1] = 2.0f * (qy * qz + qw * qx);
    R[2][2] = 1.0f - 2.0f * (qx * qx + qy * qy);
}

void ESKF::PredictIMU(const float acc[3], const float gyro[3], float dt)
{
    // 1. 扣除零偏
    float true_acc[3]  = {acc[0] - ba[0], acc[1] - ba[1], acc[2] - ba[2]};
    float true_gyro[3] = {gyro[0] - bg[0], gyro[1] - bg[1], gyro[2] - bg[2]};

    last_gyro[0] = true_gyro[0];
    last_gyro[1] = true_gyro[1];
    last_gyro[2] = true_gyro[2];

    float Rmat[3][3];
    GetRotationMatrix(Rmat);

    // 2. 名义运动学积分
    float a_ned[3] = {
        Rmat[0][0] * true_acc[0] + Rmat[0][1] * true_acc[1] + Rmat[0][2] * true_acc[2],
        Rmat[1][0] * true_acc[0] + Rmat[1][1] * true_acc[1] + Rmat[1][2] * true_acc[2],
        Rmat[2][0] * true_acc[0] + Rmat[2][1] * true_acc[1] + Rmat[2][2] * true_acc[2] + 9.80665f // 重力补偿
    };

    for (int i = 0; i < 3; i++) {
        p[i] += v[i] * dt + 0.5f * a_ned[i] * dt * dt;
        v[i] += a_ned[i] * dt;
    }

    float theta = sqrtf(true_gyro[0] * true_gyro[0] + true_gyro[1] * true_gyro[1] + true_gyro[2] * true_gyro[2]) * dt;
    float dq[4] = {1.0f, 0.0f, 0.0f, 0.0f};
    if (theta > 1e-6f) {
        float s = sinf(theta * 0.5f) / (theta / dt);
        dq[0]   = cosf(theta * 0.5f);
        dq[1]   = true_gyro[0] * s;
        dq[2]   = true_gyro[1] * s;
        dq[3]   = true_gyro[2] * s;
    }

    float q_new[4] = {
        q[0] * dq[0] - q[1] * dq[1] - q[2] * dq[2] - q[3] * dq[3],
        q[0] * dq[1] + q[1] * dq[0] + q[2] * dq[3] - q[3] * dq[2],
        q[0] * dq[2] - q[1] * dq[3] + q[2] * dq[0] + q[3] * dq[1],
        q[0] * dq[3] + q[1] * dq[2] - q[2] * dq[1] + q[3] * dq[0]};
    float norm = sqrtf(q_new[0] * q_new[0] + q_new[1] * q_new[1] + q_new[2] * q_new[2] + q_new[3] * q_new[3]);
    for (int i = 0; i < 4; i++) q[i] = q_new[i] / norm;

    // 3. 构造状态转移雅可比矩阵 F (15x15)
    float F[15][15] = {0};
    for (int i = 0; i < 15; i++) F[i][i] = 1.0f;
    for (int i = 0; i < 3; i++) F[i][i + 3] = dt;

    float skew_a[3][3] = {{0, -true_acc[2], true_acc[1]}, {true_acc[2], 0, -true_acc[0]}, {-true_acc[1], true_acc[0], 0}};
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            F[3 + i][6 + j]  = -(Rmat[i][0] * skew_a[0][j] + Rmat[i][1] * skew_a[1][j] + Rmat[i][2] * skew_a[2][j]) * dt;
            F[3 + i][12 + j] = -Rmat[i][j] * dt;
        }
    }
    F[6][7]  = true_gyro[2] * dt;
    F[6][8]  = -true_gyro[1] * dt;
    F[7][6]  = -true_gyro[2] * dt;
    F[7][8]  = true_gyro[0] * dt;
    F[8][6]  = true_gyro[1] * dt;
    F[8][7]  = -true_gyro[0] * dt;
    F[6][9]  = -dt;
    F[7][10] = -dt;
    F[8][11] = -dt;

    // 4. 协方差推演: P = F * P * F^T + Q (矩阵展开优化算法)
    float FP[15][15] = {0};
    for (int i = 0; i < 15; i++) {
        for (int k = 0; k < 15; k++) {
            if (F[i][k] != 0.0f) {
                for (int j = 0; j < 15; j++) FP[i][j] += F[i][k] * P[k][j];
            }
        }
    }
    for (int i = 0; i < 15; i++) {
        for (int j = 0; j < 15; j++) {
            float sum = 0.0f;
            for (int k = 0; k < 15; k++)
                if (F[j][k] != 0.0f) sum += FP[i][k] * F[j][k];
            P[i][j] = sum;
        }
    }

    // 注入过程噪声 Q
    for (int i = 3; i < 6; i++) P[i][i] += 1e-2f * dt;   // 速度游走
    for (int i = 6; i < 9; i++) P[i][i] += 1e-4f * dt;   // 角度游走
    for (int i = 9; i < 12; i++) P[i][i] += 1e-6f * dt;  // 陀螺零偏游走
    for (int i = 12; i < 15; i++) P[i][i] += 1e-5f * dt; // 加速零偏游走
}

// =================== 极速降维：单向标量更新 ===================
void ESKF::ScalarUpdate(const float H[15], float y, float R_var)
{
    float PHt[15] = {0};
    float S       = R_var;
    for (int i = 0; i < 15; i++) {
        for (int j = 0; j < 15; j++)
            if (H[j] != 0.0f) PHt[i] += P[i][j] * H[j];
        S += H[i] * PHt[i];
    }
    if (S < 1e-6f) return;

    float K[15], dx[15];
    for (int i = 0; i < 15; i++) {
        K[i]  = PHt[i] / S;
        dx[i] = K[i] * y;
    }

    InjectError(dx);

    for (int i = 0; i < 15; i++) {
        for (int j = 0; j < 15; j++) P[i][j] -= K[i] * PHt[j];
    }
    for (int i = 0; i < 15; i++) { // 强制对称
        for (int j = i + 1; j < 15; j++) {
            float sym = 0.5f * (P[i][j] + P[j][i]);
            P[i][j] = P[j][i] = sym;
        }
    }
}

void ESKF::InjectError(const float dx[15])
{
    for (int i = 0; i < 3; i++) {
        p[i] += dx[i];
        v[i] += dx[i + 3];
        bg[i] += dx[i + 9];
        ba[i] += dx[i + 12];
    }
    float dq[4]    = {1.0f, 0.5f * dx[6], 0.5f * dx[7], 0.5f * dx[8]};
    float q_new[4] = {
        q[0] * dq[0] - q[1] * dq[1] - q[2] * dq[2] - q[3] * dq[3],
        q[0] * dq[1] + q[1] * dq[0] + q[2] * dq[3] - q[3] * dq[2],
        q[0] * dq[2] - q[1] * dq[3] + q[2] * dq[0] + q[3] * dq[1],
        q[0] * dq[3] + q[1] * dq[2] - q[2] * dq[1] + q[3] * dq[0]};
    float norm = sqrtf(q_new[0] * q_new[0] + q_new[1] * q_new[1] + q_new[2] * q_new[2] + q_new[3] * q_new[3]);
    for (int i = 0; i < 4; i++) q[i] = q_new[i] / norm;
}

// ---------------------- 观测接口 ----------------------
void ESKF::UpdateBaro(float alt)
{
    float H[15] = {0};
    H[2]        = -1.0f;                  // p[2] 是 NED 的 D (向下)，因此预测 alt 是 -p[2]
    ScalarUpdate(H, alt - (-p[2]), 0.5f); // 气压计方差 R=0.5
}

void ESKF::UpdateMag(const float mag[3])
{
    float Rmat[3][3];
    GetRotationMatrix(Rmat);
    float roll  = atan2f(Rmat[2][1], Rmat[2][2]);
    float pitch = asinf(-Rmat[2][0]);
    float yaw   = atan2f(Rmat[1][0], Rmat[0][0]);

    // 倾角补偿求绝对磁航向
    float cr = cosf(roll), sr = sinf(roll), cp = cosf(pitch), sp = sinf(pitch);
    float Xh       = mag[0] * cp + mag[1] * sr * sp + mag[2] * cr * sp;
    float Yh       = mag[1] * cr - mag[2] * sr;
    float meas_yaw = atan2f(-Yh, Xh);

    float y = meas_yaw - yaw;
    while (y > M_PI) y -= 2.0f * M_PI;
    while (y < -M_PI) y += 2.0f * M_PI;

    float H[15] = {0};
    H[6]        = Rmat[2][0];
    H[7]        = Rmat[2][1];
    H[8]        = Rmat[2][2];
    ScalarUpdate(H, y, 0.2f); // 磁力计方差 R=0.2
}

void ESKF::UpdateFlow(float dx, float dy, float dt)
{
    float z = -p[2]; // 对地高度
    if (z < 0.1f) z = 0.1f;

    // ★ 核心缩放系数: 像素与光流视场角换算率，需根据 PMW3901 镜头实测修改
    float OPT_FLOW_SCALER = 30.0f;
    float flow_wx         = (dx / dt) / OPT_FLOW_SCALER;
    float flow_wy         = (dy / dt) / OPT_FLOW_SCALER;

    // 抵消机身自转产生的虚假相对位移
    float vbx_obs = (flow_wy - last_gyro[1]) * z;
    float vby_obs = (flow_wx + last_gyro[0]) * z;

    float Rmat[3][3];
    GetRotationMatrix(Rmat);
    float vbx_pred = Rmat[0][0] * v[0] + Rmat[1][0] * v[1] + Rmat[2][0] * v[2];
    float vby_pred = Rmat[0][1] * v[0] + Rmat[1][1] * v[1] + Rmat[2][1] * v[2];
    float vbz_pred = Rmat[0][2] * v[0] + Rmat[1][2] * v[1] + Rmat[2][2] * v[2];

    // 分别进行 X 和 Y 轴的标量融合
    float Hx[15] = {0};
    Hx[3]        = Rmat[0][0];
    Hx[4]        = Rmat[1][0];
    Hx[5]        = Rmat[2][0];
    Hx[7]        = -vbz_pred;
    Hx[8]        = vby_pred;
    ScalarUpdate(Hx, vbx_obs - vbx_pred, 0.1f);

    float Hy[15] = {0};
    Hy[3]        = Rmat[0][1];
    Hy[4]        = Rmat[1][1];
    Hy[5]        = Rmat[2][1];
    Hy[6]        = vbz_pred;
    Hy[8]        = -vbx_pred;
    ScalarUpdate(Hy, vby_obs - vby_pred, 0.1f);
}

VehicleState_t ESKF::GetState(uint64_t timestamp)
{
    VehicleState_t s;
    s.timestamp = timestamp;
    float Rmat[3][3];
    GetRotationMatrix(Rmat);
    s.roll     = atan2f(Rmat[2][1], Rmat[2][2]);
    float sinp = -Rmat[2][0];
    if (sinp > 1.0f)
        sinp = 1.0f;
    else if (sinp < -1.0f)
        sinp = -1.0f;
    s.pitch = asinf(sinp);
    s.yaw   = atan2f(Rmat[1][0], Rmat[0][0]);

    for (int i = 0; i < 4; i++) s.q[i] = q[i];
    for (int i = 0; i < 3; i++) {
        s.position[i]   = p[i];
        s.velocity[i]   = v[i];
        s.accel_bias[i] = ba[i];
        s.gyro_bias[i]  = bg[i];
    }
    return s;
}

// ================= FreeRTOS 任务主干 =================
void AttitudeESKF_TaskEntry(void *argument)
{
    Sensor_Packet_t pkt;

    // --- 阶段1：静止开机校准，获取初始基准 ---
    int imu_cnt = 0, mag_cnt = 0, baro_cnt = 0;
    float sum_acc[3] = {0}, sum_mag[3] = {0}, sum_baro = 0;

    while (imu_cnt < 200) { // 等待约 0.2 秒收集基础环境数据
        if (xQueueReceive(SensorsDataHub, &pkt, portMAX_DELAY)) {
            if (pkt.tag == SENSOR_ID_ICM42688) {
                sum_acc[0] += pkt.data.ICM42688.acc[0];
                sum_acc[1] += pkt.data.ICM42688.acc[1];
                sum_acc[2] += pkt.data.ICM42688.acc[2];
                imu_cnt++;
            } else if (pkt.tag == SENSOR_ID_MMC5983) {
                sum_mag[0] += pkt.data.MMC5983.mag[0];
                sum_mag[1] += pkt.data.MMC5983.mag[1];
                sum_mag[2] += pkt.data.MMC5983.mag[2];
                mag_cnt++;
            } else if (pkt.tag == SENSOR_ID_DPS310) {
                sum_baro += pkt.data.DPS310.pressure;
                baro_cnt++;
            }
        }
    }

    float ax = sum_acc[0] / imu_cnt;
    if (ax > 1.0f)
        ax = 1.0f;
    else if (ax < -1.0f)
        ax = -1.0f;
    float pitch = asinf(ax);
    float roll  = atan2f(-(sum_acc[1] / imu_cnt), -(sum_acc[2] / imu_cnt));

    float initial_yaw = 0.0f;
    if (mag_cnt > 0) {
        float Xh    = (sum_mag[0] / mag_cnt) * cosf(pitch) + (sum_mag[1] / mag_cnt) * sinf(roll) * sinf(pitch) + (sum_mag[2] / mag_cnt) * cosf(roll) * sinf(pitch);
        float Yh    = (sum_mag[1] / mag_cnt) * cosf(roll) - (sum_mag[2] / mag_cnt) * sinf(roll);
        initial_yaw = atan2f(-Yh, Xh);
    }
    if (baro_cnt > 0) eskf.base_baro = sum_baro / baro_cnt;

    eskf.Init(initial_yaw, 0.0f);
    uint64_t last_imu_ts = 0, last_flow_ts = 0;

    // --- 阶段2：高速解算循环 ---
    while (1) {
        if (xQueueReceive(SensorsDataHub, &pkt, portMAX_DELAY)) {
            switch (pkt.tag) {
                case SENSOR_ID_ICM42688: { // IMU到达：触发预测并向外发布
                    if (last_imu_ts != 0) {
                        float dt = (pkt.timestamp - last_imu_ts) * 1e-9f;

                        float acc[3]  = {pkt.data.ICM42688.acc[0] * 9.80665f, pkt.data.ICM42688.acc[1] * 9.80665f, pkt.data.ICM42688.acc[2] * 9.80665f};
                        float gyro[3] = {pkt.data.ICM42688.gyro[0] * 0.01745329f, pkt.data.ICM42688.gyro[1] * 0.01745329f, pkt.data.ICM42688.gyro[2] * 0.01745329f};

                        // 1. 运动学预测 (状态推演)
                        eskf.PredictIMU(acc, gyro, dt);

                        // ★ 2. 加速度计姿态更新 (非常关键：锁定水平面，防止重力泄露)
                        eskf.UpdateAccel(acc);

                        // ★ 3. 桌面静态抗漂移 ZUPT (Zero Velocity Update) 逻辑
                        static int static_counter = 0;
                        float gyro_norm           = sqrtf(gyro[0] * gyro[0] + gyro[1] * gyro[1] + gyro[2] * gyro[2]);
                        float acc_norm            = sqrtf(acc[0] * acc[0] + acc[1] * acc[1] + acc[2] * acc[2]);

                        // 如果角速度极小 (<0.03 rad/s，约 1.7度/秒) 且加速度接近 1G，认为飞控板静止放在桌面上
                        if (gyro_norm < 0.03f && fabsf(acc_norm - 9.80665f) < 0.5f) {
                            static_counter++;
                            if (static_counter > 50) { // 连续约50ms静止，认定为完全静置
                                eskf.UpdateZUPT();
                            }
                        } else {
                            static_counter = 0; // 一旦有拿起来或晃动，立即解除静止锁定
                        }

                        // 打包当前解算结果并用 Overwrite 机制发布给控制器
                        VehicleState_t vs = eskf.GetState(pkt.timestamp);
                        if (VehicleStateQueue != NULL) xQueueOverwrite(VehicleStateQueue, &vs);

                        // 更新调试探针
                        DBG_MON_ATTITUDE_UPDATE(&vs);
                    }
                    last_imu_ts = pkt.timestamp;
                    break;
                }
                case SENSOR_ID_DPS310: { // 气压计到达：触发高度观测
                    float alt = 44330.0f * (1.0f - powf(pkt.data.DPS310.pressure / eskf.base_baro, 0.190295f));
                    eskf.UpdateBaro(alt);
                    break;
                }
                case SENSOR_ID_MMC5983: { // 磁力计到达：触发航向观测
                    eskf.UpdateMag(pkt.data.MMC5983.mag);
                    break;
                }
                case SENSOR_ID_PMW3901: { // 光流到达：触发XY速度观测
                    if (last_flow_ts != 0 && pkt.data.PMW3901.squal >= 20.0f) {
                        float dt = (pkt.timestamp - last_flow_ts) * 1e-9f;
                        if (dt > 0.0f && dt < 0.1f) {
                            eskf.UpdateFlow(pkt.data.PMW3901.delta_x, pkt.data.PMW3901.delta_y, dt);
                        }
                    }
                    last_flow_ts = pkt.timestamp;
                    break;
                }
                default:
                    break;
            }
        }
    }
}
void ESKF::UpdateAccel(const float acc[3])
{
    // 1. 扣除零偏求当前真实加速度的模长 (m/s^2)
    float true_acc[3] = {acc[0] - ba[0], acc[1] - ba[1], acc[2] - ba[2]};
    float norm        = sqrtf(true_acc[0] * true_acc[0] + true_acc[1] * true_acc[1] + true_acc[2] * true_acc[2]);

    // 2. 只有在无剧烈机动时才使用加速度计修正姿态 (约 0.8G ~ 1.2G)
    // 避免机动时的异常加速度干扰重力方向
    if (norm < 8.0f || norm > 11.5f) return;

    // 3. 归一化测量向量 (机体坐标系下的重力支持力方向向量)
    float v_meas[3] = {true_acc[0] / norm, true_acc[1] / norm, true_acc[2] / norm};

    // 4. 计算期望的归一化重力向量
    // (NED坐标系下重力向下为 [0, 0, 1]，转换到机体坐标系即为旋转矩阵的第三列转置。
    // 由于加速度计测到的是向上的支持力，方向与重力相反，所以取负)
    float Rmat[3][3];
    GetRotationMatrix(Rmat);
    float v_pred[3] = {-Rmat[0][2], -Rmat[1][2], -Rmat[2][2]};

    // 5. 分别对 X、Y、Z 三个轴进行雅可比标量降维更新
    float H[15] = {0};

    // X轴倾角更新
    H[6] = 0.0f;
    H[7] = v_pred[2];
    H[8] = -v_pred[1];
    ScalarUpdate(H, v_meas[0] - v_pred[0], 0.05f); // 0.05f 为观测方差

    // Y轴倾角更新
    memset(H, 0, sizeof(H));
    H[6] = -v_pred[2];
    H[7] = 0.0f;
    H[8] = v_pred[0];
    ScalarUpdate(H, v_meas[1] - v_pred[1], 0.05f);

    // Z轴倾角更新
    memset(H, 0, sizeof(H));
    H[6] = v_pred[1];
    H[7] = -v_pred[0];
    H[8] = 0.0f;
    ScalarUpdate(H, v_meas[2] - v_pred[2], 0.05f);
}

void ESKF::UpdateZUPT(void)
{
    float H[15] = {0};

    // 强制更新 X 轴速度为 0
    H[3] = 1.0f;
    ScalarUpdate(H, 0.0f - v[0], 0.005f); // 极小方差，强制收敛

    // 强制更新 Y 轴速度为 0
    memset(H, 0, sizeof(H));
    H[4] = 1.0f;
    ScalarUpdate(H, 0.0f - v[1], 0.005f);

    // 强制更新 Z 轴速度为 0
    memset(H, 0, sizeof(H));
    H[5] = 1.0f;
    ScalarUpdate(H, 0.0f - v[2], 0.005f);
}

void AttitudeEstimator_Init(void)
{
    ESKFTaskHandle = xTaskCreateStatic(
        AttitudeESKF_TaskEntry, "AttEst", 1024, NULL,
        configMAX_PRIORITIES - 3, // 优先级建议低于 Sensor 解析任务，高于未来其它控制逻辑
        ESKFTaskStack, &ESKFTaskTCB);
}
</file>

<file path=".clang-format">
# For more options, open this url: https://clang.llvm.net.cn/docs/ClangFormatStyleOptions.html
---
BasedOnStyle: Microsoft
IndentWidth: 4
UseTab: Never
TabWidth: 4
ColumnLimit: 0
---
Language: Cpp
AccessModifierOffset: -4
NamespaceIndentation: All
FixNamespaceComments: false
BreakBeforeBraces: Linux
AllowShortIfStatementsOnASingleLine: true
AllowShortLoopsOnASingleLine: true
AllowShortBlocksOnASingleLine: true
IndentCaseLabels: true
SortIncludes: false
AlignConsecutiveMacros: AcrossEmptyLines
AlignConsecutiveAssignments: Consecutive
</file>

<file path=".cproject">
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?fileVersion 4.0.0?><cproject storage_type_id="org.eclipse.cdt.core.XmlProjectDescriptionStorage">
	<storageModule moduleId="org.eclipse.cdt.core.settings">
		<cconfiguration id="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug.81981667">
			<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug.81981667" moduleId="org.eclipse.cdt.core.settings" name="Debug">
				<externalSettings/>
				<extensions>
					<extension id="org.eclipse.cdt.core.ELF" point="org.eclipse.cdt.core.BinaryParser"/>
					<extension id="org.eclipse.cdt.core.GASErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
					<extension id="org.eclipse.cdt.core.GmakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
					<extension id="org.eclipse.cdt.core.GLDErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
					<extension id="org.eclipse.cdt.core.CWDLocator" point="org.eclipse.cdt.core.ErrorParser"/>
					<extension id="org.eclipse.cdt.core.GCCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
				</extensions>
			</storageModule>
			<storageModule moduleId="cdtBuildSystem" version="4.0.0">
				<configuration artifactExtension="elf" artifactName="${ProjName}" buildArtefactType="org.eclipse.cdt.build.core.buildArtefactType.exe" buildProperties="org.eclipse.cdt.build.core.buildArtefactType=org.eclipse.cdt.build.core.buildArtefactType.exe,org.eclipse.cdt.build.core.buildType=org.eclipse.cdt.build.core.buildType.debug" cleanCommand="rm -rf" description="" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug.81981667" name="Debug" parent="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug">
					<folderInfo id="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug.81981667." name="/" resourcePath="">
						<toolChain id="com.st.stm32cube.ide.mcu.gnu.managedbuild.toolchain.exe.debug.1898152068" name="MCU ARM GCC" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.toolchain.exe.debug">
							<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_mcu.1520828459" name="MCU" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_mcu" value="STM32H743VITx" valueType="string"/>
							<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_cpuid.466076737" name="CPU" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_cpuid" value="0" valueType="string"/>
							<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_coreid.74673653" name="Core" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_coreid" value="0" valueType="string"/>
							<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.fpu.380084530" name="Floating-point unit" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.fpu" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.fpu.value.fpv5-d16" valueType="enumerated"/>
							<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.floatabi.2067162030" name="Floating-point ABI" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.floatabi" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.floatabi.value.hard" valueType="enumerated"/>
							<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_board.307921524" name="Board" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_board" value="genericBoard" valueType="string"/>
							<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.defaults.1227810147" name="Defaults" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.defaults" value="com.st.stm32cube.ide.common.services.build.inputs.revA.1.0.6 || Debug || true || Executable || com.st.stm32cube.ide.mcu.gnu.managedbuild.option.toolchain.value.workspace || STM32H743VITx || 0 || 0 || arm-none-eabi- || ${gnu_tools_for_stm32_compiler_path} || ../Core/Inc | ../Drivers/STM32H7xx_HAL_Driver/Inc | ../Drivers/STM32H7xx_HAL_Driver/Inc/Legacy | ../Middlewares/Third_Party/FreeRTOS/Source/include | ../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 | ../Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM4F | ../Drivers/CMSIS/Device/ST/STM32H7xx/Include | ../Drivers/CMSIS/Include || ../Core/Inc | ../Drivers/STM32H7xx_HAL_Driver/Inc | ../Drivers/STM32H7xx_HAL_Driver/Inc/Legacy | ../Middlewares/Third_Party/FreeRTOS/Source/include | ../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 | ../Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM4F | ../Drivers/CMSIS/Device/ST/STM32H7xx/Include | ../Drivers/CMSIS/Include ||  || USE_PWR_LDO_SUPPLY | USE_HAL_DRIVER | STM32H743xx ||  || Drivers | Core/Startup | Middlewares | Core ||  ||  || ${workspace_loc:/${ProjName}/STM32H743VITX_FLASH.ld} || true || NonSecure ||  || secure_nsclib.o ||  || None ||  ||  || " valueType="string"/>
							<option id="com.st.stm32cube.ide.mcu.debug.option.cpuclock.259643662" superClass="com.st.stm32cube.ide.mcu.debug.option.cpuclock" value="240" valueType="string"/>
							<targetPlatform archList="all" binaryParser="org.eclipse.cdt.core.ELF" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.targetplatform.1764729127" isAbstract="false" osList="all" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.targetplatform"/>
							<builder buildPath="${workspace_loc:/MyDrone}/Debug" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.builder.1669666131" keepEnvironmentInBuildfile="false" managedBuildOn="true" name="Gnu Make Builder" parallelBuildOn="true" parallelizationNumber="optimal" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.builder"/>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.59440939" name="MCU/MPU GCC Assembler" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler">
								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.option.debuglevel.1973401825" name="Debug level" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.option.debuglevel" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.option.debuglevel.value.g3" valueType="enumerated"/>
								<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.option.definedsymbols.1404344691" name="Define symbols (-D)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.option.definedsymbols" valueType="definedSymbols">
									<listOptionValue builtIn="false" value="DEBUG"/>
								</option>
								<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.option.includepaths.2092926506" name="Include paths (-I)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.option.includepaths" valueType="includePath">
									<listOptionValue builtIn="false" value="../Core/Inc"/>
									<listOptionValue builtIn="false" value="../Drivers/STM32H7xx_HAL_Driver/Inc"/>
									<listOptionValue builtIn="false" value="../Drivers/STM32H7xx_HAL_Driver/Inc/Legacy"/>
									<listOptionValue builtIn="false" value="../Middlewares/Third_Party/FreeRTOS/Source/include"/>
									<listOptionValue builtIn="false" value="../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2"/>
									<listOptionValue builtIn="false" value="../Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM4F"/>
									<listOptionValue builtIn="false" value="../Drivers/CMSIS/Device/ST/STM32H7xx/Include"/>
									<listOptionValue builtIn="false" value="../Drivers/CMSIS/Include"/>
								</option>
								<inputType id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.input.1173751211" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.input"/>
							</tool>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.968661359" name="MCU/MPU GCC Compiler" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler">
								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.debuglevel.1354960980" name="Debug level" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.debuglevel" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.debuglevel.value.g3" valueType="enumerated"/>
								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.optimization.level.653606420" name="Optimization level" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.optimization.level"/>
								<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.definedsymbols.722271262" name="Define symbols (-D)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.definedsymbols" valueType="definedSymbols">
									<listOptionValue builtIn="false" value="DEBUG"/>
									<listOptionValue builtIn="false" value="USE_PWR_LDO_SUPPLY"/>
									<listOptionValue builtIn="false" value="USE_HAL_DRIVER"/>
									<listOptionValue builtIn="false" value="STM32H743xx"/>
								</option>
								<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.includepaths.1464509781" name="Include paths (-I)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.includepaths" valueType="includePath">
									<listOptionValue builtIn="false" value="../Core/Inc"/>
									<listOptionValue builtIn="false" value="../Drivers/STM32H7xx_HAL_Driver/Inc"/>
									<listOptionValue builtIn="false" value="../Drivers/STM32H7xx_HAL_Driver/Inc/Legacy"/>
									<listOptionValue builtIn="false" value="../Middlewares/Third_Party/FreeRTOS/Source/include"/>
									<listOptionValue builtIn="false" value="../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2"/>
									<listOptionValue builtIn="false" value="../Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM4F"/>
									<listOptionValue builtIn="false" value="../Drivers/CMSIS/Device/ST/STM32H7xx/Include"/>
									<listOptionValue builtIn="false" value="../Drivers/CMSIS/Include"/>
								</option>
								<inputType id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.input.c.668344827" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.input.c"/>
							</tool>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.837562616" name="MCU/MPU G++ Compiler" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler">
								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.debuglevel.1342926953" name="Debug level" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.debuglevel" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.debuglevel.value.g3" valueType="enumerated"/>
								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.optimization.level.1660208369" name="Optimization level" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.optimization.level"/>
							</tool>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.151516353" name="MCU/MPU GCC Linker" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker">
								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.script.1999712772" name="Linker Script (-T)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.script" value="${workspace_loc:/${ProjName}/STM32H743VITX_FLASH.ld}" valueType="string"/>
								<inputType id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.input.1106541040" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.input">
									<additionalInput kind="additionalinputdependency" paths="$(USER_OBJS)"/>
									<additionalInput kind="additionalinput" paths="$(LIBS)"/>
								</inputType>
							</tool>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.1948595717" name="MCU/MPU G++ Linker" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker"/>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.archiver.182490719" name="MCU/MPU GCC Archiver" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.archiver"/>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.size.446761559" name="MCU Size" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.size"/>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objdump.listfile.26013525" name="MCU Output Converter list file" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objdump.listfile"/>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.hex.1849926619" name="MCU Output Converter Hex" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.hex"/>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.binary.668501020" name="MCU Output Converter Binary" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.binary"/>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.verilog.1007897253" name="MCU Output Converter Verilog" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.verilog"/>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.srec.479354029" name="MCU Output Converter Motorola S-rec" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.srec"/>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.symbolsrec.623959158" name="MCU Output Converter Motorola S-rec with symbols" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.symbolsrec"/>
						</toolChain>
					</folderInfo>
					<sourceEntries>
						<entry flags="VALUE_WORKSPACE_PATH|RESOLVED" kind="sourcePath" name="Core"/>
						<entry flags="VALUE_WORKSPACE_PATH|RESOLVED" kind="sourcePath" name="Middlewares"/>
						<entry flags="VALUE_WORKSPACE_PATH|RESOLVED" kind="sourcePath" name="Drivers"/>
					</sourceEntries>
				</configuration>
			</storageModule>
			<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
		</cconfiguration>
		<cconfiguration id="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.release.1471817921">
			<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.release.1471817921" moduleId="org.eclipse.cdt.core.settings" name="Release">
				<externalSettings/>
				<extensions>
					<extension id="org.eclipse.cdt.core.ELF" point="org.eclipse.cdt.core.BinaryParser"/>
					<extension id="org.eclipse.cdt.core.GASErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
					<extension id="org.eclipse.cdt.core.GmakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
					<extension id="org.eclipse.cdt.core.GLDErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
					<extension id="org.eclipse.cdt.core.CWDLocator" point="org.eclipse.cdt.core.ErrorParser"/>
					<extension id="org.eclipse.cdt.core.GCCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
				</extensions>
			</storageModule>
			<storageModule moduleId="cdtBuildSystem" version="4.0.0">
				<configuration artifactExtension="elf" artifactName="${ProjName}" buildArtefactType="org.eclipse.cdt.build.core.buildArtefactType.exe" buildProperties="org.eclipse.cdt.build.core.buildArtefactType=org.eclipse.cdt.build.core.buildArtefactType.exe,org.eclipse.cdt.build.core.buildType=org.eclipse.cdt.build.core.buildType.release" cleanCommand="rm -rf" description="" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.release.1471817921" name="Release" parent="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.release">
					<folderInfo id="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.release.1471817921." name="/" resourcePath="">
						<toolChain id="com.st.stm32cube.ide.mcu.gnu.managedbuild.toolchain.exe.release.1035502647" name="MCU ARM GCC" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.toolchain.exe.release">
							<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_mcu.2054724974" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_mcu" value="STM32H743VITx" valueType="string"/>
							<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_cpuid.1950968557" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_cpuid" value="0" valueType="string"/>
							<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_coreid.914074044" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_coreid" value="0" valueType="string"/>
							<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.fpu.1779983679" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.fpu" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.fpu.value.fpv5-d16" valueType="enumerated"/>
							<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.floatabi.1434092922" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.floatabi" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.floatabi.value.hard" valueType="enumerated"/>
							<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_board.620337661" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_board" value="genericBoard" valueType="string"/>
							<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.defaults.447012625" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.defaults" value="com.st.stm32cube.ide.common.services.build.inputs.revA.1.0.6 || Release || false || Executable || com.st.stm32cube.ide.mcu.gnu.managedbuild.option.toolchain.value.workspace || STM32H743VITx || 0 || 0 || arm-none-eabi- || ${gnu_tools_for_stm32_compiler_path} || ../Core/Inc | ../Drivers/STM32H7xx_HAL_Driver/Inc | ../Drivers/STM32H7xx_HAL_Driver/Inc/Legacy | ../Middlewares/Third_Party/FreeRTOS/Source/include | ../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 | ../Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM4F | ../Drivers/CMSIS/Device/ST/STM32H7xx/Include | ../Drivers/CMSIS/Include || ../Core/Inc | ../Drivers/STM32H7xx_HAL_Driver/Inc | ../Drivers/STM32H7xx_HAL_Driver/Inc/Legacy | ../Middlewares/Third_Party/FreeRTOS/Source/include | ../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 | ../Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM4F | ../Drivers/CMSIS/Device/ST/STM32H7xx/Include | ../Drivers/CMSIS/Include ||  || USE_PWR_LDO_SUPPLY | USE_HAL_DRIVER | STM32H743xx ||  || Drivers | Core/Startup | Middlewares | Core ||  ||  || ${workspace_loc:/${ProjName}/STM32H743VITX_FLASH.ld} || true || NonSecure ||  || secure_nsclib.o ||  || None ||  ||  || " valueType="string"/>
							<option id="com.st.stm32cube.ide.mcu.debug.option.cpuclock.145656639" superClass="com.st.stm32cube.ide.mcu.debug.option.cpuclock" value="240" valueType="string"/>
							<targetPlatform archList="all" binaryParser="org.eclipse.cdt.core.ELF" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.targetplatform.448408067" isAbstract="false" osList="all" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.targetplatform"/>
							<builder buildPath="${workspace_loc:/MyDrone}/Release" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.builder.1382206066" managedBuildOn="true" name="Gnu Make Builder.Release" parallelBuildOn="true" parallelizationNumber="optimal" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.builder"/>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.191194170" name="MCU/MPU GCC Assembler" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler">
								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.option.debuglevel.807362771" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.option.debuglevel" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.option.debuglevel.value.g0" valueType="enumerated"/>
								<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.option.includepaths.2032120538" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.option.includepaths" valueType="includePath">
									<listOptionValue builtIn="false" value="../Core/Inc"/>
									<listOptionValue builtIn="false" value="../Drivers/STM32H7xx_HAL_Driver/Inc"/>
									<listOptionValue builtIn="false" value="../Drivers/STM32H7xx_HAL_Driver/Inc/Legacy"/>
									<listOptionValue builtIn="false" value="../Middlewares/Third_Party/FreeRTOS/Source/include"/>
									<listOptionValue builtIn="false" value="../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2"/>
									<listOptionValue builtIn="false" value="../Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM4F"/>
									<listOptionValue builtIn="false" value="../Drivers/CMSIS/Device/ST/STM32H7xx/Include"/>
									<listOptionValue builtIn="false" value="../Drivers/CMSIS/Include"/>
								</option>
								<inputType id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.input.1252563692" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.input"/>
							</tool>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.1144096641" name="MCU/MPU GCC Compiler" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler">
								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.debuglevel.1943505551" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.debuglevel" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.debuglevel.value.g0" valueType="enumerated"/>
								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.optimization.level.672257631" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.optimization.level" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.optimization.level.value.os" valueType="enumerated"/>
								<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.definedsymbols.336718126" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.definedsymbols" valueType="definedSymbols">
									<listOptionValue builtIn="false" value="USE_PWR_LDO_SUPPLY"/>
									<listOptionValue builtIn="false" value="USE_HAL_DRIVER"/>
									<listOptionValue builtIn="false" value="STM32H743xx"/>
								</option>
								<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.includepaths.229001628" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.includepaths" valueType="includePath">
									<listOptionValue builtIn="false" value="../Core/Inc"/>
									<listOptionValue builtIn="false" value="../Drivers/STM32H7xx_HAL_Driver/Inc"/>
									<listOptionValue builtIn="false" value="../Drivers/STM32H7xx_HAL_Driver/Inc/Legacy"/>
									<listOptionValue builtIn="false" value="../Middlewares/Third_Party/FreeRTOS/Source/include"/>
									<listOptionValue builtIn="false" value="../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2"/>
									<listOptionValue builtIn="false" value="../Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM4F"/>
									<listOptionValue builtIn="false" value="../Drivers/CMSIS/Device/ST/STM32H7xx/Include"/>
									<listOptionValue builtIn="false" value="../Drivers/CMSIS/Include"/>
								</option>
								<inputType id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.input.c.1274200988" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.input.c"/>
							</tool>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.195322292" name="MCU/MPU G++ Compiler" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler">
								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.debuglevel.841627646" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.debuglevel" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.debuglevel.value.g0" valueType="enumerated"/>
								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.optimization.level.182991525" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.optimization.level" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.optimization.level.value.os" valueType="enumerated"/>
							</tool>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.768542024" name="MCU/MPU GCC Linker" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker">
								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.script.1894577305" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.script" value="${workspace_loc:/${ProjName}/STM32H743VITX_FLASH.ld}" valueType="string"/>
								<inputType id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.input.1600872330" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.input">
									<additionalInput kind="additionalinputdependency" paths="$(USER_OBJS)"/>
									<additionalInput kind="additionalinput" paths="$(LIBS)"/>
								</inputType>
							</tool>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.491466823" name="MCU/MPU G++ Linker" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker"/>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.archiver.823739557" name="MCU/MPU GCC Archiver" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.archiver"/>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.size.891006319" name="MCU Size" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.size"/>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objdump.listfile.1152936543" name="MCU Output Converter list file" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objdump.listfile"/>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.hex.186301530" name="MCU Output Converter Hex" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.hex"/>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.binary.1127796356" name="MCU Output Converter Binary" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.binary"/>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.verilog.1154953131" name="MCU Output Converter Verilog" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.verilog"/>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.srec.825488618" name="MCU Output Converter Motorola S-rec" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.srec"/>
							<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.symbolsrec.794554944" name="MCU Output Converter Motorola S-rec with symbols" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.symbolsrec"/>
						</toolChain>
					</folderInfo>
					<sourceEntries>
						<entry flags="VALUE_WORKSPACE_PATH|RESOLVED" kind="sourcePath" name="Core"/>
						<entry flags="VALUE_WORKSPACE_PATH|RESOLVED" kind="sourcePath" name="Middlewares"/>
						<entry flags="VALUE_WORKSPACE_PATH|RESOLVED" kind="sourcePath" name="Drivers"/>
					</sourceEntries>
				</configuration>
			</storageModule>
			<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
		</cconfiguration>
	</storageModule>
	<storageModule moduleId="org.eclipse.cdt.core.pathentry"/>
	<storageModule moduleId="cdtBuildSystem" version="4.0.0">
		<project id="MyDrone.null.614217293" name="MyDrone"/>
	</storageModule>
	<storageModule moduleId="org.eclipse.cdt.core.LanguageSettingsProviders"/>
	<storageModule moduleId="scannerConfiguration">
		<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId=""/>
		<scannerConfigBuildInfo instanceId="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.release.1471817921;com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.release.1471817921.;com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.1144096641;com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.input.c.1274200988">
			<autodiscovery enabled="false" problemReportingEnabled="true" selectedProfileId=""/>
		</scannerConfigBuildInfo>
		<scannerConfigBuildInfo instanceId="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug.81981667;com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug.81981667.;com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.968661359;com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.input.c.668344827">
			<autodiscovery enabled="false" problemReportingEnabled="true" selectedProfileId=""/>
		</scannerConfigBuildInfo>
	</storageModule>
</cproject>
</file>

<file path=".eide/files.options.yml">
##########################################################################################
#                        Append Compiler Options For Source Files
##########################################################################################

# syntax:
#   <your pattern>: <compiler options>
# For get pattern syntax, please refer to: https://www.npmjs.com/package/micromatch
#
# examples:
#   'main.cpp':           --cpp11 -Og ...
#   'src/*.c':            -gnu -O2 ...
#   'src/lib/**/*.cpp':   --cpp11 -Os ...
#   '!Application/*.c':   -O0
#   '**/*.c':             -O2 -gnu ...

version: "2.1"
options:
    Debug:
        files: {}
    Release:
        files: {}
</file>

<file path=".gitignore">
# dot files
/.vscode/launch.json
/.settings
/.eide/log
/.eide.usr.ctx.json

# project out
/build
/bin
/obj
/out

# eide template
*.ept
*.eide-template
</file>

<file path=".project">
<?xml version="1.0" encoding="UTF-8"?>
<projectDescription>
	<name>MyDrone</name>
	<comment></comment>
	<projects>
	</projects>
	<buildSpec>
		<buildCommand>
			<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
			<triggers>clean,full,incremental,</triggers>
			<arguments>
			</arguments>
		</buildCommand>
		<buildCommand>
			<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder</name>
			<triggers>full,incremental,</triggers>
			<arguments>
			</arguments>
		</buildCommand>
	</buildSpec>
	<natures>
		<nature>com.st.stm32cube.ide.mcu.MCUProjectNature</nature>
		<nature>org.eclipse.cdt.core.cnature</nature>
		<nature>com.st.stm32cube.ide.mcu.MCUCubeIdeServicesRevAev2ProjectNature</nature>
		<nature>com.st.stm32cube.ide.mcu.MCUCubeProjectNature</nature>
		<nature>com.st.stm32cube.ide.mcu.MCUAdvancedStructureProjectNature</nature>
		<nature>com.st.stm32cube.ide.mcu.MCUSingleCpuProjectNature</nature>
		<nature>com.st.stm32cube.ide.mcu.MCURootProjectNature</nature>
		<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
		<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
	</natures>
</projectDescription>
</file>

<file path=".repomixignore">
# 忽略编译产物、二进制和链接文件
MDK-ARM/
Debug/
Release/
build/
*.o
*.d
*.elf
*.hex
*.bin
*.map
*.axf

# 忽略 ST 官方标准底层库 (AI 早就学过了，不需要再看一遍)
Drivers/STM32H7xx_HAL_Driver/
Drivers/CMSIS/

# 忽略 FreeRTOS 官方底层源码 (仅保留你的应用层逻辑即可)
Middlewares/Third_Party/FreeRTOS/Source/

# 忽略 IDE 缓存和隐藏配置
.settings/
.vscode/
.idea/
*.uvoptx
*.uvprojx
*.launch
.DS_Store
</file>

<file path="Core/Inc/dma.h">
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    dma.h
  * @brief   This file contains all the function prototypes for
  *          the dma.c file
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2026 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __DMA_H__
#define __DMA_H__

#ifdef __cplusplus
extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* DMA memory to memory transfer handles -------------------------------------*/

/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* USER CODE BEGIN Private defines */

/* USER CODE END Private defines */

void MX_DMA_Init(void);

/* USER CODE BEGIN Prototypes */

/* USER CODE END Prototypes */

#ifdef __cplusplus
}
#endif

#endif /* __DMA_H__ */
</file>

<file path="Core/Inc/FreeRTOSConfig.h">
/* USER CODE BEGIN Header */
/*
 * FreeRTOS Kernel V10.3.1
 * Portion Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 * Portion Copyright (C) 2019 StMicroelectronics, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * http://www.FreeRTOS.org
 * http://aws.amazon.com/freertos
 *
 * 1 tab == 4 spaces!
 */
/* USER CODE END Header */

#ifndef FREERTOS_CONFIG_H
#define FREERTOS_CONFIG_H

/*-----------------------------------------------------------
 * Application specific definitions.
 *
 * These definitions should be adjusted for your particular hardware and
 * application requirements.
 *
 * These parameters and more are described within the 'configuration' section of the
 * FreeRTOS API documentation available on the FreeRTOS.org web site.
 *
 * See http://www.freertos.org/a00110.html
 *----------------------------------------------------------*/

/* USER CODE BEGIN Includes */
/* Section where include file can be added */
/* USER CODE END Includes */

/* Ensure definitions are only used by the compiler, and not by the assembler. */
#if defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__)
  #include <stdint.h>
  extern uint32_t SystemCoreClock;
#endif
#ifndef CMSIS_device_header
#define CMSIS_device_header "stm32h7xx.h"
#endif /* CMSIS_device_header */

#define configENABLE_FPU                         1
#define configENABLE_MPU                         0

#define configUSE_PREEMPTION                     1
#define configSUPPORT_STATIC_ALLOCATION          1
#define configSUPPORT_DYNAMIC_ALLOCATION         1
#define configUSE_IDLE_HOOK                      0
#define configUSE_TICK_HOOK                      0
#define configCPU_CLOCK_HZ                       ( SystemCoreClock )
#define configTICK_RATE_HZ                       ((TickType_t)1000)
#define configMAX_PRIORITIES                     ( 56 )
#define configMINIMAL_STACK_SIZE                 ((uint16_t)128)
#define configTOTAL_HEAP_SIZE                    ((size_t)131072)
#define configMAX_TASK_NAME_LEN                  ( 16 )
#define configUSE_TRACE_FACILITY                 1
#define configUSE_16_BIT_TICKS                   0
#define configUSE_MUTEXES                        1
#define configQUEUE_REGISTRY_SIZE                8
#define configCHECK_FOR_STACK_OVERFLOW           2
#define configUSE_RECURSIVE_MUTEXES              1
#define configUSE_COUNTING_SEMAPHORES            1
#define configUSE_PORT_OPTIMISED_TASK_SELECTION  0
/* USER CODE BEGIN MESSAGE_BUFFER_LENGTH_TYPE */
/* Defaults to size_t for backward compatibility, but can be changed
   if lengths will always be less than the number of bytes in a size_t. */
#define configMESSAGE_BUFFER_LENGTH_TYPE         size_t
/* USER CODE END MESSAGE_BUFFER_LENGTH_TYPE */

/* Co-routine definitions. */
#define configUSE_CO_ROUTINES                    0
#define configMAX_CO_ROUTINE_PRIORITIES          ( 2 )

/* Software timer definitions. */
#define configUSE_TIMERS                         1
#define configTIMER_TASK_PRIORITY                ( 40 )
#define configTIMER_QUEUE_LENGTH                 10
#define configTIMER_TASK_STACK_DEPTH             256

/* CMSIS-RTOS V2 flags */
#define configUSE_OS2_THREAD_SUSPEND_RESUME  1
#define configUSE_OS2_THREAD_ENUMERATE       1
#define configUSE_OS2_EVENTFLAGS_FROM_ISR    1
#define configUSE_OS2_THREAD_FLAGS           1
#define configUSE_OS2_TIMER                  1
#define configUSE_OS2_MUTEX                  1

/* Set the following definitions to 1 to include the API function, or zero
to exclude the API function. */
#define INCLUDE_vTaskPrioritySet             1
#define INCLUDE_uxTaskPriorityGet            1
#define INCLUDE_vTaskDelete                  1
#define INCLUDE_vTaskCleanUpResources        0
#define INCLUDE_vTaskSuspend                 1
#define INCLUDE_vTaskDelayUntil              1
#define INCLUDE_vTaskDelay                   1
#define INCLUDE_xTaskGetSchedulerState       1
#define INCLUDE_xTimerPendFunctionCall       1
#define INCLUDE_xQueueGetMutexHolder         1
#define INCLUDE_uxTaskGetStackHighWaterMark  1
#define INCLUDE_xTaskGetCurrentTaskHandle    1
#define INCLUDE_eTaskGetState                1

/*
 * The CMSIS-RTOS V2 FreeRTOS wrapper is dependent on the heap implementation used
 * by the application thus the correct define need to be enabled below
 */
#define USE_FreeRTOS_HEAP_4

/* Cortex-M specific definitions. */
#ifdef __NVIC_PRIO_BITS
 /* __BVIC_PRIO_BITS will be specified when CMSIS is being used. */
 #define configPRIO_BITS         __NVIC_PRIO_BITS
#else
 #define configPRIO_BITS         4
#endif

/* The lowest interrupt priority that can be used in a call to a "set priority"
function. */
#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY   15

/* The highest interrupt priority that can be used by any interrupt service
routine that makes calls to interrupt safe FreeRTOS API functions.  DO NOT CALL
INTERRUPT SAFE FREERTOS API FUNCTIONS FROM ANY INTERRUPT THAT HAS A HIGHER
PRIORITY THAN THIS! (higher priorities are lower numeric values. */
#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY 5

/* Interrupt priorities used by the kernel port layer itself.  These are generic
to all Cortex-M ports, and do not rely on any particular library functions. */
#define configKERNEL_INTERRUPT_PRIORITY 		( configLIBRARY_LOWEST_INTERRUPT_PRIORITY << (8 - configPRIO_BITS) )
/* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!!
See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. */
#define configMAX_SYSCALL_INTERRUPT_PRIORITY 	( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY << (8 - configPRIO_BITS) )

/* Normal assert() semantics without relying on the provision of an assert.h
header file. */
/* USER CODE BEGIN 1 */
#define configASSERT( x ) if ((x) == 0) {taskDISABLE_INTERRUPTS(); for( ;; );}
/* USER CODE END 1 */

/* Definitions that map the FreeRTOS port interrupt handlers to their CMSIS
standard names. */
#define vPortSVCHandler    SVC_Handler
#define xPortPendSVHandler PendSV_Handler

/* IMPORTANT: After 10.3.1 update, Systick_Handler comes from NVIC (if SYS timebase = systick), otherwise from cmsis_os2.c */

#define USE_CUSTOM_SYSTICK_HANDLER_IMPLEMENTATION 0

/* USER CODE BEGIN Defines */
/* Section where parameter definitions can be added (for instance, to override default ones in FreeRTOS.h) */
/* USER CODE END Defines */

#endif /* FREERTOS_CONFIG_H */
</file>

<file path="Core/Inc/gpio.h">
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    gpio.h
  * @brief   This file contains all the function prototypes for
  *          the gpio.c file
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2026 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __GPIO_H__
#define __GPIO_H__

#ifdef __cplusplus
extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* USER CODE BEGIN Private defines */

/* USER CODE END Private defines */

void MX_GPIO_Init(void);

/* USER CODE BEGIN Prototypes */

/* USER CODE END Prototypes */

#ifdef __cplusplus
}
#endif
#endif /*__ GPIO_H__ */
</file>

<file path="Core/Inc/i2c.h">
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    i2c.h
  * @brief   This file contains all the function prototypes for
  *          the i2c.c file
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2026 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __I2C_H__
#define __I2C_H__

#ifdef __cplusplus
extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

extern I2C_HandleTypeDef hi2c1;

/* USER CODE BEGIN Private defines */

/* USER CODE END Private defines */

void MX_I2C1_Init(void);

/* USER CODE BEGIN Prototypes */

/* USER CODE END Prototypes */

#ifdef __cplusplus
}
#endif

#endif /* __I2C_H__ */
</file>

<file path="Core/Inc/spi.h">
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    spi.h
  * @brief   This file contains all the function prototypes for
  *          the spi.c file
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2026 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __SPI_H__
#define __SPI_H__

#ifdef __cplusplus
extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

extern SPI_HandleTypeDef hspi1;

extern SPI_HandleTypeDef hspi2;

extern SPI_HandleTypeDef hspi3;

extern SPI_HandleTypeDef hspi4;

/* USER CODE BEGIN Private defines */

/* USER CODE END Private defines */

void MX_SPI1_Init(void);
void MX_SPI2_Init(void);
void MX_SPI3_Init(void);
void MX_SPI4_Init(void);

/* USER CODE BEGIN Prototypes */

/* USER CODE END Prototypes */

#ifdef __cplusplus
}
#endif

#endif /* __SPI_H__ */
</file>

<file path="Core/Inc/stm32h7xx_hal_conf.h">
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    stm32h7xx_hal_conf.h
  * @author  MCD Application Team
  * @brief   HAL configuration file.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef STM32H7xx_HAL_CONF_H
#define STM32H7xx_HAL_CONF_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Exported types ------------------------------------------------------------*/
/* Exported constants --------------------------------------------------------*/

/* ########################## Module Selection ############################## */
/**
  * @brief This is the list of modules to be used in the HAL driver
  */
#define HAL_MODULE_ENABLED

  /* #define HAL_ADC_MODULE_ENABLED   */
/* #define HAL_FDCAN_MODULE_ENABLED   */
/* #define HAL_FMAC_MODULE_ENABLED   */
/* #define HAL_CEC_MODULE_ENABLED   */
/* #define HAL_COMP_MODULE_ENABLED   */
/* #define HAL_CORDIC_MODULE_ENABLED   */
/* #define HAL_CRC_MODULE_ENABLED   */
/* #define HAL_CRYP_MODULE_ENABLED   */
/* #define HAL_DAC_MODULE_ENABLED   */
/* #define HAL_DCMI_MODULE_ENABLED   */
/* #define HAL_DMA2D_MODULE_ENABLED   */
/* #define HAL_ETH_MODULE_ENABLED   */
/* #define HAL_ETH_LEGACY_MODULE_ENABLED   */
/* #define HAL_NAND_MODULE_ENABLED   */
/* #define HAL_NOR_MODULE_ENABLED   */
/* #define HAL_OTFDEC_MODULE_ENABLED   */
/* #define HAL_SRAM_MODULE_ENABLED   */
/* #define HAL_SDRAM_MODULE_ENABLED   */
/* #define HAL_HASH_MODULE_ENABLED   */
/* #define HAL_HRTIM_MODULE_ENABLED   */
/* #define HAL_HSEM_MODULE_ENABLED   */
/* #define HAL_GFXMMU_MODULE_ENABLED   */
/* #define HAL_JPEG_MODULE_ENABLED   */
/* #define HAL_OPAMP_MODULE_ENABLED   */
/* #define HAL_OSPI_MODULE_ENABLED   */
/* #define HAL_I2S_MODULE_ENABLED   */
/* #define HAL_SMBUS_MODULE_ENABLED   */
/* #define HAL_IWDG_MODULE_ENABLED   */
/* #define HAL_LPTIM_MODULE_ENABLED   */
/* #define HAL_LTDC_MODULE_ENABLED   */
/* #define HAL_QSPI_MODULE_ENABLED   */
/* #define HAL_RAMECC_MODULE_ENABLED   */
/* #define HAL_RNG_MODULE_ENABLED   */
/* #define HAL_RTC_MODULE_ENABLED   */
/* #define HAL_SAI_MODULE_ENABLED   */
/* #define HAL_SD_MODULE_ENABLED   */
/* #define HAL_MMC_MODULE_ENABLED   */
/* #define HAL_SPDIFRX_MODULE_ENABLED   */
#define HAL_SPI_MODULE_ENABLED
/* #define HAL_SWPMI_MODULE_ENABLED   */
#define HAL_TIM_MODULE_ENABLED
/* #define HAL_UART_MODULE_ENABLED   */
/* #define HAL_USART_MODULE_ENABLED   */
/* #define HAL_IRDA_MODULE_ENABLED   */
/* #define HAL_SMARTCARD_MODULE_ENABLED   */
/* #define HAL_WWDG_MODULE_ENABLED   */
/* #define HAL_PCD_MODULE_ENABLED   */
/* #define HAL_HCD_MODULE_ENABLED   */
/* #define HAL_DFSDM_MODULE_ENABLED   */
/* #define HAL_DSI_MODULE_ENABLED   */
/* #define HAL_JPEG_MODULE_ENABLED   */
/* #define HAL_MDIOS_MODULE_ENABLED   */
/* #define HAL_PSSI_MODULE_ENABLED   */
/* #define HAL_DTS_MODULE_ENABLED   */
#define HAL_GPIO_MODULE_ENABLED
#define HAL_DMA_MODULE_ENABLED
#define HAL_MDMA_MODULE_ENABLED
#define HAL_RCC_MODULE_ENABLED
#define HAL_FLASH_MODULE_ENABLED
#define HAL_EXTI_MODULE_ENABLED
#define HAL_PWR_MODULE_ENABLED
#define HAL_I2C_MODULE_ENABLED
#define HAL_CORTEX_MODULE_ENABLED
#define HAL_HSEM_MODULE_ENABLED

/* ########################## Oscillator Values adaptation ####################*/
/**
  * @brief Adjust the value of External High Speed oscillator (HSE) used in your application.
  *        This value is used by the RCC HAL module to compute the system frequency
  *        (when HSE is used as system clock source, directly or through the PLL).
  */
#if !defined  (HSE_VALUE)
#define HSE_VALUE    (25000000UL) /*!< Value of the External oscillator in Hz : FPGA case fixed to 60MHZ */
#endif /* HSE_VALUE */

#if !defined  (HSE_STARTUP_TIMEOUT)
  #define HSE_STARTUP_TIMEOUT    (100UL)   /*!< Time out for HSE start up, in ms */
#endif /* HSE_STARTUP_TIMEOUT */

/**
  * @brief Internal  oscillator (CSI) default value.
  *        This value is the default CSI value after Reset.
  */
#if !defined  (CSI_VALUE)
  #define CSI_VALUE    (4000000UL) /*!< Value of the Internal oscillator in Hz*/
#endif /* CSI_VALUE */

/**
  * @brief Internal High Speed oscillator (HSI) value.
  *        This value is used by the RCC HAL module to compute the system frequency
  *        (when HSI is used as system clock source, directly or through the PLL).
  */
#if !defined  (HSI_VALUE)
  #define HSI_VALUE    (64000000UL) /*!< Value of the Internal oscillator in Hz*/
#endif /* HSI_VALUE */

/**
  * @brief External Low Speed oscillator (LSE) value.
  *        This value is used by the UART, RTC HAL module to compute the system frequency
  */
#if !defined  (LSE_VALUE)
  #define LSE_VALUE    (32768UL) /*!< Value of the External oscillator in Hz*/
#endif /* LSE_VALUE */

#if !defined  (LSE_STARTUP_TIMEOUT)
  #define LSE_STARTUP_TIMEOUT    (5000UL)   /*!< Time out for LSE start up, in ms */
#endif /* LSE_STARTUP_TIMEOUT */

#if !defined  (LSI_VALUE)
  #define LSI_VALUE  (32000UL)              /*!< LSI Typical Value in Hz*/
#endif /* LSI_VALUE */                      /*!< Value of the Internal Low Speed oscillator in Hz
                                              The real value may vary depending on the variations
                                              in voltage and temperature.*/

/**
  * @brief External clock source for I2S peripheral
  *        This value is used by the I2S HAL module to compute the I2S clock source
  *        frequency, this source is inserted directly through I2S_CKIN pad.
  */
#if !defined  (EXTERNAL_CLOCK_VALUE)
  #define EXTERNAL_CLOCK_VALUE    12288000UL /*!< Value of the External clock in Hz*/
#endif /* EXTERNAL_CLOCK_VALUE */

/* Tip: To avoid modifying this file each time you need to use different HSE,
   ===  you can define the HSE value in your toolchain compiler preprocessor. */

/* ########################### System Configuration ######################### */
/**
  * @brief This is the HAL system configuration section
  */
#define  VDD_VALUE                    (3300UL) /*!< Value of VDD in mv */
#define  TICK_INT_PRIORITY            (15UL) /*!< tick interrupt priority */
#define  USE_RTOS                     0
#define  USE_SD_TRANSCEIVER           0U               /*!< use uSD Transceiver */
#define  USE_SPI_CRC	              0U               /*!< use CRC in SPI */

#define  USE_HAL_ADC_REGISTER_CALLBACKS     0U /* ADC register callback disabled     */
#define  USE_HAL_CEC_REGISTER_CALLBACKS     0U /* CEC register callback disabled     */
#define  USE_HAL_COMP_REGISTER_CALLBACKS    0U /* COMP register callback disabled    */
#define  USE_HAL_CORDIC_REGISTER_CALLBACKS  0U /* CORDIC register callback disabled  */
#define  USE_HAL_CRYP_REGISTER_CALLBACKS    0U /* CRYP register callback disabled    */
#define  USE_HAL_DAC_REGISTER_CALLBACKS     0U /* DAC register callback disabled     */
#define  USE_HAL_DCMI_REGISTER_CALLBACKS    0U /* DCMI register callback disabled    */
#define  USE_HAL_DFSDM_REGISTER_CALLBACKS   0U /* DFSDM register callback disabled   */
#define  USE_HAL_DMA2D_REGISTER_CALLBACKS   0U /* DMA2D register callback disabled   */
#define  USE_HAL_DSI_REGISTER_CALLBACKS     0U /* DSI register callback disabled     */
#define  USE_HAL_DTS_REGISTER_CALLBACKS     0U /* DTS register callback disabled     */
#define  USE_HAL_ETH_REGISTER_CALLBACKS     0U /* ETH register callback disabled     */
#define  USE_HAL_FDCAN_REGISTER_CALLBACKS   0U /* FDCAN register callback disabled   */
#define  USE_HAL_FMAC_REGISTER_CALLBACKS    0U /* FMAC register callback disabled  */
#define  USE_HAL_NAND_REGISTER_CALLBACKS    0U /* NAND register callback disabled    */
#define  USE_HAL_NOR_REGISTER_CALLBACKS     0U /* NOR register callback disabled     */
#define  USE_HAL_SDRAM_REGISTER_CALLBACKS   0U /* SDRAM register callback disabled   */
#define  USE_HAL_SRAM_REGISTER_CALLBACKS    0U /* SRAM register callback disabled    */
#define  USE_HAL_HASH_REGISTER_CALLBACKS    0U /* HASH register callback disabled    */
#define  USE_HAL_HCD_REGISTER_CALLBACKS     0U /* HCD register callback disabled     */
#define  USE_HAL_GFXMMU_REGISTER_CALLBACKS  0U /* GFXMMU register callback disabled  */
#define  USE_HAL_HRTIM_REGISTER_CALLBACKS   0U /* HRTIM register callback disabled   */
#define  USE_HAL_I2C_REGISTER_CALLBACKS     0U /* I2C register callback disabled     */
#define  USE_HAL_I2S_REGISTER_CALLBACKS     0U /* I2S register callback disabled     */
#define  USE_HAL_IRDA_REGISTER_CALLBACKS    0U /* IRDA register callback disabled    */
#define  USE_HAL_JPEG_REGISTER_CALLBACKS    0U /* JPEG register callback disabled    */
#define  USE_HAL_LPTIM_REGISTER_CALLBACKS   0U /* LPTIM register callback disabled   */
#define  USE_HAL_LTDC_REGISTER_CALLBACKS    0U /* LTDC register callback disabled    */
#define  USE_HAL_MDIOS_REGISTER_CALLBACKS   0U /* MDIO register callback disabled    */
#define  USE_HAL_MMC_REGISTER_CALLBACKS     0U /* MMC register callback disabled     */
#define  USE_HAL_OPAMP_REGISTER_CALLBACKS   0U /* MDIO register callback disabled    */
#define  USE_HAL_OSPI_REGISTER_CALLBACKS    0U /* OSPI register callback disabled    */
#define  USE_HAL_OTFDEC_REGISTER_CALLBACKS  0U /* OTFDEC register callback disabled  */
#define  USE_HAL_PCD_REGISTER_CALLBACKS     0U /* PCD register callback disabled     */
#define  USE_HAL_QSPI_REGISTER_CALLBACKS    0U /* QSPI register callback disabled    */
#define  USE_HAL_RNG_REGISTER_CALLBACKS     0U /* RNG register callback disabled     */
#define  USE_HAL_RTC_REGISTER_CALLBACKS     0U /* RTC register callback disabled     */
#define  USE_HAL_SAI_REGISTER_CALLBACKS     0U /* SAI register callback disabled     */
#define  USE_HAL_SD_REGISTER_CALLBACKS      0U /* SD register callback disabled      */
#define  USE_HAL_SMARTCARD_REGISTER_CALLBACKS  0U /* SMARTCARD register callback disabled */
#define  USE_HAL_SPDIFRX_REGISTER_CALLBACKS 0U /* SPDIFRX register callback disabled */
#define  USE_HAL_SMBUS_REGISTER_CALLBACKS   0U /* SMBUS register callback disabled   */
#define  USE_HAL_SPI_REGISTER_CALLBACKS     0U /* SPI register callback disabled     */
#define  USE_HAL_SWPMI_REGISTER_CALLBACKS   0U /* SWPMI register callback disabled   */
#define  USE_HAL_TIM_REGISTER_CALLBACKS     0U /* TIM register callback disabled     */
#define  USE_HAL_UART_REGISTER_CALLBACKS    0U /* UART register callback disabled    */
#define  USE_HAL_USART_REGISTER_CALLBACKS   0U /* USART register callback disabled   */
#define  USE_HAL_WWDG_REGISTER_CALLBACKS    0U /* WWDG register callback disabled    */

/* ########################### Ethernet Configuration ######################### */
#define ETH_TX_DESC_CNT         4U  /* number of Ethernet Tx DMA descriptors */
#define ETH_RX_DESC_CNT         4U  /* number of Ethernet Rx DMA descriptors */

#define ETH_MAC_ADDR0    (0x02UL)
#define ETH_MAC_ADDR1    (0x00UL)
#define ETH_MAC_ADDR2    (0x00UL)
#define ETH_MAC_ADDR3    (0x00UL)
#define ETH_MAC_ADDR4    (0x00UL)
#define ETH_MAC_ADDR5    (0x00UL)

/* ########################## Assert Selection ############################## */
/**
  * @brief Uncomment the line below to expanse the "assert_param" macro in the
  *        HAL drivers code
  */
/* #define USE_FULL_ASSERT    1U */

/* Includes ------------------------------------------------------------------*/
/**
  * @brief Include module's header file
  */

#ifdef HAL_RCC_MODULE_ENABLED
  #include "stm32h7xx_hal_rcc.h"
#endif /* HAL_RCC_MODULE_ENABLED */

#ifdef HAL_GPIO_MODULE_ENABLED
  #include "stm32h7xx_hal_gpio.h"
#endif /* HAL_GPIO_MODULE_ENABLED */

#ifdef HAL_DMA_MODULE_ENABLED
  #include "stm32h7xx_hal_dma.h"
#endif /* HAL_DMA_MODULE_ENABLED */

#ifdef HAL_MDMA_MODULE_ENABLED
 #include "stm32h7xx_hal_mdma.h"
#endif /* HAL_MDMA_MODULE_ENABLED */

#ifdef HAL_HASH_MODULE_ENABLED
  #include "stm32h7xx_hal_hash.h"
#endif /* HAL_HASH_MODULE_ENABLED */

#ifdef HAL_DCMI_MODULE_ENABLED
  #include "stm32h7xx_hal_dcmi.h"
#endif /* HAL_DCMI_MODULE_ENABLED */

#ifdef HAL_DMA2D_MODULE_ENABLED
  #include "stm32h7xx_hal_dma2d.h"
#endif /* HAL_DMA2D_MODULE_ENABLED */

#ifdef HAL_DSI_MODULE_ENABLED
  #include "stm32h7xx_hal_dsi.h"
#endif /* HAL_DSI_MODULE_ENABLED */

#ifdef HAL_DFSDM_MODULE_ENABLED
  #include "stm32h7xx_hal_dfsdm.h"
#endif /* HAL_DFSDM_MODULE_ENABLED */

#ifdef HAL_DTS_MODULE_ENABLED
 #include "stm32h7xx_hal_dts.h"
#endif /* HAL_DTS_MODULE_ENABLED */

#ifdef HAL_ETH_MODULE_ENABLED
  #include "stm32h7xx_hal_eth.h"
#endif /* HAL_ETH_MODULE_ENABLED */

#ifdef HAL_ETH_LEGACY_MODULE_ENABLED
  #include "stm32h7xx_hal_eth_legacy.h"
#endif /* HAL_ETH_LEGACY_MODULE_ENABLED */

#ifdef HAL_EXTI_MODULE_ENABLED
  #include "stm32h7xx_hal_exti.h"
#endif /* HAL_EXTI_MODULE_ENABLED */

#ifdef HAL_CORTEX_MODULE_ENABLED
  #include "stm32h7xx_hal_cortex.h"
#endif /* HAL_CORTEX_MODULE_ENABLED */

#ifdef HAL_ADC_MODULE_ENABLED
  #include "stm32h7xx_hal_adc.h"
#endif /* HAL_ADC_MODULE_ENABLED */

#ifdef HAL_FDCAN_MODULE_ENABLED
  #include "stm32h7xx_hal_fdcan.h"
#endif /* HAL_FDCAN_MODULE_ENABLED */

#ifdef HAL_CEC_MODULE_ENABLED
  #include "stm32h7xx_hal_cec.h"
#endif /* HAL_CEC_MODULE_ENABLED */

#ifdef HAL_COMP_MODULE_ENABLED
  #include "stm32h7xx_hal_comp.h"
#endif /* HAL_COMP_MODULE_ENABLED */

#ifdef HAL_CORDIC_MODULE_ENABLED
  #include "stm32h7xx_hal_cordic.h"
#endif /* HAL_CORDIC_MODULE_ENABLED */

#ifdef HAL_CRC_MODULE_ENABLED
  #include "stm32h7xx_hal_crc.h"
#endif /* HAL_CRC_MODULE_ENABLED */

#ifdef HAL_CRYP_MODULE_ENABLED
  #include "stm32h7xx_hal_cryp.h"
#endif /* HAL_CRYP_MODULE_ENABLED */

#ifdef HAL_DAC_MODULE_ENABLED
  #include "stm32h7xx_hal_dac.h"
#endif /* HAL_DAC_MODULE_ENABLED */

#ifdef HAL_FLASH_MODULE_ENABLED
  #include "stm32h7xx_hal_flash.h"
#endif /* HAL_FLASH_MODULE_ENABLED */

#ifdef HAL_GFXMMU_MODULE_ENABLED
  #include "stm32h7xx_hal_gfxmmu.h"
#endif /* HAL_GFXMMU_MODULE_ENABLED */

#ifdef HAL_FMAC_MODULE_ENABLED
  #include "stm32h7xx_hal_fmac.h"
#endif /* HAL_FMAC_MODULE_ENABLED */

#ifdef HAL_HRTIM_MODULE_ENABLED
  #include "stm32h7xx_hal_hrtim.h"
#endif /* HAL_HRTIM_MODULE_ENABLED */

#ifdef HAL_HSEM_MODULE_ENABLED
  #include "stm32h7xx_hal_hsem.h"
#endif /* HAL_HSEM_MODULE_ENABLED */

#ifdef HAL_SRAM_MODULE_ENABLED
  #include "stm32h7xx_hal_sram.h"
#endif /* HAL_SRAM_MODULE_ENABLED */

#ifdef HAL_NOR_MODULE_ENABLED
  #include "stm32h7xx_hal_nor.h"
#endif /* HAL_NOR_MODULE_ENABLED */

#ifdef HAL_NAND_MODULE_ENABLED
  #include "stm32h7xx_hal_nand.h"
#endif /* HAL_NAND_MODULE_ENABLED */

#ifdef HAL_I2C_MODULE_ENABLED
 #include "stm32h7xx_hal_i2c.h"
#endif /* HAL_I2C_MODULE_ENABLED */

#ifdef HAL_I2S_MODULE_ENABLED
 #include "stm32h7xx_hal_i2s.h"
#endif /* HAL_I2S_MODULE_ENABLED */

#ifdef HAL_IWDG_MODULE_ENABLED
 #include "stm32h7xx_hal_iwdg.h"
#endif /* HAL_IWDG_MODULE_ENABLED */

#ifdef HAL_JPEG_MODULE_ENABLED
 #include "stm32h7xx_hal_jpeg.h"
#endif /* HAL_JPEG_MODULE_ENABLED */

#ifdef HAL_MDIOS_MODULE_ENABLED
 #include "stm32h7xx_hal_mdios.h"
#endif /* HAL_MDIOS_MODULE_ENABLED */

#ifdef HAL_MMC_MODULE_ENABLED
 #include "stm32h7xx_hal_mmc.h"
#endif /* HAL_MMC_MODULE_ENABLED */

#ifdef HAL_LPTIM_MODULE_ENABLED
#include "stm32h7xx_hal_lptim.h"
#endif /* HAL_LPTIM_MODULE_ENABLED */

#ifdef HAL_LTDC_MODULE_ENABLED
#include "stm32h7xx_hal_ltdc.h"
#endif /* HAL_LTDC_MODULE_ENABLED */

#ifdef HAL_OPAMP_MODULE_ENABLED
#include "stm32h7xx_hal_opamp.h"
#endif /* HAL_OPAMP_MODULE_ENABLED */

#ifdef HAL_OSPI_MODULE_ENABLED
 #include "stm32h7xx_hal_ospi.h"
#endif /* HAL_OSPI_MODULE_ENABLED */

#ifdef HAL_OTFDEC_MODULE_ENABLED
#include "stm32h7xx_hal_otfdec.h"
#endif /* HAL_OTFDEC_MODULE_ENABLED */

#ifdef HAL_PSSI_MODULE_ENABLED
 #include "stm32h7xx_hal_pssi.h"
#endif /* HAL_PSSI_MODULE_ENABLED */

#ifdef HAL_PWR_MODULE_ENABLED
 #include "stm32h7xx_hal_pwr.h"
#endif /* HAL_PWR_MODULE_ENABLED */

#ifdef HAL_QSPI_MODULE_ENABLED
 #include "stm32h7xx_hal_qspi.h"
#endif /* HAL_QSPI_MODULE_ENABLED */

#ifdef HAL_RAMECC_MODULE_ENABLED
 #include "stm32h7xx_hal_ramecc.h"
#endif /* HAL_RAMECC_MODULE_ENABLED */

#ifdef HAL_RNG_MODULE_ENABLED
 #include "stm32h7xx_hal_rng.h"
#endif /* HAL_RNG_MODULE_ENABLED */

#ifdef HAL_RTC_MODULE_ENABLED
 #include "stm32h7xx_hal_rtc.h"
#endif /* HAL_RTC_MODULE_ENABLED */

#ifdef HAL_SAI_MODULE_ENABLED
 #include "stm32h7xx_hal_sai.h"
#endif /* HAL_SAI_MODULE_ENABLED */

#ifdef HAL_SD_MODULE_ENABLED
 #include "stm32h7xx_hal_sd.h"
#endif /* HAL_SD_MODULE_ENABLED */

#ifdef HAL_SDRAM_MODULE_ENABLED
 #include "stm32h7xx_hal_sdram.h"
#endif /* HAL_SDRAM_MODULE_ENABLED */

#ifdef HAL_SPI_MODULE_ENABLED
 #include "stm32h7xx_hal_spi.h"
#endif /* HAL_SPI_MODULE_ENABLED */

#ifdef HAL_SPDIFRX_MODULE_ENABLED
 #include "stm32h7xx_hal_spdifrx.h"
#endif /* HAL_SPDIFRX_MODULE_ENABLED */

#ifdef HAL_SWPMI_MODULE_ENABLED
 #include "stm32h7xx_hal_swpmi.h"
#endif /* HAL_SWPMI_MODULE_ENABLED */

#ifdef HAL_TIM_MODULE_ENABLED
 #include "stm32h7xx_hal_tim.h"
#endif /* HAL_TIM_MODULE_ENABLED */

#ifdef HAL_UART_MODULE_ENABLED
 #include "stm32h7xx_hal_uart.h"
#endif /* HAL_UART_MODULE_ENABLED */

#ifdef HAL_USART_MODULE_ENABLED
 #include "stm32h7xx_hal_usart.h"
#endif /* HAL_USART_MODULE_ENABLED */

#ifdef HAL_IRDA_MODULE_ENABLED
 #include "stm32h7xx_hal_irda.h"
#endif /* HAL_IRDA_MODULE_ENABLED */

#ifdef HAL_SMARTCARD_MODULE_ENABLED
 #include "stm32h7xx_hal_smartcard.h"
#endif /* HAL_SMARTCARD_MODULE_ENABLED */

#ifdef HAL_SMBUS_MODULE_ENABLED
 #include "stm32h7xx_hal_smbus.h"
#endif /* HAL_SMBUS_MODULE_ENABLED */

#ifdef HAL_WWDG_MODULE_ENABLED
 #include "stm32h7xx_hal_wwdg.h"
#endif /* HAL_WWDG_MODULE_ENABLED */

#ifdef HAL_PCD_MODULE_ENABLED
 #include "stm32h7xx_hal_pcd.h"
#endif /* HAL_PCD_MODULE_ENABLED */

#ifdef HAL_HCD_MODULE_ENABLED
 #include "stm32h7xx_hal_hcd.h"
#endif /* HAL_HCD_MODULE_ENABLED */

/* Exported macro ------------------------------------------------------------*/
#ifdef  USE_FULL_ASSERT
/**
  * @brief  The assert_param macro is used for function's parameters check.
  * @param  expr: If expr is false, it calls assert_failed function
  *         which reports the name of the source file and the source
  *         line number of the call that failed.
  *         If expr is true, it returns no value.
  * @retval None
  */
  #define assert_param(expr) ((expr) ? (void)0U : assert_failed((uint8_t *)__FILE__, __LINE__))
/* Exported functions ------------------------------------------------------- */
  void assert_failed(uint8_t *file, uint32_t line);
#else
  #define assert_param(expr) ((void)0U)
#endif /* USE_FULL_ASSERT */

#ifdef __cplusplus
}
#endif

#endif /* STM32H7xx_HAL_CONF_H */
</file>

<file path="Core/Inc/tim.h">
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    tim.h
  * @brief   This file contains all the function prototypes for
  *          the tim.c file
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2026 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __TIM_H__
#define __TIM_H__

#ifdef __cplusplus
extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

extern TIM_HandleTypeDef htim2;

extern TIM_HandleTypeDef htim4;

/* USER CODE BEGIN Private defines */

/* USER CODE END Private defines */

void MX_TIM2_Init(void);
void MX_TIM4_Init(void);

void HAL_TIM_MspPostInit(TIM_HandleTypeDef *htim);

/* USER CODE BEGIN Prototypes */

/* USER CODE END Prototypes */

#ifdef __cplusplus
}
#endif

#endif /* __TIM_H__ */
</file>

<file path="Core/Src/dma.c">
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    dma.c
  * @brief   This file provides code for the configuration
  *          of all the requested memory to memory DMA transfers.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2026 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "dma.h"

/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/*----------------------------------------------------------------------------*/
/* Configure DMA                                                              */
/*----------------------------------------------------------------------------*/

/* USER CODE BEGIN 1 */

/* USER CODE END 1 */

/**
  * Enable DMA controller clock
  */
void MX_DMA_Init(void)
{

  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();
  __HAL_RCC_DMA2_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Stream0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream0_IRQn, 5, 0);
  HAL_NVIC_EnableIRQ(DMA1_Stream0_IRQn);
  /* DMA1_Stream1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 5, 0);
  HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);
  /* DMA1_Stream2_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream2_IRQn, 5, 0);
  HAL_NVIC_EnableIRQ(DMA1_Stream2_IRQn);
  /* DMA1_Stream3_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream3_IRQn, 5, 0);
  HAL_NVIC_EnableIRQ(DMA1_Stream3_IRQn);
  /* DMA1_Stream4_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream4_IRQn, 5, 0);
  HAL_NVIC_EnableIRQ(DMA1_Stream4_IRQn);
  /* DMA1_Stream5_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream5_IRQn, 5, 0);
  HAL_NVIC_EnableIRQ(DMA1_Stream5_IRQn);
  /* DMA1_Stream6_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream6_IRQn, 5, 0);
  HAL_NVIC_EnableIRQ(DMA1_Stream6_IRQn);
  /* DMA1_Stream7_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream7_IRQn, 5, 0);
  HAL_NVIC_EnableIRQ(DMA1_Stream7_IRQn);
  /* DMA2_Stream0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 5, 0);
  HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);
  /* DMA2_Stream1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream1_IRQn, 5, 0);
  HAL_NVIC_EnableIRQ(DMA2_Stream1_IRQn);

}

/* USER CODE BEGIN 2 */

/* USER CODE END 2 */
</file>

<file path="Core/Src/freertos.c">
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * File Name          : freertos.c
  * Description        : Code for freertos applications
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2026 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "FreeRTOS.h"
#include "task.h"
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN Variables */

/* USER CODE END Variables */
/* Definitions for defaultTask */
osThreadId_t defaultTaskHandle;
const osThreadAttr_t defaultTask_attributes = {
  .name = "defaultTask",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN FunctionPrototypes */

/* USER CODE END FunctionPrototypes */

void StartDefaultTask(void *argument);

void MX_FREERTOS_Init(void); /* (MISRA C 2004 rule 8.1) */

/* Hook prototypes */
void vApplicationStackOverflowHook(xTaskHandle xTask, signed char *pcTaskName);

/* USER CODE BEGIN 4 */
void vApplicationStackOverflowHook(xTaskHandle xTask, signed char *pcTaskName)
{
   /* Run time stack overflow checking is performed if
   configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2. This hook function is
   called if a stack overflow is detected. */
}
/* USER CODE END 4 */

/**
  * @brief  FreeRTOS initialization
  * @param  None
  * @retval None
  */
void MX_FREERTOS_Init(void) {
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* USER CODE BEGIN RTOS_MUTEX */
  /* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* USER CODE BEGIN RTOS_SEMAPHORES */
  /* add semaphores, ... */
  /* USER CODE END RTOS_SEMAPHORES */

  /* USER CODE BEGIN RTOS_TIMERS */
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* USER CODE BEGIN RTOS_QUEUES */
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* creation of defaultTask */
  defaultTaskHandle = osThreadNew(StartDefaultTask, NULL, &defaultTask_attributes);

  /* USER CODE BEGIN RTOS_THREADS */
  /* add threads, ... */
  /* USER CODE END RTOS_THREADS */

  /* USER CODE BEGIN RTOS_EVENTS */
  /* add events, ... */
  /* USER CODE END RTOS_EVENTS */

}

/* USER CODE BEGIN Header_StartDefaultTask */
/**
  * @brief  Function implementing the defaultTask thread.
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_StartDefaultTask */
void StartDefaultTask(void *argument)
{
  /* USER CODE BEGIN StartDefaultTask */
  /* Infinite loop */
  for(;;)
  {
    osDelay(1);
  }
  /* USER CODE END StartDefaultTask */
}

/* Private application code --------------------------------------------------*/
/* USER CODE BEGIN Application */

/* USER CODE END Application */
</file>

<file path="Core/Src/stm32h7xx_hal_msp.c">
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file         stm32h7xx_hal_msp.c
  * @brief        This file provides code for the MSP Initialization
  *               and de-Initialization codes.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2026 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN TD */

/* USER CODE END TD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN Define */

/* USER CODE END Define */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN Macro */

/* USER CODE END Macro */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* External functions --------------------------------------------------------*/
/* USER CODE BEGIN ExternalFunctions */

/* USER CODE END ExternalFunctions */

/* USER CODE BEGIN 0 */

/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}

/* USER CODE BEGIN 1 */

/* USER CODE END 1 */
</file>

<file path="Core/Src/stm32h7xx_hal_timebase_tim.c">
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    stm32h7xx_hal_timebase_tim.c
  * @brief   HAL time base based on the hardware TIM.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2026 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "stm32h7xx_hal.h"
#include "stm32h7xx_hal_tim.h"

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
TIM_HandleTypeDef        htim7;
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

/**
  * @brief  This function configures the TIM7 as a time base source.
  *         The time source is configured  to have 1ms time base with a dedicated
  *         Tick interrupt priority.
  * @note   This function is called  automatically at the beginning of program after
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  RCC_ClkInitTypeDef    clkconfig;
  uint32_t              uwTimclock, uwAPB1Prescaler;
  uint32_t              uwPrescalerValue;
  uint32_t              pFLatency;

  /*Configure the TIM7 IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
   {
     HAL_NVIC_SetPriority(TIM7_IRQn, TickPriority ,0);

     /* Enable the TIM7 global Interrupt */
     HAL_NVIC_EnableIRQ(TIM7_IRQn);
     uwTickPrio = TickPriority;
    }
  else
  {
    return HAL_ERROR;
  }

  /* Enable TIM7 clock */
  __HAL_RCC_TIM7_CLK_ENABLE();

  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);

  /* Get APB1 prescaler */
  uwAPB1Prescaler = clkconfig.APB1CLKDivider;
  /* Compute TIM7 clock */
  if (uwAPB1Prescaler == RCC_HCLK_DIV1)
  {
    uwTimclock = HAL_RCC_GetPCLK1Freq();
  }
  else
  {
    uwTimclock = 2UL * HAL_RCC_GetPCLK1Freq();
  }

  /* Compute the prescaler value to have TIM7 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);

  /* Initialize TIM7 */
  htim7.Instance = TIM7;

  /* Initialize TIMx peripheral as follow:
   * Period = [(TIM7CLK/1000) - 1]. to have a (1/1000) s time base.
   * Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
   * ClockDivision = 0
   * Counter direction = Up
   */
  htim7.Init.Period = (1000000U / 1000U) - 1U;
  htim7.Init.Prescaler = uwPrescalerValue;
  htim7.Init.ClockDivision = 0;
  htim7.Init.CounterMode = TIM_COUNTERMODE_UP;

  if(HAL_TIM_Base_Init(&htim7) == HAL_OK)
  {
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim7);
  }

  /* Return function status */
  return HAL_ERROR;
}

/**
  * @brief  Suspend Tick increment.
  * @note   Disable the tick increment by disabling TIM7 update interrupt.
  * @param  None
  * @retval None
  */
void HAL_SuspendTick(void)
{
  /* Disable TIM7 update Interrupt */
  __HAL_TIM_DISABLE_IT(&htim7, TIM_IT_UPDATE);
}

/**
  * @brief  Resume Tick increment.
  * @note   Enable the tick increment by Enabling TIM7 update interrupt.
  * @param  None
  * @retval None
  */
void HAL_ResumeTick(void)
{
  /* Enable TIM7 Update interrupt */
  __HAL_TIM_ENABLE_IT(&htim7, TIM_IT_UPDATE);
}
</file>

<file path="Core/Src/syscalls.c">
/**
 ******************************************************************************
 * @file      syscalls.c
 * @author    Auto-generated by STM32CubeIDE
 * @brief     STM32CubeIDE Minimal System calls file
 *
 *            For more information about which c-functions
 *            need which of these lowlevel functions
 *            please consult the Newlib libc-manual
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2020-2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/* Includes */
#include <sys/stat.h>
#include <stdlib.h>
#include <errno.h>
#include <stdio.h>
#include <signal.h>
#include <time.h>
#include <sys/time.h>
#include <sys/times.h>


/* Variables */
extern int __io_putchar(int ch) __attribute__((weak));
extern int __io_getchar(void) __attribute__((weak));


char *__env[1] = { 0 };
char **environ = __env;


/* Functions */
void initialise_monitor_handles()
{
}

int _getpid(void)
{
  return 1;
}

int _kill(int pid, int sig)
{
  (void)pid;
  (void)sig;
  errno = EINVAL;
  return -1;
}

void _exit (int status)
{
  _kill(status, -1);
  while (1) {}    /* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
  {
    *ptr++ = __io_getchar();
  }

  return len;
}

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
  {
    __io_putchar(*ptr++);
  }
  return len;
}

int _close(int file)
{
  (void)file;
  return -1;
}


int _fstat(int file, struct stat *st)
{
  (void)file;
  st->st_mode = S_IFCHR;
  return 0;
}

int _isatty(int file)
{
  (void)file;
  return 1;
}

int _lseek(int file, int ptr, int dir)
{
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
}

int _open(char *path, int flags, ...)
{
  (void)path;
  (void)flags;
  /* Pretend like we always fail */
  return -1;
}

int _wait(int *status)
{
  (void)status;
  errno = ECHILD;
  return -1;
}

int _unlink(char *name)
{
  (void)name;
  errno = ENOENT;
  return -1;
}

int _times(struct tms *buf)
{
  (void)buf;
  return -1;
}

int _stat(char *file, struct stat *st)
{
  (void)file;
  st->st_mode = S_IFCHR;
  return 0;
}

int _link(char *old, char *new)
{
  (void)old;
  (void)new;
  errno = EMLINK;
  return -1;
}

int _fork(void)
{
  errno = EAGAIN;
  return -1;
}

int _execve(char *name, char **argv, char **env)
{
  (void)name;
  (void)argv;
  (void)env;
  errno = ENOMEM;
  return -1;
}
</file>

<file path="Core/Src/sysmem.c">
/**
 ******************************************************************************
 * @file      sysmem.c
 * @author    Generated by STM32CubeIDE
 * @brief     STM32CubeIDE System Memory calls file
 *
 *            For more information about which C functions
 *            need which of these lowlevel functions
 *            please consult the newlib libc manual
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/* Includes */
#include <errno.h>
#include <stdint.h>

/**
 * Pointer to the current high watermark of the heap usage
 */
static uint8_t *__sbrk_heap_end = NULL;

/**
 * @brief _sbrk() allocates memory to the newlib heap and is used by malloc
 *        and others from the C library
 *
 * @verbatim
 * ############################################################################
 * #  .data  #  .bss  #       newlib heap       #          MSP stack          #
 * #         #        #                         # Reserved by _Min_Stack_Size #
 * ############################################################################
 * ^-- RAM start      ^-- _end                             _estack, RAM end --^
 * @endverbatim
 *
 * This implementation starts allocating at the '_end' linker symbol
 * The '_Min_Stack_Size' linker symbol reserves a memory for the MSP stack
 * The implementation considers '_estack' linker symbol to be RAM end
 * NOTE: If the MSP stack, at any point during execution, grows larger than the
 * reserved size, please increase the '_Min_Stack_Size'.
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
  const uint8_t *max_heap = (uint8_t *)stack_limit;
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
  {
    __sbrk_heap_end = &_end;
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
  {
    errno = ENOMEM;
    return (void *)-1;
  }

  prev_heap_end = __sbrk_heap_end;
  __sbrk_heap_end += incr;

  return (void *)prev_heap_end;
}
</file>

<file path="Core/Src/system_stm32h7xx.c">
/**
  ******************************************************************************
  * @file    system_stm32h7xx.c
  * @author  MCD Application Team
  * @brief   CMSIS Cortex-Mx Device Peripheral Access Layer System Source File.
  *
  *   This file provides two functions and one global variable to be called from
  *   user application:
  *      - ExitRun0Mode(): Specifies the Power Supply source. This function is
  *                        called at startup just after reset and before the call
  *                        of SystemInit(). This call is made inside
  *                        the "startup_stm32h7xx.s" file.
  *
  *      - SystemInit(): This function is called at startup just after reset and
  *                      before branch to main program. This call is made inside
  *                      the "startup_stm32h7xx.s" file.
  *
  *      - SystemCoreClock variable: Contains the core clock, it can be used
  *                                  by the user application to setup the SysTick
  *                                  timer or configure other parameters.
  *
  *      - SystemCoreClockUpdate(): Updates the variable SystemCoreClock and must
  *                                 be called whenever the core clock is changed
  *                                 during program execution.
  *
  *
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/** @addtogroup CMSIS
  * @{
  */

/** @addtogroup stm32h7xx_system
  * @{
  */

/** @addtogroup STM32H7xx_System_Private_Includes
  * @{
  */

#include "stm32h7xx.h"
#include <math.h>

#if !defined  (HSE_VALUE)
#define HSE_VALUE    ((uint32_t)25000000) /*!< Value of the External oscillator in Hz */
#endif /* HSE_VALUE */

#if !defined  (CSI_VALUE)
  #define CSI_VALUE    ((uint32_t)4000000) /*!< Value of the Internal oscillator in Hz*/
#endif /* CSI_VALUE */

#if !defined  (HSI_VALUE)
  #define HSI_VALUE    ((uint32_t)64000000) /*!< Value of the Internal oscillator in Hz*/
#endif /* HSI_VALUE */


/**
  * @}
  */

/** @addtogroup STM32H7xx_System_Private_TypesDefinitions
  * @{
  */

/**
  * @}
  */

/** @addtogroup STM32H7xx_System_Private_Defines
  * @{
  */

/************************* Miscellaneous Configuration ************************/
/*!< Uncomment the following line if you need to use initialized data in D2 domain SRAM (AHB SRAM) */
/* #define DATA_IN_D2_SRAM */

/* Note: Following vector table addresses must be defined in line with linker
         configuration. */
/*!< Uncomment the following line if you need to relocate the vector table
     anywhere in FLASH BANK1 or AXI SRAM, else the vector table is kept at the automatic
     remap of boot address selected */
/* #define USER_VECT_TAB_ADDRESS */

#if defined(USER_VECT_TAB_ADDRESS)
#if defined(DUAL_CORE) && defined(CORE_CM4)
/*!< Uncomment the following line if you need to relocate your vector Table
     in D2 AXI SRAM else user remap will be done in FLASH BANK2. */
/* #define VECT_TAB_SRAM */
#if defined(VECT_TAB_SRAM)
#define VECT_TAB_BASE_ADDRESS   D2_AXISRAM_BASE   /*!< Vector Table base address field.
                                                       This value must be a multiple of 0x400. */
#define VECT_TAB_OFFSET         0x00000000U       /*!< Vector Table base offset field.
                                                       This value must be a multiple of 0x400. */
#else
#define VECT_TAB_BASE_ADDRESS   FLASH_BANK2_BASE  /*!< Vector Table base address field.
                                                       This value must be a multiple of 0x400. */
#define VECT_TAB_OFFSET         0x00000000U       /*!< Vector Table base offset field.
                                                       This value must be a multiple of 0x400. */
#endif /* VECT_TAB_SRAM */
#else
/*!< Uncomment the following line if you need to relocate your vector Table
     in D1 AXI SRAM else user remap will be done in FLASH BANK1. */
/* #define VECT_TAB_SRAM */
#if defined(VECT_TAB_SRAM)
#define VECT_TAB_BASE_ADDRESS   D1_AXISRAM_BASE   /*!< Vector Table base address field.
                                                       This value must be a multiple of 0x400. */
#define VECT_TAB_OFFSET         0x00000000U       /*!< Vector Table base offset field.
                                                       This value must be a multiple of 0x400. */
#else
#define VECT_TAB_BASE_ADDRESS   FLASH_BANK1_BASE  /*!< Vector Table base address field.
                                                       This value must be a multiple of 0x400. */
#define VECT_TAB_OFFSET         0x00000000U       /*!< Vector Table base offset field.
                                                       This value must be a multiple of 0x400. */
#endif /* VECT_TAB_SRAM */
#endif /* DUAL_CORE && CORE_CM4 */
#endif /* USER_VECT_TAB_ADDRESS */
/******************************************************************************/

/**
  * @}
  */

/** @addtogroup STM32H7xx_System_Private_Macros
  * @{
  */

/**
  * @}
  */

/** @addtogroup STM32H7xx_System_Private_Variables
  * @{
  */
  /* This variable is updated in three ways:
      1) by calling CMSIS function SystemCoreClockUpdate()
      2) by calling HAL API function HAL_RCC_GetHCLKFreq()
      3) each time HAL_RCC_ClockConfig() is called to configure the system clock frequency
         Note: If you use this function to configure the system clock; then there
               is no need to call the 2 first functions listed above, since SystemCoreClock
               variable is updated automatically.
  */
  uint32_t SystemCoreClock = 64000000;
  uint32_t SystemD2Clock = 64000000;
  const  uint8_t D1CorePrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};

/**
  * @}
  */

/** @addtogroup STM32H7xx_System_Private_FunctionPrototypes
  * @{
  */

/**
  * @}
  */

/** @addtogroup STM32H7xx_System_Private_Functions
  * @{
  */

/**
  * @brief  Setup the microcontroller system
  *         Initialize the FPU setting and  vector table location
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
#if defined (DATA_IN_D2_SRAM)
 __IO uint32_t tmpreg;
#endif /* DATA_IN_D2_SRAM */

  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/

   /* Increasing the CPU frequency */
  if(FLASH_LATENCY_DEFAULT  > (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
  }

  /* Set HSION bit */
  RCC->CR |= RCC_CR_HSION;

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;

  /* Reset HSEON, HSECSSON, CSION, HSI48ON, CSIKERON, PLL1ON, PLL2ON and PLL3ON bits */
  RCC->CR &= 0xEAF6ED7FU;

   /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLASH_LATENCY_DEFAULT  < (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
  }

#if defined(D3_SRAM_BASE)
  /* Reset D1CFGR register */
  RCC->D1CFGR = 0x00000000;

  /* Reset D2CFGR register */
  RCC->D2CFGR = 0x00000000;

  /* Reset D3CFGR register */
  RCC->D3CFGR = 0x00000000;
#else
  /* Reset CDCFGR1 register */
  RCC->CDCFGR1 = 0x00000000;

  /* Reset CDCFGR2 register */
  RCC->CDCFGR2 = 0x00000000;

  /* Reset SRDCFGR register */
  RCC->SRDCFGR = 0x00000000;
#endif
  /* Reset PLLCKSELR register */
  RCC->PLLCKSELR = 0x02020200;

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x01FF0000;
  /* Reset PLL1DIVR register */
  RCC->PLL1DIVR = 0x01010280;
  /* Reset PLL1FRACR register */
  RCC->PLL1FRACR = 0x00000000;

  /* Reset PLL2DIVR register */
  RCC->PLL2DIVR = 0x01010280;

  /* Reset PLL2FRACR register */

  RCC->PLL2FRACR = 0x00000000;
  /* Reset PLL3DIVR register */
  RCC->PLL3DIVR = 0x01010280;

  /* Reset PLL3FRACR register */
  RCC->PLL3FRACR = 0x00000000;

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;

#if (STM32H7_DEV_ID == 0x450UL)
  /* dual core CM7 or single core line */
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
  {
    /* if stm32h7 revY*/
    /* Change  the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) */
    *((__IO uint32_t*)0x51008108) = 0x000000001U;
  }
#endif /* STM32H7_DEV_ID */

#if defined(DATA_IN_D2_SRAM)
  /* in case of initialized data in D2 SRAM (AHB SRAM), enable the D2 SRAM clock (AHB SRAM clock) */
#if defined(RCC_AHB2ENR_D2SRAM3EN)
  RCC->AHB2ENR |= (RCC_AHB2ENR_D2SRAM1EN | RCC_AHB2ENR_D2SRAM2EN | RCC_AHB2ENR_D2SRAM3EN);
#elif defined(RCC_AHB2ENR_D2SRAM2EN)
  RCC->AHB2ENR |= (RCC_AHB2ENR_D2SRAM1EN | RCC_AHB2ENR_D2SRAM2EN);
#else
  RCC->AHB2ENR |= (RCC_AHB2ENR_AHBSRAM1EN | RCC_AHB2ENR_AHBSRAM2EN);
#endif /* RCC_AHB2ENR_D2SRAM3EN */

  tmpreg = RCC->AHB2ENR;
  (void) tmpreg;
#endif /* DATA_IN_D2_SRAM */

#if defined(DUAL_CORE) && defined(CORE_CM4)
  /* Configure the Vector Table location add offset address for cortex-M4 ------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal D2 AXI-RAM or in Internal FLASH */
#endif /* USER_VECT_TAB_ADDRESS */

#else
  if(READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN) == 0U)
  {
    /* Enable the FMC interface clock */
    SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);

    /*
     * Disable the FMC bank1 (enabled after reset).
     * This, prevents CPU speculation access on this bank which blocks the use of FMC during
     * 24us. During this time the others FMC master (such as LTDC) cannot use it!
     */
    FMC_Bank1_R->BTCR[0] = 0x000030D2;

    /* Disable the FMC interface clock */
    CLEAR_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);
  }

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal D1 AXI-RAM or in Internal FLASH */
#endif /* USER_VECT_TAB_ADDRESS */

#endif /*DUAL_CORE && CORE_CM4*/
}

/**
  * @brief  Update SystemCoreClock variable according to Clock Register Values.
  *         The SystemCoreClock variable contains the core clock , it can
  *         be used by the user application to setup the SysTick timer or configure
  *         other parameters.
  *
  * @note   Each time the core clock changes, this function must be called
  *         to update SystemCoreClock variable value. Otherwise, any configuration
  *         based on this variable will be incorrect.
  *
  * @note   - The system frequency computed by this function is not the real
  *           frequency in the chip. It is calculated based on the predefined
  *           constant and the selected clock source:
  *
  *           - If SYSCLK source is CSI, SystemCoreClock will contain the CSI_VALUE(*)
  *           - If SYSCLK source is HSI, SystemCoreClock will contain the HSI_VALUE(**)
  *           - If SYSCLK source is HSE, SystemCoreClock will contain the HSE_VALUE(***)
  *           - If SYSCLK source is PLL, SystemCoreClock will contain the CSI_VALUE(*),
  *             HSI_VALUE(**) or HSE_VALUE(***) multiplied/divided by the PLL factors.
  *
  *         (*) CSI_VALUE is a constant defined in stm32h7xx_hal.h file (default value
  *             4 MHz) but the real value may vary depending on the variations
  *             in voltage and temperature.
  *         (**) HSI_VALUE is a constant defined in stm32h7xx_hal.h file (default value
  *             64 MHz) but the real value may vary depending on the variations
  *             in voltage and temperature.
  *
  *         (***)HSE_VALUE is a constant defined in stm32h7xx_hal.h file (default value
  *              25 MHz), user has to ensure that HSE_VALUE is same as the real
  *              frequency of the crystal used. Otherwise, this function may
  *              have wrong result.
  *
  *         - The result of this function could be not correct when using fractional
  *           value for HSE crystal.
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate (void)
{
  uint32_t pllp, pllsource, pllm, pllfracen, hsivalue, tmp;
  uint32_t common_system_clock;
  float_t fracn1, pllvco;


  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
  {
  case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    common_system_clock = (uint32_t) (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3));
    break;

  case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
    common_system_clock = CSI_VALUE;
    break;

  case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    common_system_clock = HSE_VALUE;
    break;

  case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
    pllfracen = ((RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));

    if (pllm != 0U)
    {
      switch (pllsource)
      {
        case RCC_PLLCKSELR_PLLSRC_HSI:  /* HSI used as PLL clock source */

        hsivalue = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3)) ;
        pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );

        break;

        case RCC_PLLCKSELR_PLLSRC_CSI:  /* CSI used as PLL clock source */
          pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
        break;

        case RCC_PLLCKSELR_PLLSRC_HSE:  /* HSE used as PLL clock source */
          pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
        break;

      default:
          hsivalue = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3)) ;
          pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
        break;
      }
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
      common_system_clock =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
    }
    else
    {
      common_system_clock = 0U;
    }
    break;

  default:
    common_system_clock = (uint32_t) (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3));
    break;
  }

  /* Compute SystemClock frequency --------------------------------------------------*/
#if defined (RCC_D1CFGR_D1CPRE)
  tmp = D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos];

  /* common_system_clock frequency : CM7 CPU frequency  */
  common_system_clock >>= tmp;

  /* SystemD2Clock frequency : CM4 CPU, AXI and AHBs Clock frequency  */
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));

#else
  tmp = D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos];

  /* common_system_clock frequency : CM7 CPU frequency  */
  common_system_clock >>= tmp;

  /* SystemD2Clock frequency : AXI and AHBs Clock frequency  */
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE)>> RCC_CDCFGR1_HPRE_Pos]) & 0x1FU));

#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
#endif /* DUAL_CORE && CORE_CM4 */
}

/**
  * @brief  Exit Run* mode and Configure the system Power Supply
  *
  * @note   This function exits the Run* mode and configures the system power supply
  *         according to the definition to be used at compilation preprocessing level.
  *         The application shall set one of the following configuration option:
  *           - PWR_LDO_SUPPLY
  *           - PWR_DIRECT_SMPS_SUPPLY
  *           - PWR_EXTERNAL_SOURCE_SUPPLY
  *           - PWR_SMPS_1V8_SUPPLIES_LDO
  *           - PWR_SMPS_2V5_SUPPLIES_LDO
  *           - PWR_SMPS_1V8_SUPPLIES_EXT_AND_LDO
  *           - PWR_SMPS_2V5_SUPPLIES_EXT_AND_LDO
  *           - PWR_SMPS_1V8_SUPPLIES_EXT
  *           - PWR_SMPS_2V5_SUPPLIES_EXT
  *
  * @note   The function modifies the PWR->CR3 register to enable or disable specific
  *         power supply modes and waits until the voltage level flag is set, indicating
  *         that the power supply configuration is stable.
  *
  * @param  None
  * @retval None
  */
void ExitRun0Mode(void)
{
#if defined(USE_PWR_LDO_SUPPLY)
  #if defined(SMPS)
    /* Exit Run* mode by disabling SMPS and enabling LDO */
    PWR->CR3 = (PWR->CR3 & ~PWR_CR3_SMPSEN) | PWR_CR3_LDOEN;
  #else
    /* Enable LDO mode */
    PWR->CR3 |= PWR_CR3_LDOEN;
  #endif /* SMPS */
  /* Wait till voltage level flag is set */
  while ((PWR->CSR1 & PWR_CSR1_ACTVOSRDY) == 0U)
  {}
#elif defined(USE_PWR_EXTERNAL_SOURCE_SUPPLY)
  #if defined(SMPS)
    /* Exit Run* mode */
    PWR->CR3 = (PWR->CR3 & ~(PWR_CR3_SMPSEN | PWR_CR3_LDOEN)) | PWR_CR3_BYPASS;
  #else
    PWR->CR3 = (PWR->CR3 & ~(PWR_CR3_LDOEN)) | PWR_CR3_BYPASS;
  #endif /* SMPS */
  /* Wait till voltage level flag is set */
  while ((PWR->CSR1 & PWR_CSR1_ACTVOSRDY) == 0U)
  {}
#elif defined(USE_PWR_DIRECT_SMPS_SUPPLY) && defined(SMPS)
  /* Exit Run* mode */
  PWR->CR3 &= ~(PWR_CR3_LDOEN);
  /* Wait till voltage level flag is set */
  while ((PWR->CSR1 & PWR_CSR1_ACTVOSRDY) == 0U)
  {}
#elif defined(USE_PWR_SMPS_1V8_SUPPLIES_LDO) && defined(SMPS)
  /* Exit Run* mode */
  PWR->CR3 |= PWR_CR3_SMPSLEVEL_0 | PWR_CR3_SMPSEN | PWR_CR3_LDOEN;
  /* Wait till voltage level flag is set */
  while ((PWR->CSR1 & PWR_CSR1_ACTVOSRDY) == 0U)
  {}
#elif defined(USE_PWR_SMPS_2V5_SUPPLIES_LDO) && defined(SMPS)
  /* Exit Run* mode */
  PWR->CR3 |= PWR_CR3_SMPSLEVEL_1 | PWR_CR3_SMPSEN | PWR_CR3_LDOEN;
  /* Wait till voltage level flag is set */
  while ((PWR->CSR1 & PWR_CSR1_ACTVOSRDY) == 0U)
  {}
#elif defined(USE_PWR_SMPS_1V8_SUPPLIES_EXT_AND_LDO) && defined(SMPS)
  /* Exit Run* mode */
  PWR->CR3 |= PWR_CR3_SMPSLEVEL_0 | PWR_CR3_SMPSEXTHP | PWR_CR3_SMPSEN | PWR_CR3_LDOEN;
  /* Wait till voltage level flag is set */
  while ((PWR->CSR1 & PWR_CSR1_ACTVOSRDY) == 0U)
  {}
#elif defined(USE_PWR_SMPS_2V5_SUPPLIES_EXT_AND_LDO) && defined(SMPS)
  /* Exit Run* mode */
  PWR->CR3 |= PWR_CR3_SMPSLEVEL_1 | PWR_CR3_SMPSEXTHP | PWR_CR3_SMPSEN | PWR_CR3_LDOEN;
  /* Wait till voltage level flag is set */
  while ((PWR->CSR1 & PWR_CSR1_ACTVOSRDY) == 0U)
  {}
#elif defined(USE_PWR_SMPS_1V8_SUPPLIES_EXT) && defined(SMPS)
  /* Exit Run* mode */
  PWR->CR3 = (PWR->CR3 & ~(PWR_CR3_LDOEN)) | PWR_CR3_SMPSLEVEL_0 | PWR_CR3_SMPSEXTHP | PWR_CR3_SMPSEN | PWR_CR3_BYPASS;
  /* Wait till voltage level flag is set */
  while ((PWR->CSR1 & PWR_CSR1_ACTVOSRDY) == 0U)
  {}
#elif defined(USE_PWR_SMPS_2V5_SUPPLIES_EXT) && defined(SMPS)
  /* Exit Run* mode */
  PWR->CR3 = (PWR->CR3 & ~(PWR_CR3_LDOEN)) | PWR_CR3_SMPSLEVEL_1 | PWR_CR3_SMPSEXTHP | PWR_CR3_SMPSEN | PWR_CR3_BYPASS;
  /* Wait till voltage level flag is set */
  while ((PWR->CSR1 & PWR_CSR1_ACTVOSRDY) == 0U)
  {}
#else
  /* No system power supply configuration is selected at exit Run* mode */
#endif /* USE_PWR_LDO_SUPPLY */
}

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */
</file>

<file path="Core/Src/tim.c">
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    tim.c
  * @brief   This file provides code for the configuration
  *          of the TIM instances.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2026 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "tim.h"

/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

TIM_HandleTypeDef htim2;
TIM_HandleTypeDef htim4;

/* TIM2 init function */
void MX_TIM2_Init(void)
{

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 240-1;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 20000;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 1500;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */
  HAL_TIM_MspPostInit(&htim2);

}
/* TIM4 init function */
void MX_TIM4_Init(void)
{

  /* USER CODE BEGIN TIM4_Init 0 */

  /* USER CODE END TIM4_Init 0 */

  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM4_Init 1 */

  /* USER CODE END TIM4_Init 1 */
  htim4.Instance = TIM4;
  htim4.Init.Prescaler = 240-1;
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim4.Init.Period = 20000;
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_PWM_Init(&htim4) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 1500;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM4_Init 2 */

  /* USER CODE END TIM4_Init 2 */
  HAL_TIM_MspPostInit(&htim4);

}

void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef* tim_pwmHandle)
{

  if(tim_pwmHandle->Instance==TIM2)
  {
  /* USER CODE BEGIN TIM2_MspInit 0 */

  /* USER CODE END TIM2_MspInit 0 */
    /* TIM2 clock enable */
    __HAL_RCC_TIM2_CLK_ENABLE();
  /* USER CODE BEGIN TIM2_MspInit 1 */

  /* USER CODE END TIM2_MspInit 1 */
  }
  else if(tim_pwmHandle->Instance==TIM4)
  {
  /* USER CODE BEGIN TIM4_MspInit 0 */

  /* USER CODE END TIM4_MspInit 0 */
    /* TIM4 clock enable */
    __HAL_RCC_TIM4_CLK_ENABLE();
  /* USER CODE BEGIN TIM4_MspInit 1 */

  /* USER CODE END TIM4_MspInit 1 */
  }
}
void HAL_TIM_MspPostInit(TIM_HandleTypeDef* timHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(timHandle->Instance==TIM2)
  {
  /* USER CODE BEGIN TIM2_MspPostInit 0 */

  /* USER CODE END TIM2_MspPostInit 0 */
    __HAL_RCC_GPIOA_CLK_ENABLE();
    /**TIM2 GPIO Configuration
    PA0     ------> TIM2_CH1
    PA1     ------> TIM2_CH2
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /* USER CODE BEGIN TIM2_MspPostInit 1 */

  /* USER CODE END TIM2_MspPostInit 1 */
  }
  else if(timHandle->Instance==TIM4)
  {
  /* USER CODE BEGIN TIM4_MspPostInit 0 */

  /* USER CODE END TIM4_MspPostInit 0 */

    __HAL_RCC_GPIOD_CLK_ENABLE();
    /**TIM4 GPIO Configuration
    PD12     ------> TIM4_CH1
    PD13     ------> TIM4_CH2
    */
    GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);

  /* USER CODE BEGIN TIM4_MspPostInit 1 */

  /* USER CODE END TIM4_MspPostInit 1 */
  }

}

void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef* tim_pwmHandle)
{

  if(tim_pwmHandle->Instance==TIM2)
  {
  /* USER CODE BEGIN TIM2_MspDeInit 0 */

  /* USER CODE END TIM2_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_TIM2_CLK_DISABLE();
  /* USER CODE BEGIN TIM2_MspDeInit 1 */

  /* USER CODE END TIM2_MspDeInit 1 */
  }
  else if(tim_pwmHandle->Instance==TIM4)
  {
  /* USER CODE BEGIN TIM4_MspDeInit 0 */

  /* USER CODE END TIM4_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_TIM4_CLK_DISABLE();
  /* USER CODE BEGIN TIM4_MspDeInit 1 */

  /* USER CODE END TIM4_MspDeInit 1 */
  }
}

/* USER CODE BEGIN 1 */

/* USER CODE END 1 */
</file>

<file path="Core/Startup/startup_stm32h743vitx.s">
/**
  ******************************************************************************
  * @file      startup_stm32h743xx.s
  * @author    MCD Application Team
  * @brief     STM32H743xx Devices vector table for GCC based toolchain.
  *            This module performs:
  *                - Set the initial SP
  *                - Set the initial PC == Reset_Handler,
  *                - Set the vector table entries with the exceptions ISR address
  *                - Branches to main in the C library (which eventually
  *                  calls main()).
  *            After Reset the Cortex-M processor is in Thread mode,
  *            priority is Privileged, and the Stack is set to Main.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

  .syntax unified
  .cpu cortex-m7
  .fpu softvfp
  .thumb

.global  g_pfnVectors
.global  Default_Handler

/* start address for the initialization values of the .data section.
defined in linker script */
.word  _sidata
/* start address for the .data section. defined in linker script */
.word  _sdata
/* end address for the .data section. defined in linker script */
.word  _edata
/* start address for the .bss section. defined in linker script */
.word  _sbss
/* end address for the .bss section. defined in linker script */
.word  _ebss
/* stack used for SystemInit_ExtMemCtl; always internal RAM used */

/**
 * @brief  This is the code that gets called when the processor first
 *          starts execution following a reset event. Only the absolutely
 *          necessary set is performed, after which the application
 *          supplied main() routine is called.
 * @param  None
 * @retval : None
*/

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack      /* set stack pointer */

/* Call the ExitRun0Mode function to configure the power supply */
  bl  ExitRun0Mode
/* Call the clock system initialization function.*/
  bl  SystemInit

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
  ldr r1, =_edata
  ldr r2, =_sidata
  movs r3, #0
  b LoopCopyDataInit

CopyDataInit:
  ldr r4, [r2, r3]
  str r4, [r0, r3]
  adds r3, r3, #4

LoopCopyDataInit:
  adds r4, r0, r3
  cmp r4, r1
  bcc CopyDataInit
/* Zero fill the bss segment. */
  ldr r2, =_sbss
  ldr r4, =_ebss
  movs r3, #0
  b LoopFillZerobss

FillZerobss:
  str  r3, [r2]
  adds r2, r2, #4

LoopFillZerobss:
  cmp r2, r4
  bcc FillZerobss

/* Call static constructors */
    bl __libc_init_array
/* Call the application's entry point.*/
  bl  main
  bx  lr
.size  Reset_Handler, .-Reset_Handler

/**
 * @brief  This is the code that gets called when the processor receives an
 *         unexpected interrupt.  This simply enters an infinite loop, preserving
 *         the system state for examination by a debugger.
 * @param  None
 * @retval None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
  .size  Default_Handler, .-Default_Handler
/******************************************************************************
*
* The minimal vector table for a Cortex M. Note that the proper constructs
* must be placed on this to ensure that it ends up at physical address
* 0x0000.0000.
*
*******************************************************************************/
   .section  .isr_vector,"a",%progbits
  .type  g_pfnVectors, %object


g_pfnVectors:
  .word  _estack
  .word  Reset_Handler

  .word  NMI_Handler
  .word  HardFault_Handler
  .word  MemManage_Handler
  .word  BusFault_Handler
  .word  UsageFault_Handler
  .word  0
  .word  0
  .word  0
  .word  0
  .word  SVC_Handler
  .word  DebugMon_Handler
  .word  0
  .word  PendSV_Handler
  .word  SysTick_Handler

  /* External Interrupts */
  .word     WWDG_IRQHandler                   /* Window WatchDog              */
  .word     PVD_AVD_IRQHandler                /* PVD/AVD through EXTI Line detection */
  .word     TAMP_STAMP_IRQHandler             /* Tamper and TimeStamps through the EXTI line */
  .word     RTC_WKUP_IRQHandler               /* RTC Wakeup through the EXTI line */
  .word     FLASH_IRQHandler                  /* FLASH                        */
  .word     RCC_IRQHandler                    /* RCC                          */
  .word     EXTI0_IRQHandler                  /* EXTI Line0                   */
  .word     EXTI1_IRQHandler                  /* EXTI Line1                   */
  .word     EXTI2_IRQHandler                  /* EXTI Line2                   */
  .word     EXTI3_IRQHandler                  /* EXTI Line3                   */
  .word     EXTI4_IRQHandler                  /* EXTI Line4                   */
  .word     DMA1_Stream0_IRQHandler           /* DMA1 Stream 0                */
  .word     DMA1_Stream1_IRQHandler           /* DMA1 Stream 1                */
  .word     DMA1_Stream2_IRQHandler           /* DMA1 Stream 2                */
  .word     DMA1_Stream3_IRQHandler           /* DMA1 Stream 3                */
  .word     DMA1_Stream4_IRQHandler           /* DMA1 Stream 4                */
  .word     DMA1_Stream5_IRQHandler           /* DMA1 Stream 5                */
  .word     DMA1_Stream6_IRQHandler           /* DMA1 Stream 6                */
  .word     ADC_IRQHandler                    /* ADC1, ADC2 and ADC3s         */
  .word     FDCAN1_IT0_IRQHandler             /* FDCAN1 interrupt line 0      */
  .word     FDCAN2_IT0_IRQHandler             /* FDCAN2 interrupt line 0      */
  .word     FDCAN1_IT1_IRQHandler             /* FDCAN1 interrupt line 1      */
  .word     FDCAN2_IT1_IRQHandler             /* FDCAN2 interrupt line 1      */
  .word     EXTI9_5_IRQHandler                /* External Line[9:5]s          */
  .word     TIM1_BRK_IRQHandler               /* TIM1 Break interrupt         */
  .word     TIM1_UP_IRQHandler                /* TIM1 Update interrupt        */
  .word     TIM1_TRG_COM_IRQHandler           /* TIM1 Trigger and Commutation interrupt */
  .word     TIM1_CC_IRQHandler                /* TIM1 Capture Compare         */
  .word     TIM2_IRQHandler                   /* TIM2                         */
  .word     TIM3_IRQHandler                   /* TIM3                         */
  .word     TIM4_IRQHandler                   /* TIM4                         */
  .word     I2C1_EV_IRQHandler                /* I2C1 Event                   */
  .word     I2C1_ER_IRQHandler                /* I2C1 Error                   */
  .word     I2C2_EV_IRQHandler                /* I2C2 Event                   */
  .word     I2C2_ER_IRQHandler                /* I2C2 Error                   */
  .word     SPI1_IRQHandler                   /* SPI1                         */
  .word     SPI2_IRQHandler                   /* SPI2                         */
  .word     USART1_IRQHandler                 /* USART1                       */
  .word     USART2_IRQHandler                 /* USART2                       */
  .word     USART3_IRQHandler                 /* USART3                       */
  .word     EXTI15_10_IRQHandler              /* External Line[15:10]s        */
  .word     RTC_Alarm_IRQHandler              /* RTC Alarm (A and B) through EXTI Line */
  .word     0                                 /* Reserved                     */
  .word     TIM8_BRK_TIM12_IRQHandler         /* TIM8 Break and TIM12         */
  .word     TIM8_UP_TIM13_IRQHandler          /* TIM8 Update and TIM13        */
  .word     TIM8_TRG_COM_TIM14_IRQHandler     /* TIM8 Trigger and Commutation and TIM14 */
  .word     TIM8_CC_IRQHandler                /* TIM8 Capture Compare         */
  .word     DMA1_Stream7_IRQHandler           /* DMA1 Stream7                 */
  .word     FMC_IRQHandler                    /* FMC                          */
  .word     SDMMC1_IRQHandler                 /* SDMMC1                       */
  .word     TIM5_IRQHandler                   /* TIM5                         */
  .word     SPI3_IRQHandler                   /* SPI3                         */
  .word     UART4_IRQHandler                  /* UART4                        */
  .word     UART5_IRQHandler                  /* UART5                        */
  .word     TIM6_DAC_IRQHandler               /* TIM6 and DAC1&2 underrun errors */
  .word     TIM7_IRQHandler                   /* TIM7                         */
  .word     DMA2_Stream0_IRQHandler           /* DMA2 Stream 0                */
  .word     DMA2_Stream1_IRQHandler           /* DMA2 Stream 1                */
  .word     DMA2_Stream2_IRQHandler           /* DMA2 Stream 2                */
  .word     DMA2_Stream3_IRQHandler           /* DMA2 Stream 3                */
  .word     DMA2_Stream4_IRQHandler           /* DMA2 Stream 4                */
  .word     ETH_IRQHandler                    /* Ethernet                     */
  .word     ETH_WKUP_IRQHandler               /* Ethernet Wakeup through EXTI line */
  .word     FDCAN_CAL_IRQHandler              /* FDCAN calibration unit interrupt*/
  .word     0                                 /* Reserved                     */
  .word     0                                 /* Reserved                     */
  .word     0                                 /* Reserved                     */
  .word     0                                 /* Reserved                     */
  .word     DMA2_Stream5_IRQHandler           /* DMA2 Stream 5                */
  .word     DMA2_Stream6_IRQHandler           /* DMA2 Stream 6                */
  .word     DMA2_Stream7_IRQHandler           /* DMA2 Stream 7                */
  .word     USART6_IRQHandler                 /* USART6                       */
  .word     I2C3_EV_IRQHandler                /* I2C3 event                   */
  .word     I2C3_ER_IRQHandler                /* I2C3 error                   */
  .word     OTG_HS_EP1_OUT_IRQHandler         /* USB OTG HS End Point 1 Out   */
  .word     OTG_HS_EP1_IN_IRQHandler          /* USB OTG HS End Point 1 In    */
  .word     OTG_HS_WKUP_IRQHandler            /* USB OTG HS Wakeup through EXTI */
  .word     OTG_HS_IRQHandler                 /* USB OTG HS                   */
  .word     DCMI_IRQHandler                   /* DCMI                         */
  .word     0                                 /* Reserved                     */
  .word     RNG_IRQHandler                    /* Rng                          */
  .word     FPU_IRQHandler                    /* FPU                          */
  .word     UART7_IRQHandler                  /* UART7                        */
  .word     UART8_IRQHandler                  /* UART8                        */
  .word     SPI4_IRQHandler                   /* SPI4                         */
  .word     SPI5_IRQHandler                   /* SPI5                         */
  .word     SPI6_IRQHandler                   /* SPI6                         */
  .word     SAI1_IRQHandler                   /* SAI1                         */
  .word     LTDC_IRQHandler                   /* LTDC                         */
  .word     LTDC_ER_IRQHandler                /* LTDC error                   */
  .word     DMA2D_IRQHandler                  /* DMA2D                        */
  .word     SAI2_IRQHandler                   /* SAI2                         */
  .word     QUADSPI_IRQHandler                /* QUADSPI                      */
  .word     LPTIM1_IRQHandler                 /* LPTIM1                       */
  .word     CEC_IRQHandler                    /* HDMI_CEC                     */
  .word     I2C4_EV_IRQHandler                /* I2C4 Event                   */
  .word     I2C4_ER_IRQHandler                /* I2C4 Error                   */
  .word     SPDIF_RX_IRQHandler               /* SPDIF_RX                     */
  .word     OTG_FS_EP1_OUT_IRQHandler         /* USB OTG FS End Point 1 Out   */
  .word     OTG_FS_EP1_IN_IRQHandler          /* USB OTG FS End Point 1 In    */
  .word     OTG_FS_WKUP_IRQHandler            /* USB OTG FS Wakeup through EXTI */
  .word     OTG_FS_IRQHandler                 /* USB OTG FS                   */
  .word     DMAMUX1_OVR_IRQHandler            /* DMAMUX1 Overrun interrupt    */
  .word     HRTIM1_Master_IRQHandler          /* HRTIM Master Timer global Interrupt */
  .word     HRTIM1_TIMA_IRQHandler            /* HRTIM Timer A global Interrupt */
  .word     HRTIM1_TIMB_IRQHandler            /* HRTIM Timer B global Interrupt */
  .word     HRTIM1_TIMC_IRQHandler            /* HRTIM Timer C global Interrupt */
  .word     HRTIM1_TIMD_IRQHandler            /* HRTIM Timer D global Interrupt */
  .word     HRTIM1_TIME_IRQHandler            /* HRTIM Timer E global Interrupt */
  .word     HRTIM1_FLT_IRQHandler             /* HRTIM Fault global Interrupt   */
  .word     DFSDM1_FLT0_IRQHandler            /* DFSDM Filter0 Interrupt        */
  .word     DFSDM1_FLT1_IRQHandler            /* DFSDM Filter1 Interrupt        */
  .word     DFSDM1_FLT2_IRQHandler            /* DFSDM Filter2 Interrupt        */
  .word     DFSDM1_FLT3_IRQHandler            /* DFSDM Filter3 Interrupt        */
  .word     SAI3_IRQHandler                   /* SAI3 global Interrupt          */
  .word     SWPMI1_IRQHandler                 /* Serial Wire Interface 1 global interrupt */
  .word     TIM15_IRQHandler                  /* TIM15 global Interrupt      */
  .word     TIM16_IRQHandler                  /* TIM16 global Interrupt      */
  .word     TIM17_IRQHandler                  /* TIM17 global Interrupt      */
  .word     MDIOS_WKUP_IRQHandler             /* MDIOS Wakeup  Interrupt     */
  .word     MDIOS_IRQHandler                  /* MDIOS global Interrupt      */
  .word     JPEG_IRQHandler                   /* JPEG global Interrupt       */
  .word     MDMA_IRQHandler                   /* MDMA global Interrupt       */
  .word     0                                 /* Reserved                    */
  .word     SDMMC2_IRQHandler                 /* SDMMC2 global Interrupt     */
  .word     HSEM1_IRQHandler                  /* HSEM1 global Interrupt      */
  .word     0                                 /* Reserved                    */
  .word     ADC3_IRQHandler                   /* ADC3 global Interrupt       */
  .word     DMAMUX2_OVR_IRQHandler            /* DMAMUX Overrun interrupt    */
  .word     BDMA_Channel0_IRQHandler          /* BDMA Channel 0 global Interrupt */
  .word     BDMA_Channel1_IRQHandler          /* BDMA Channel 1 global Interrupt */
  .word     BDMA_Channel2_IRQHandler          /* BDMA Channel 2 global Interrupt */
  .word     BDMA_Channel3_IRQHandler          /* BDMA Channel 3 global Interrupt */
  .word     BDMA_Channel4_IRQHandler          /* BDMA Channel 4 global Interrupt */
  .word     BDMA_Channel5_IRQHandler          /* BDMA Channel 5 global Interrupt */
  .word     BDMA_Channel6_IRQHandler          /* BDMA Channel 6 global Interrupt */
  .word     BDMA_Channel7_IRQHandler          /* BDMA Channel 7 global Interrupt */
  .word     COMP1_IRQHandler                  /* COMP1 global Interrupt     */
  .word     LPTIM2_IRQHandler                 /* LP TIM2 global interrupt   */
  .word     LPTIM3_IRQHandler                 /* LP TIM3 global interrupt   */
  .word     LPTIM4_IRQHandler                 /* LP TIM4 global interrupt   */
  .word     LPTIM5_IRQHandler                 /* LP TIM5 global interrupt   */
  .word     LPUART1_IRQHandler                /* LP UART1 interrupt         */
  .word     0                                 /* Reserved                   */
  .word     CRS_IRQHandler                    /* Clock Recovery Global Interrupt */
  .word     ECC_IRQHandler                    /* ECC diagnostic Global Interrupt */
  .word     SAI4_IRQHandler                   /* SAI4 global interrupt      */
  .word     0                                 /* Reserved                   */
  .word     0                                 /* Reserved                   */
  .word     WAKEUP_PIN_IRQHandler             /* Interrupt for all 6 wake-up pins */

  .size  g_pfnVectors, .-g_pfnVectors

/*******************************************************************************
*
* Provide weak aliases for each Exception handler to the Default_Handler.
* As they are weak aliases, any function with the same name will override
* this definition.
*
*******************************************************************************/
   .weak      NMI_Handler
   .thumb_set NMI_Handler,Default_Handler

   .weak      HardFault_Handler
   .thumb_set HardFault_Handler,Default_Handler

   .weak      MemManage_Handler
   .thumb_set MemManage_Handler,Default_Handler

   .weak      BusFault_Handler
   .thumb_set BusFault_Handler,Default_Handler

   .weak      UsageFault_Handler
   .thumb_set UsageFault_Handler,Default_Handler

   .weak      SVC_Handler
   .thumb_set SVC_Handler,Default_Handler

   .weak      DebugMon_Handler
   .thumb_set DebugMon_Handler,Default_Handler

   .weak      PendSV_Handler
   .thumb_set PendSV_Handler,Default_Handler

   .weak      SysTick_Handler
   .thumb_set SysTick_Handler,Default_Handler

   .weak      WWDG_IRQHandler
   .thumb_set WWDG_IRQHandler,Default_Handler

   .weak      PVD_AVD_IRQHandler
   .thumb_set PVD_AVD_IRQHandler,Default_Handler

   .weak      TAMP_STAMP_IRQHandler
   .thumb_set TAMP_STAMP_IRQHandler,Default_Handler

   .weak      RTC_WKUP_IRQHandler
   .thumb_set RTC_WKUP_IRQHandler,Default_Handler

   .weak      FLASH_IRQHandler
   .thumb_set FLASH_IRQHandler,Default_Handler

   .weak      RCC_IRQHandler
   .thumb_set RCC_IRQHandler,Default_Handler

   .weak      EXTI0_IRQHandler
   .thumb_set EXTI0_IRQHandler,Default_Handler

   .weak      EXTI1_IRQHandler
   .thumb_set EXTI1_IRQHandler,Default_Handler

   .weak      EXTI2_IRQHandler
   .thumb_set EXTI2_IRQHandler,Default_Handler

   .weak      EXTI3_IRQHandler
   .thumb_set EXTI3_IRQHandler,Default_Handler

   .weak      EXTI4_IRQHandler
   .thumb_set EXTI4_IRQHandler,Default_Handler

   .weak      DMA1_Stream0_IRQHandler
   .thumb_set DMA1_Stream0_IRQHandler,Default_Handler

   .weak      DMA1_Stream1_IRQHandler
   .thumb_set DMA1_Stream1_IRQHandler,Default_Handler

   .weak      DMA1_Stream2_IRQHandler
   .thumb_set DMA1_Stream2_IRQHandler,Default_Handler

   .weak      DMA1_Stream3_IRQHandler
   .thumb_set DMA1_Stream3_IRQHandler,Default_Handler

   .weak      DMA1_Stream4_IRQHandler
   .thumb_set DMA1_Stream4_IRQHandler,Default_Handler

   .weak      DMA1_Stream5_IRQHandler
   .thumb_set DMA1_Stream5_IRQHandler,Default_Handler

   .weak      DMA1_Stream6_IRQHandler
   .thumb_set DMA1_Stream6_IRQHandler,Default_Handler

   .weak      ADC_IRQHandler
   .thumb_set ADC_IRQHandler,Default_Handler

   .weak      FDCAN1_IT0_IRQHandler
   .thumb_set FDCAN1_IT0_IRQHandler,Default_Handler

   .weak      FDCAN2_IT0_IRQHandler
   .thumb_set FDCAN2_IT0_IRQHandler,Default_Handler

   .weak      FDCAN1_IT1_IRQHandler
   .thumb_set FDCAN1_IT1_IRQHandler,Default_Handler

   .weak      FDCAN2_IT1_IRQHandler
   .thumb_set FDCAN2_IT1_IRQHandler,Default_Handler

   .weak      EXTI9_5_IRQHandler
   .thumb_set EXTI9_5_IRQHandler,Default_Handler

   .weak      TIM1_BRK_IRQHandler
   .thumb_set TIM1_BRK_IRQHandler,Default_Handler

   .weak      TIM1_UP_IRQHandler
   .thumb_set TIM1_UP_IRQHandler,Default_Handler

   .weak      TIM1_TRG_COM_IRQHandler
   .thumb_set TIM1_TRG_COM_IRQHandler,Default_Handler

   .weak      TIM1_CC_IRQHandler
   .thumb_set TIM1_CC_IRQHandler,Default_Handler

   .weak      TIM2_IRQHandler
   .thumb_set TIM2_IRQHandler,Default_Handler

   .weak      TIM3_IRQHandler
   .thumb_set TIM3_IRQHandler,Default_Handler

   .weak      TIM4_IRQHandler
   .thumb_set TIM4_IRQHandler,Default_Handler

   .weak      I2C1_EV_IRQHandler
   .thumb_set I2C1_EV_IRQHandler,Default_Handler

   .weak      I2C1_ER_IRQHandler
   .thumb_set I2C1_ER_IRQHandler,Default_Handler

   .weak      I2C2_EV_IRQHandler
   .thumb_set I2C2_EV_IRQHandler,Default_Handler

   .weak      I2C2_ER_IRQHandler
   .thumb_set I2C2_ER_IRQHandler,Default_Handler

   .weak      SPI1_IRQHandler
   .thumb_set SPI1_IRQHandler,Default_Handler

   .weak      SPI2_IRQHandler
   .thumb_set SPI2_IRQHandler,Default_Handler

   .weak      USART1_IRQHandler
   .thumb_set USART1_IRQHandler,Default_Handler

   .weak      USART2_IRQHandler
   .thumb_set USART2_IRQHandler,Default_Handler

   .weak      USART3_IRQHandler
   .thumb_set USART3_IRQHandler,Default_Handler

   .weak      EXTI15_10_IRQHandler
   .thumb_set EXTI15_10_IRQHandler,Default_Handler

   .weak      RTC_Alarm_IRQHandler
   .thumb_set RTC_Alarm_IRQHandler,Default_Handler

   .weak      TIM8_BRK_TIM12_IRQHandler
   .thumb_set TIM8_BRK_TIM12_IRQHandler,Default_Handler

   .weak      TIM8_UP_TIM13_IRQHandler
   .thumb_set TIM8_UP_TIM13_IRQHandler,Default_Handler

   .weak      TIM8_TRG_COM_TIM14_IRQHandler
   .thumb_set TIM8_TRG_COM_TIM14_IRQHandler,Default_Handler

   .weak      TIM8_CC_IRQHandler
   .thumb_set TIM8_CC_IRQHandler,Default_Handler

   .weak      DMA1_Stream7_IRQHandler
   .thumb_set DMA1_Stream7_IRQHandler,Default_Handler

   .weak      FMC_IRQHandler
   .thumb_set FMC_IRQHandler,Default_Handler

   .weak      SDMMC1_IRQHandler
   .thumb_set SDMMC1_IRQHandler,Default_Handler

   .weak      TIM5_IRQHandler
   .thumb_set TIM5_IRQHandler,Default_Handler

   .weak      SPI3_IRQHandler
   .thumb_set SPI3_IRQHandler,Default_Handler

   .weak      UART4_IRQHandler
   .thumb_set UART4_IRQHandler,Default_Handler

   .weak      UART5_IRQHandler
   .thumb_set UART5_IRQHandler,Default_Handler

   .weak      TIM6_DAC_IRQHandler
   .thumb_set TIM6_DAC_IRQHandler,Default_Handler

   .weak      TIM7_IRQHandler
   .thumb_set TIM7_IRQHandler,Default_Handler

   .weak      DMA2_Stream0_IRQHandler
   .thumb_set DMA2_Stream0_IRQHandler,Default_Handler

   .weak      DMA2_Stream1_IRQHandler
   .thumb_set DMA2_Stream1_IRQHandler,Default_Handler

   .weak      DMA2_Stream2_IRQHandler
   .thumb_set DMA2_Stream2_IRQHandler,Default_Handler

   .weak      DMA2_Stream3_IRQHandler
   .thumb_set DMA2_Stream3_IRQHandler,Default_Handler

   .weak      DMA2_Stream4_IRQHandler
   .thumb_set DMA2_Stream4_IRQHandler,Default_Handler

   .weak      ETH_IRQHandler
   .thumb_set ETH_IRQHandler,Default_Handler

   .weak      ETH_WKUP_IRQHandler
   .thumb_set ETH_WKUP_IRQHandler,Default_Handler

   .weak      FDCAN_CAL_IRQHandler
   .thumb_set FDCAN_CAL_IRQHandler,Default_Handler

   .weak      DMA2_Stream5_IRQHandler
   .thumb_set DMA2_Stream5_IRQHandler,Default_Handler

   .weak      DMA2_Stream6_IRQHandler
   .thumb_set DMA2_Stream6_IRQHandler,Default_Handler

   .weak      DMA2_Stream7_IRQHandler
   .thumb_set DMA2_Stream7_IRQHandler,Default_Handler

   .weak      USART6_IRQHandler
   .thumb_set USART6_IRQHandler,Default_Handler

   .weak      I2C3_EV_IRQHandler
   .thumb_set I2C3_EV_IRQHandler,Default_Handler

   .weak      I2C3_ER_IRQHandler
   .thumb_set I2C3_ER_IRQHandler,Default_Handler

   .weak      OTG_HS_EP1_OUT_IRQHandler
   .thumb_set OTG_HS_EP1_OUT_IRQHandler,Default_Handler

   .weak      OTG_HS_EP1_IN_IRQHandler
   .thumb_set OTG_HS_EP1_IN_IRQHandler,Default_Handler

   .weak      OTG_HS_WKUP_IRQHandler
   .thumb_set OTG_HS_WKUP_IRQHandler,Default_Handler

   .weak      OTG_HS_IRQHandler
   .thumb_set OTG_HS_IRQHandler,Default_Handler

   .weak      DCMI_IRQHandler
   .thumb_set DCMI_IRQHandler,Default_Handler

   .weak      RNG_IRQHandler
   .thumb_set RNG_IRQHandler,Default_Handler

   .weak      FPU_IRQHandler
   .thumb_set FPU_IRQHandler,Default_Handler

   .weak      UART7_IRQHandler
   .thumb_set UART7_IRQHandler,Default_Handler

   .weak      UART8_IRQHandler
   .thumb_set UART8_IRQHandler,Default_Handler

   .weak      SPI4_IRQHandler
   .thumb_set SPI4_IRQHandler,Default_Handler

   .weak      SPI5_IRQHandler
   .thumb_set SPI5_IRQHandler,Default_Handler

   .weak      SPI6_IRQHandler
   .thumb_set SPI6_IRQHandler,Default_Handler

   .weak      SAI1_IRQHandler
   .thumb_set SAI1_IRQHandler,Default_Handler

   .weak      LTDC_IRQHandler
   .thumb_set LTDC_IRQHandler,Default_Handler

   .weak      LTDC_ER_IRQHandler
   .thumb_set LTDC_ER_IRQHandler,Default_Handler

   .weak      DMA2D_IRQHandler
   .thumb_set DMA2D_IRQHandler,Default_Handler

   .weak      SAI2_IRQHandler
   .thumb_set SAI2_IRQHandler,Default_Handler

   .weak      QUADSPI_IRQHandler
   .thumb_set QUADSPI_IRQHandler,Default_Handler

   .weak      LPTIM1_IRQHandler
   .thumb_set LPTIM1_IRQHandler,Default_Handler

   .weak      CEC_IRQHandler
   .thumb_set CEC_IRQHandler,Default_Handler

   .weak      I2C4_EV_IRQHandler
   .thumb_set I2C4_EV_IRQHandler,Default_Handler

   .weak      I2C4_ER_IRQHandler
   .thumb_set I2C4_ER_IRQHandler,Default_Handler

   .weak      SPDIF_RX_IRQHandler
   .thumb_set SPDIF_RX_IRQHandler,Default_Handler

   .weak      OTG_FS_EP1_OUT_IRQHandler
   .thumb_set OTG_FS_EP1_OUT_IRQHandler,Default_Handler

   .weak      OTG_FS_EP1_IN_IRQHandler
   .thumb_set OTG_FS_EP1_IN_IRQHandler,Default_Handler

   .weak      OTG_FS_WKUP_IRQHandler
   .thumb_set OTG_FS_WKUP_IRQHandler,Default_Handler

   .weak      OTG_FS_IRQHandler
   .thumb_set OTG_FS_IRQHandler,Default_Handler

   .weak      DMAMUX1_OVR_IRQHandler
   .thumb_set DMAMUX1_OVR_IRQHandler,Default_Handler

   .weak      HRTIM1_Master_IRQHandler
   .thumb_set HRTIM1_Master_IRQHandler,Default_Handler

   .weak      HRTIM1_TIMA_IRQHandler
   .thumb_set HRTIM1_TIMA_IRQHandler,Default_Handler

   .weak      HRTIM1_TIMB_IRQHandler
   .thumb_set HRTIM1_TIMB_IRQHandler,Default_Handler

   .weak      HRTIM1_TIMC_IRQHandler
   .thumb_set HRTIM1_TIMC_IRQHandler,Default_Handler

   .weak      HRTIM1_TIMD_IRQHandler
   .thumb_set HRTIM1_TIMD_IRQHandler,Default_Handler

   .weak      HRTIM1_TIME_IRQHandler
   .thumb_set HRTIM1_TIME_IRQHandler,Default_Handler

   .weak      HRTIM1_FLT_IRQHandler
   .thumb_set HRTIM1_FLT_IRQHandler,Default_Handler

   .weak      DFSDM1_FLT0_IRQHandler
   .thumb_set DFSDM1_FLT0_IRQHandler,Default_Handler

   .weak      DFSDM1_FLT1_IRQHandler
   .thumb_set DFSDM1_FLT1_IRQHandler,Default_Handler

   .weak      DFSDM1_FLT2_IRQHandler
   .thumb_set DFSDM1_FLT2_IRQHandler,Default_Handler

   .weak      DFSDM1_FLT3_IRQHandler
   .thumb_set DFSDM1_FLT3_IRQHandler,Default_Handler

   .weak      SAI3_IRQHandler
   .thumb_set SAI3_IRQHandler,Default_Handler

   .weak      SWPMI1_IRQHandler
   .thumb_set SWPMI1_IRQHandler,Default_Handler

   .weak      TIM15_IRQHandler
   .thumb_set TIM15_IRQHandler,Default_Handler

   .weak      TIM16_IRQHandler
   .thumb_set TIM16_IRQHandler,Default_Handler

   .weak      TIM17_IRQHandler
   .thumb_set TIM17_IRQHandler,Default_Handler

   .weak      MDIOS_WKUP_IRQHandler
   .thumb_set MDIOS_WKUP_IRQHandler,Default_Handler

   .weak      MDIOS_IRQHandler
   .thumb_set MDIOS_IRQHandler,Default_Handler

   .weak      JPEG_IRQHandler
   .thumb_set JPEG_IRQHandler,Default_Handler

   .weak      MDMA_IRQHandler
   .thumb_set MDMA_IRQHandler,Default_Handler

   .weak      SDMMC2_IRQHandler
   .thumb_set SDMMC2_IRQHandler,Default_Handler

   .weak      HSEM1_IRQHandler
   .thumb_set HSEM1_IRQHandler,Default_Handler

   .weak      ADC3_IRQHandler
   .thumb_set ADC3_IRQHandler,Default_Handler

   .weak      DMAMUX2_OVR_IRQHandler
   .thumb_set DMAMUX2_OVR_IRQHandler,Default_Handler

   .weak      BDMA_Channel0_IRQHandler
   .thumb_set BDMA_Channel0_IRQHandler,Default_Handler

   .weak      BDMA_Channel1_IRQHandler
   .thumb_set BDMA_Channel1_IRQHandler,Default_Handler

   .weak      BDMA_Channel2_IRQHandler
   .thumb_set BDMA_Channel2_IRQHandler,Default_Handler

   .weak      BDMA_Channel3_IRQHandler
   .thumb_set BDMA_Channel3_IRQHandler,Default_Handler

   .weak      BDMA_Channel4_IRQHandler
   .thumb_set BDMA_Channel4_IRQHandler,Default_Handler

   .weak      BDMA_Channel5_IRQHandler
   .thumb_set BDMA_Channel5_IRQHandler,Default_Handler

   .weak      BDMA_Channel6_IRQHandler
   .thumb_set BDMA_Channel6_IRQHandler,Default_Handler

   .weak      BDMA_Channel7_IRQHandler
   .thumb_set BDMA_Channel7_IRQHandler,Default_Handler

   .weak      COMP1_IRQHandler
   .thumb_set COMP1_IRQHandler,Default_Handler

   .weak      LPTIM2_IRQHandler
   .thumb_set LPTIM2_IRQHandler,Default_Handler

   .weak      LPTIM3_IRQHandler
   .thumb_set LPTIM3_IRQHandler,Default_Handler

   .weak      LPTIM4_IRQHandler
   .thumb_set LPTIM4_IRQHandler,Default_Handler

   .weak      LPTIM5_IRQHandler
   .thumb_set LPTIM5_IRQHandler,Default_Handler

   .weak      LPUART1_IRQHandler
   .thumb_set LPUART1_IRQHandler,Default_Handler

   .weak      CRS_IRQHandler
   .thumb_set CRS_IRQHandler,Default_Handler

   .weak      ECC_IRQHandler
   .thumb_set ECC_IRQHandler,Default_Handler

   .weak      SAI4_IRQHandler
   .thumb_set SAI4_IRQHandler,Default_Handler

   .weak      WAKEUP_PIN_IRQHandler
   .thumb_set WAKEUP_PIN_IRQHandler,Default_Handler
</file>

<file path="MyCore/Inc/DebugMonitor.hpp">
#pragma once
#include "main.h"
#include "FreeRTOS.h"
#include "task.h"
#include "DataStructConfig.hpp"

// ==========================================
// 调试模式总开关 (设为 0 时，探针被彻底抹除，编译器实现零性能损耗)
// ==========================================
#define ENABLE_DEBUG_MONITOR 1

#if ENABLE_DEBUG_MONITOR

// 任务健康信息结构体
struct TaskDebugInfo_t {
    TaskHandle_t handle;
    char taskName[configMAX_TASK_NAME_LEN];
    uint32_t stackHighWaterMark; // 栈历史最小剩余量 (单位: Word/4字节，接近 0 时说明即将栈溢出)
    float cpuUsagePercent;       // 过去 1 秒内该任务实际消耗 CPU 算力占比 (%)
    uint32_t _lastRunTime;       // 内部变量
};

struct AttitudeDebugInfo_t {
    uint32_t updateCount;        // 累计完成姿态解算的次数
    uint32_t updatesPerSecondHz; // 当前解算频率 (Hz，理想情况下应等于 ICM42688 的读取频率)
    VehicleState_t latestState;  // 最新解算的姿态与位置数据 (便于直接观察Roll/Pitch/Yaw)

    uint32_t _lastUpdateCount; // 内部变量
};

// 传感器健康与状态信息结构体
struct SensorDebugInfo_t {
    uint32_t attempts;          // 尝试发起总线读取的总次数
    uint32_t successes;         // 成功读取且数据解析有效的总次数
    uint32_t errors;            // 总线传输失败或数据包无效的次数
    uint32_t readsPerSecondHz;  // 当前真实的每秒成功读取次数 (即传感器有效运行频率 Hz)
    float failureRatePercent;   // 累计读取异常失败率 (%)
    Sensor_Packet_t latestData; // 传感器最新数值 (在调试器直接展开看解析好的数值)

    uint32_t _lastSuccesses; // 内部变量
};

// 全局 LiveWatch 聚合观测结构体
struct SystemDebugMonitor_t {
    float totalCpuUsage;    // 系统当前整体业务 CPU 占用率
    uint32_t uptimeSeconds; // 飞控运行时长 (秒)
    uint32_t taskCount;

    TaskDebugInfo_t tasks[15];

    SensorDebugInfo_t icm42688;
    SensorDebugInfo_t pmw3901;
    SensorDebugInfo_t dps310;
    SensorDebugInfo_t mmc5983;
    AttitudeDebugInfo_t attitude;
};

extern SystemDebugMonitor_t g_DebugMonitor; // Live Watch 观测这个变量

void DebugMonitor_Init();
void DebugMonitor_RecordAttempt(SensorID_e id);
void DebugMonitor_RecordSuccess(SensorID_e id, const Sensor_Packet_t *packet);
void DebugMonitor_RecordError(SensorID_e id);
void DebugMonitor_RecordAttitudeUpdate(const VehicleState_t *state);

// 给业务逻辑插装的探针宏
#define DBG_MON_INIT()                 DebugMonitor_Init()
#define DBG_MON_ATTEMPT(id)            DebugMonitor_RecordAttempt(id)
#define DBG_MON_SUCCESS(id, packet)    DebugMonitor_RecordSuccess(id, packet)
#define DBG_MON_ERROR(id)              DebugMonitor_RecordError(id)
#define DBG_MON_ATTITUDE_UPDATE(state) DebugMonitor_RecordAttitudeUpdate(state)
#else // 关闭调试监控，实现绝对的零消耗

#define DBG_MON_INIT()                 ((void)0)
#define DBG_MON_ATTEMPT(id)            ((void)0)
#define DBG_MON_SUCCESS(id, packet)    ((void)0)
#define DBG_MON_ERROR(id)              ((void)0)
#define DBG_MON_ATTITUDE_UPDATE(state) ((void)0)

#endif
</file>

<file path="MyCore/Inc/DTCMinit.h">
#ifndef DTCMINIT_H
#define DTCMINIT_H
/* 这里放函数原型声明 */
void System_DTCM_Init(void);
#endif // !DTCMINIT_H
</file>

<file path="MyCore/Inc/QueueConfig.hpp">
#pragma once

#include"FreeRTOS.h"
#include"queue.h"
extern QueueHandle_t SensorsDataHub;
extern QueueHandle_t VehicleStateQueue;
void SystemQueueInit(void);
</file>

<file path="MyCore/Src/DebugMonitor.cpp">
#include "DebugMonitor.hpp"
#include <string.h>

#if ENABLE_DEBUG_MONITOR

SystemDebugMonitor_t g_DebugMonitor = {0};
static TaskHandle_t MonitorTaskHandle = NULL;
DTCM_DATA static StackType_t MonitorTaskStack[256];
DTCM_DATA static StaticTask_t MonitorTaskTCB;

static void DebugMonitor_UpdateSensor(SensorDebugInfo_t* info) {
    uint32_t curSuccesses = info->successes;
    info->readsPerSecondHz = curSuccesses - info->_lastSuccesses;
    info->_lastSuccesses = curSuccesses;
    
    if (info->attempts > 0) {
        info->failureRatePercent = ((float)info->errors / (float)info->attempts) * 100.0f;
    }
}

// 1Hz 后台统计与计算任务
static void DebugMonitor_Task(void* argument) {
    TickType_t xLastWakeTime = xTaskGetTickCount();
    uint32_t lastTotalRunTime = 0;
    
    while (1) {
        vTaskDelayUntil(&xLastWakeTime, pdMS_TO_TICKS(1000));
        g_DebugMonitor.uptimeSeconds++;
        
        // 1. 更新传感器指标 (计算Hz和失败率)
        DebugMonitor_UpdateSensor(&g_DebugMonitor.icm42688);
        DebugMonitor_UpdateSensor(&g_DebugMonitor.pmw3901);
        DebugMonitor_UpdateSensor(&g_DebugMonitor.dps310);
        DebugMonitor_UpdateSensor(&g_DebugMonitor.mmc5983);


        uint32_t curAttUpdates = g_DebugMonitor.attitude.updateCount;
        g_DebugMonitor.attitude.updatesPerSecondHz = curAttUpdates - g_DebugMonitor.attitude._lastUpdateCount;
        g_DebugMonitor.attitude._lastUpdateCount = curAttUpdates;
        
        // 2. 更新任务栈与 CPU 指标
        static TaskStatus_t taskStatusArray[15]; // 使用静态分配避免 pvPortMalloc 碎片化
        uint32_t totalRunTime;
        UBaseType_t numTasks = uxTaskGetSystemState(taskStatusArray, 15, &totalRunTime);
        g_DebugMonitor.taskCount = numTasks;
            
        // 算出近 1 秒内的 CPU 时间增量
        uint32_t deltaTotalTime = totalRunTime - lastTotalRunTime;
        lastTotalRunTime = totalRunTime;
        if (deltaTotalTime == 0) deltaTotalTime = 1; 
            
        float sysTotalCpu = 0.0f;
            
        for (UBaseType_t i = 0; i < numTasks && i < 15; i++) {
            TaskHandle_t handle = taskStatusArray[i].xHandle;
                
            // 根据句柄查找对应的插槽
            int idx = -1;
            for (int j = 0; j < 15; j++) {
                if (g_DebugMonitor.tasks[j].handle == handle) { idx = j; break; }
                if (g_DebugMonitor.tasks[j].handle == NULL)   { idx = j; break; } // 空槽位
            }
                
            if (idx != -1) {
                g_DebugMonitor.tasks[idx].handle = handle;
                strncpy(g_DebugMonitor.tasks[idx].taskName, taskStatusArray[i].pcTaskName, configMAX_TASK_NAME_LEN - 1);
                
                // 写入历史最小栈水位线，单位 Word(4字节)
                g_DebugMonitor.tasks[idx].stackHighWaterMark = taskStatusArray[i].usStackHighWaterMark;
                    
                uint32_t deltaTaskTime = taskStatusArray[i].ulRunTimeCounter - g_DebugMonitor.tasks[idx]._lastRunTime;
                g_DebugMonitor.tasks[idx]._lastRunTime = taskStatusArray[i].ulRunTimeCounter;
                    
                float usage = ((float)deltaTaskTime / (float)deltaTotalTime) * 100.0f;
                g_DebugMonitor.tasks[idx].cpuUsagePercent = usage;
                    
                // 把 IDLE 空闲任务排除，累加真实的飞控业务逻辑总开销
                if (strncmp(taskStatusArray[i].pcTaskName, "IDLE", 4) != 0) {
                    sysTotalCpu += usage;
                }
            }
        }
        g_DebugMonitor.totalCpuUsage = sysTotalCpu;
    }
}

void DebugMonitor_Init() {
    MonitorTaskHandle = xTaskCreateStatic(
        DebugMonitor_Task, "DebugMon", 256, NULL, 
        tskIDLE_PRIORITY + 1, // 极低优先级，绝不挤占任何姿态解算时间
        MonitorTaskStack, &MonitorTaskTCB);
}

void DebugMonitor_RecordAttempt(SensorID_e id) {
    switch (id) {
        case SENSOR_ID_ICM42688: g_DebugMonitor.icm42688.attempts++; break;
        case SENSOR_ID_PMW3901:  g_DebugMonitor.pmw3901.attempts++;  break;
        case SENSOR_ID_DPS310:   g_DebugMonitor.dps310.attempts++;   break;
        case SENSOR_ID_MMC5983:  g_DebugMonitor.mmc5983.attempts++;  break;
        default: break;
    }
}

void DebugMonitor_RecordSuccess(SensorID_e id, const Sensor_Packet_t* packet) {
    SensorDebugInfo_t* info = nullptr;
    switch (id) {
        case SENSOR_ID_ICM42688: info = &g_DebugMonitor.icm42688; break;
        case SENSOR_ID_PMW3901:  info = &g_DebugMonitor.pmw3901;  break;
        case SENSOR_ID_DPS310:   info = &g_DebugMonitor.dps310;   break;
        case SENSOR_ID_MMC5983:  info = &g_DebugMonitor.mmc5983;  break;
        default: return;
    }
    info->successes++;
    if (packet) info->latestData = *packet;
}

void DebugMonitor_RecordError(SensorID_e id) {
    switch (id) {
        case SENSOR_ID_ICM42688: g_DebugMonitor.icm42688.errors++; break;
        case SENSOR_ID_PMW3901:  g_DebugMonitor.pmw3901.errors++;  break;
        case SENSOR_ID_DPS310:   g_DebugMonitor.dps310.errors++;   break;
        case SENSOR_ID_MMC5983:  g_DebugMonitor.mmc5983.errors++;  break;
        default: break;
    }
}

void DebugMonitor_RecordAttitudeUpdate(const VehicleState_t* state) {
    g_DebugMonitor.attitude.updateCount++;
    if (state != nullptr) {
        // 利用结构体赋值特性，瞬间拷贝数据供调试器抓取（耗时基本为0，无需加锁）
        g_DebugMonitor.attitude.latestState = *state;
    }
}

#endif
</file>

<file path="MyCore/Src/DTCMinit.c">
#include "DTCMinit.h"
#include <stdint.h>

extern uint32_t _sidtcm_data; // Load Address (在 Flash 中)
extern uint32_t _sdtcm_data;  // Start Address (在 DTCM 中)
extern uint32_t _edtcm_data;  // End Address (在 DTCM 中)

// .dtcm_bss 相关符号
extern uint32_t _sdtcm_bss; // Start Address
extern uint32_t _edtcm_bss; // End Address

void System_DTCM_Init(void)
{
    uint32_t *src = &_sidtcm_data;
    uint32_t *dst = &_sdtcm_data;
    uint32_t *end = &_edtcm_data;

    if (src != dst)
    {
        while (dst < end)
        {
            *dst++ = *src++;
        }
    }

    uint32_t *bss_start = &_sdtcm_bss;
    uint32_t *bss_end = &_edtcm_bss;

    while (bss_start < bss_end)
    {
        *bss_start++ = 0;
    }
}
</file>

<file path="MyCore/Src/QueueConfig.cpp">
#include "QueueConfig.hpp"
#include "DataStructConfig.hpp"
#include "Sensors.hpp"
QueueHandle_t SensorsDataHub = NULL;
QueueHandle_t VehicleStateQueue=NULL;

void SystemQueueInit(void)
{
    SensorsDataHub    = xQueueCreate(20, sizeof(Sensor_Packet_t));
    VehicleStateQueue = xQueueCreate(1, sizeof(VehicleState_t));
}
</file>

<file path="STM32H743VITX_FLASH.ld">
/*
******************************************************************************
**
**  File        : LinkerScript.ld
**
**  Author      : STM32CubeIDE
**
**  Abstract    : Linker script for STM32H7 series
**                2048Kbytes FLASH and 1056Kbytes RAM
**
**                Set heap size, stack size and stack location according
**                to application requirements.
**
**                Set memory bank area and size if external memory is used.
**
**  Target      : STMicroelectronics STM32
**
**  Distribution: The file is distributed as is, without any warranty
**                of any kind.
**
*****************************************************************************
** @attention
**
** Copyright (c) 2025 STMicroelectronics.
** All rights reserved.
**
** This software is licensed under terms that can be found in the LICENSE file
** in the root directory of this software component.
** If no LICENSE file comes with this software, it is provided AS-IS.
**
****************************************************************************
*/

/* Entry Point */
ENTRY(Reset_Handler)

/* Highest address of the user mode stack */
_estack = ORIGIN(RAM_D1) + LENGTH(RAM_D1);    /* end of RAM */
/* Generate a link error if heap and stack don't fit into RAM */
_Min_Heap_Size = 0x200;      /* required amount of heap  */
_Min_Stack_Size = 0x400; /* required amount of stack */

/* Specify the memory areas */
MEMORY
{
  FLASH (rx)     : ORIGIN = 0x08000000, LENGTH = 2048K
  DTCMRAM (xrw)  : ORIGIN = 0x20000000, LENGTH = 128K
  RAM_D1 (xrw)   : ORIGIN = 0x24000000, LENGTH = 512K
  RAM_D2 (xrw)   : ORIGIN = 0x30000000, LENGTH = 288K
  RAM_D3 (xrw)   : ORIGIN = 0x38000000, LENGTH = 64K
  ITCMRAM (xrw)  : ORIGIN = 0x00000000, LENGTH = 64K
}

/* Define output sections */
SECTIONS
{
  /* The startup code goes first into FLASH */
  .isr_vector :
  {
    . = ALIGN(4);
    KEEP(*(.isr_vector)) /* Startup code */
    . = ALIGN(4);
  } >FLASH

  /* The program code and other data goes into FLASH */
  .text :
  {
    . = ALIGN(4);
    *(.text)           /* .text sections (code) */
    *(.text*)          /* .text* sections (code) */
    *(.glue_7)         /* glue arm to thumb code */
    *(.glue_7t)        /* glue thumb to arm code */
    *(.eh_frame)

    KEEP (*(.init))
    KEEP (*(.fini))

    . = ALIGN(4);
    _etext = .;        /* define a global symbols at end of code */
  } >FLASH

  /* Constant data goes into FLASH */
  .rodata :
  {
    . = ALIGN(4);
    *(.rodata)         /* .rodata sections (constants, strings, etc.) */
    *(.rodata*)        /* .rodata* sections (constants, strings, etc.) */
    . = ALIGN(4);
  } >FLASH

  .ARM.extab (READONLY) : /* The READONLY keyword is only supported in GCC11 and later, remove it if using GCC10 or earlier. */
  {
    *(.ARM.extab* .gnu.linkonce.armextab.*)
  } >FLASH
  .ARM (READONLY) : /* The READONLY keyword is only supported in GCC11 and later, remove it if using GCC10 or earlier. */
  {
    __exidx_start = .;
    *(.ARM.exidx*)
    __exidx_end = .;
  } >FLASH

  .preinit_array (READONLY) : /* The READONLY keyword is only supported in GCC11 and later, remove it if using GCC10 or earlier. */
  {
    PROVIDE_HIDDEN (__preinit_array_start = .);
    KEEP (*(.preinit_array*))
    PROVIDE_HIDDEN (__preinit_array_end = .);
  } >FLASH

  .init_array (READONLY) : /* The READONLY keyword is only supported in GCC11 and later, remove it if using GCC10 or earlier. */
  {
    PROVIDE_HIDDEN (__init_array_start = .);
    KEEP (*(SORT(.init_array.*)))
    KEEP (*(.init_array*))
    PROVIDE_HIDDEN (__init_array_end = .);
  } >FLASH

  .fini_array (READONLY) : /* The READONLY keyword is only supported in GCC11 and later, remove it if using GCC10 or earlier. */
  {
    PROVIDE_HIDDEN (__fini_array_start = .);
    KEEP (*(SORT(.fini_array.*)))
    KEEP (*(.fini_array*))
    PROVIDE_HIDDEN (__fini_array_end = .);
  } >FLASH

  /* used by the startup to initialize data */
  _sidtcm_data = LOADADDR(.dtcm_data);
  .dtcm_data :
  {
    . = ALIGN(4);
    _sdtcm_data = .;       /* DTCM 数据段在 RAM 中的起始地址 */
    *(.dtcm_data)          /* 捕获所有标记为 .dtcm_data 的变量 */
    *(.dtcm_data*)
    . = ALIGN(4);
    _edtcm_data = .;       /* DTCM 数据段在 RAM 中的结束地址 */
  } >DTCMRAM AT> FLASH

  /* 2. DTCM 未初始化/零初始化段 (BSS)
   * 对应 C 代码中的: DTCM_BSS uint8_t buffer[1024]; (如任务栈)
   * NOLOAD 表示这个段不占用 FLASH 空间，只占用 RAM 空间
   */
  .dtcm_bss (NOLOAD) :
  {
    . = ALIGN(4);
    _sdtcm_bss = .;        /* DTCM BSS 段起始地址 */
    *(.dtcm_bss)           /* 捕获所有标记为 .dtcm_bss 的变量 */
    *(.dtcm_bss*)
    . = ALIGN(4);
    _edtcm_bss = .;        /* DTCM BSS 段结束地址 */
  } >DTCMRAM
  _sidata = LOADADDR(.data);

  /* Initialized data sections goes into RAM, load LMA copy after code */
  .data :
  {
    . = ALIGN(4);
    _sdata = .;        /* create a global symbol at data start */
    *(.data)           /* .data sections */
    *(.data*)          /* .data* sections */
    *(.RamFunc)        /* .RamFunc sections */
    *(.RamFunc*)       /* .RamFunc* sections */

    . = ALIGN(4);
    _edata = .;        /* define a global symbol at data end */
  } >RAM_D1 AT> FLASH

  /* Uninitialized data section */
  . = ALIGN(4);
  .bss :
  {
    /* This is used by the startup in order to initialize the .bss section */
    _sbss = .;         /* define a global symbol at bss start */
    __bss_start__ = _sbss;
    *(.bss)
    *(.bss*)
    *(COMMON)

    . = ALIGN(4);
    _ebss = .;         /* define a global symbol at bss end */
    __bss_end__ = _ebss;
  } >RAM_D1

  /* User_heap_stack section, used to check that there is enough RAM left */
  ._user_heap_stack :
  {
    . = ALIGN(8);
    PROVIDE ( end = . );
    PROVIDE ( _end = . );
    . = . + _Min_Heap_Size;
    . = . + _Min_Stack_Size;
    . = ALIGN(8);
  } >RAM_D1

  /* Remove information from the standard libraries */
  /DISCARD/ :
  {
    libc.a ( * )
    libm.a ( * )
    libgcc.a ( * )
  }

  .ARM.attributes 0 : { *(.ARM.attributes) }
}
</file>

<file path="STM32H743VITX_RAM.ld">
/*
******************************************************************************
**
**  File        : LinkerScript.ld (debug in RAM dedicated)
**
**  Author      : STM32CubeIDE
**
**  Abstract    : Linker script for STM32H7 series
**                512Kbytes RAM_EXEC and 544Kbytes RAM
**
**                Set heap size, stack size and stack location according
**                to application requirements.
**
**                Set memory bank area and size if external memory is used.
**
**  Target      : STMicroelectronics STM32
**
**  Distribution: The file is distributed as is, without any warranty
**                of any kind.
**
*****************************************************************************
** @attention
**
** Copyright (c) 2025 STMicroelectronics.
** All rights reserved.
**
** This software is licensed under terms that can be found in the LICENSE file
** in the root directory of this software component.
** If no LICENSE file comes with this software, it is provided AS-IS.
**
****************************************************************************
*/

/* Entry Point */
ENTRY(Reset_Handler)

/* Highest address of the user mode stack */
_estack = ORIGIN(DTCMRAM) + LENGTH(DTCMRAM);    /* end of RAM */
/* Generate a link error if heap and stack don't fit into RAM */
_Min_Heap_Size = 0x200;      /* required amount of heap  */
_Min_Stack_Size = 0x400; /* required amount of stack */

/* Specify the memory areas */
MEMORY
{
  RAM_EXEC (xrw)  : ORIGIN = 0x24000000, LENGTH = 512K
  DTCMRAM (xrw)   : ORIGIN = 0x20000000, LENGTH = 128K
  RAM_D2 (xrw)    : ORIGIN = 0x30000000, LENGTH = 288K
  RAM_D3 (xrw)    : ORIGIN = 0x38000000, LENGTH = 64K
  ITCMRAM (xrw)   : ORIGIN = 0x00000000, LENGTH = 64K
}

/* Define output sections */
SECTIONS
{
  /* The startup code goes first into RAM_EXEC */
  .isr_vector :
  {
    . = ALIGN(4);
    KEEP(*(.isr_vector)) /* Startup code */
    . = ALIGN(4);
  } >RAM_EXEC

  /* The program code and other data goes into RAM_EXEC */
  .text :
  {
    . = ALIGN(4);
    *(.text)           /* .text sections (code) */
    *(.text*)          /* .text* sections (code) */
    *(.glue_7)         /* glue arm to thumb code */
    *(.glue_7t)        /* glue thumb to arm code */
    *(.eh_frame)
    *(.RamFunc)        /* .RamFunc sections */
    *(.RamFunc*)       /* .RamFunc* sections */

    KEEP (*(.init))
    KEEP (*(.fini))

    . = ALIGN(4);
    _etext = .;        /* define a global symbols at end of code */
  } >RAM_EXEC

  /* Constant data goes into RAM_EXEC */
  .rodata :
  {
    . = ALIGN(4);
    *(.rodata)         /* .rodata sections (constants, strings, etc.) */
    *(.rodata*)        /* .rodata* sections (constants, strings, etc.) */
    . = ALIGN(4);
  } >RAM_EXEC

  .ARM.extab (READONLY) : /* The READONLY keyword is only supported in GCC11 and later, remove it if using GCC10 or earlier. */
  {
    *(.ARM.extab* .gnu.linkonce.armextab.*)
  } >RAM_EXEC
  .ARM (READONLY) : /* The READONLY keyword is only supported in GCC11 and later, remove it if using GCC10 or earlier. */
  {
    __exidx_start = .;
    *(.ARM.exidx*)
    __exidx_end = .;
  } >RAM_EXEC

  .preinit_array (READONLY) : /* The READONLY keyword is only supported in GCC11 and later, remove it if using GCC10 or earlier. */
  {
    PROVIDE_HIDDEN (__preinit_array_start = .);
    KEEP (*(.preinit_array*))
    PROVIDE_HIDDEN (__preinit_array_end = .);
  } >RAM_EXEC

  .init_array (READONLY) : /* The READONLY keyword is only supported in GCC11 and later, remove it if using GCC10 or earlier. */
  {
    PROVIDE_HIDDEN (__init_array_start = .);
    KEEP (*(SORT(.init_array.*)))
    KEEP (*(.init_array*))
    PROVIDE_HIDDEN (__init_array_end = .);
  } >RAM_EXEC

  .fini_array (READONLY) : /* The READONLY keyword is only supported in GCC11 and later, remove it if using GCC10 or earlier. */
  {
    PROVIDE_HIDDEN (__fini_array_start = .);
    KEEP (*(SORT(.fini_array.*)))
    KEEP (*(.fini_array*))
    PROVIDE_HIDDEN (__fini_array_end = .);
  } >RAM_EXEC

  /* used by the startup to initialize data */
  _sidata = LOADADDR(.data);

  /* Initialized data sections goes into RAM, load LMA copy after code */
  .data :
  {
    . = ALIGN(4);
    _sdata = .;        /* create a global symbol at data start */
    *(.data)           /* .data sections */
    *(.data*)          /* .data* sections */

    . = ALIGN(4);
    _edata = .;        /* define a global symbol at data end */
  } >DTCMRAM AT> RAM_EXEC

  /* Uninitialized data section */
  . = ALIGN(4);
  .bss :
  {
    /* This is used by the startup in order to initialize the .bss section */
    _sbss = .;         /* define a global symbol at bss start */
    __bss_start__ = _sbss;
    *(.bss)
    *(.bss*)
    *(COMMON)

    . = ALIGN(4);
    _ebss = .;         /* define a global symbol at bss end */
    __bss_end__ = _ebss;
  } >DTCMRAM

  /* User_heap_stack section, used to check that there is enough RAM left */
  ._user_heap_stack :
  {
    . = ALIGN(8);
    PROVIDE ( end = . );
    PROVIDE ( _end = . );
    . = . + _Min_Heap_Size;
    . = . + _Min_Stack_Size;
    . = ALIGN(8);
  } >DTCMRAM

  /* Remove information from the standard libraries */
  /DISCARD/ :
  {
    libc.a ( * )
    libm.a ( * )
    libgcc.a ( * )
  }

  .ARM.attributes 0 : { *(.ARM.attributes) }
}
</file>

<file path=".eide/eide.yml">
version: "4.1"
name: MyDrone
type: ARM
deviceName: null
packDir: null
srcDirs:
  - Core
  - Middlewares
  - Drivers
  - MyCore
virtualFolder:
  name: <virtual_root>
  files: []
  folders: []
dependenceList: []
outDir: build
miscInfo:
  uid: 1a04b93d1162cd5c1caf666f768dd8bf
targets:
  Debug:
    cppPreprocessAttrs:
      defineList:
        - DEBUG
        - USE_PWR_LDO_SUPPLY
        - USE_HAL_DRIVER
        - STM32H743xx
      incList:
        - Core/Inc
        - Drivers/STM32H7xx_HAL_Driver/Inc
        - Drivers/STM32H7xx_HAL_Driver/Inc/Legacy
        - Middlewares/Third_Party/FreeRTOS/Source/include
        - Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2
        - Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM4F
        - Drivers/CMSIS/Device/ST/STM32H7xx/Include
        - Drivers/CMSIS/Include
        - MyCore/Inc
      libList: []
    excludeList: []
    toolchain: GCC
    toolchainConfigMap:
      GCC:
        archExtensions: ""
        cpuType: Cortex-M7
        floatingPointHardware: single
        options:
          version: 5
          afterBuildTasks: []
          asm-compiler:
            ASM_FLAGS: -DDEBUG
          beforeBuildTasks: []
          c/cpp-compiler:
            CXX_FLAGS: ""
            C_FLAGS: ""
            language-c: c11
            language-cpp: c++11
            one-elf-section-per-data: true
            one-elf-section-per-function: true
            optimization: level-debug
            warnings: all-warnings
          global:
            $float-abi-type: hard
            misc-control: []
            not-use-syscalls: true
            output-debug-info: enable
            use-newlib-nano: true
          linker:
            $outputTaskExcludes:
              - .bin
            LD_FLAGS: ""
            LIB_FLAGS: ""
            output-format: elf
            remove-unused-input-sections: true
        scatterFilePath: STM32H743VITX_FLASH.ld
        storageLayout:
          RAM: []
          ROM: []
        useCustomScatterFile: true
    uploadConfigMap:
      JLink:
        baseAddr: ""
        bin: ""
        cpuInfo:
          cpuName: STM32H743VI
          vendor: ST
        otherCmds: ""
        proType: 1
        speed: 8000
    uploader: JLink
  Release:
    cppPreprocessAttrs:
      defineList:
        - USE_PWR_LDO_SUPPLY
        - USE_HAL_DRIVER
        - STM32H743xx
      incList:
        - Core/Inc
        - Drivers/STM32H7xx_HAL_Driver/Inc
        - Drivers/STM32H7xx_HAL_Driver/Inc/Legacy
        - Middlewares/Third_Party/FreeRTOS/Source/include
        - Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2
        - Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM4F
        - Drivers/CMSIS/Device/ST/STM32H7xx/Include
        - Drivers/CMSIS/Include
      libList: []
    excludeList: []
    toolchain: GCC
    toolchainConfigMap:
      GCC:
        archExtensions: ""
        cpuType: Cortex-M7
        floatingPointHardware: single
        options:
          version: 5
          afterBuildTasks: []
          asm-compiler:
            ASM_FLAGS: ""
          beforeBuildTasks: []
          c/cpp-compiler:
            CXX_FLAGS: ""
            C_FLAGS: ""
            language-c: c11
            language-cpp: c++11
            one-elf-section-per-data: true
            one-elf-section-per-function: true
            optimization: level-debug
            warnings: all-warnings
          global:
            $float-abi-type: hard
            misc-control: []
            not-use-syscalls: true
            output-debug-info: enable
            use-newlib-nano: true
          linker:
            $outputTaskExcludes:
              - .bin
            LD_FLAGS: ""
            LIB_FLAGS: ""
            output-format: elf
            remove-unused-input-sections: true
        scatterFilePath: STM32H743VITX_FLASH.ld
        storageLayout:
          RAM: []
          ROM: []
        useCustomScatterFile: true
    uploadConfigMap:
      JLink:
        baseAddr: ""
        bin: ""
        cpuInfo:
          cpuName: STM32H743VI
          vendor: ST
        otherCmds: ""
        proType: 1
        speed: 8000
    uploader: JLink
</file>

<file path=".mxproject">
[PreviousLibFiles]
LibFiles=Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_tim.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_tim_ex.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_cortex.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_cortex.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_rcc.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_rcc_ex.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_bus.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_rcc.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_crs.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_system.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_utils.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_flash.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_flash_ex.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_gpio.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_gpio_ex.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_gpio.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_hsem.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_hsem.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_dma.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_dma_ex.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_dma.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_dmamux.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_mdma.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_pwr.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_pwr_ex.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_pwr.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_def.h;Drivers\STM32H7xx_HAL_Driver\Inc\Legacy\stm32_hal_legacy.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_i2c.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_i2c_ex.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_exti.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_exti.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_i2c.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_spi.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_spi.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_spi_ex.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_tim.h;Middlewares\Third_Party\FreeRTOS\Source\include\croutine.h;Middlewares\Third_Party\FreeRTOS\Source\include\deprecated_definitions.h;Middlewares\Third_Party\FreeRTOS\Source\include\event_groups.h;Middlewares\Third_Party\FreeRTOS\Source\include\FreeRTOS.h;Middlewares\Third_Party\FreeRTOS\Source\include\list.h;Middlewares\Third_Party\FreeRTOS\Source\include\message_buffer.h;Middlewares\Third_Party\FreeRTOS\Source\include\mpu_prototypes.h;Middlewares\Third_Party\FreeRTOS\Source\include\mpu_wrappers.h;Middlewares\Third_Party\FreeRTOS\Source\include\portable.h;Middlewares\Third_Party\FreeRTOS\Source\include\projdefs.h;Middlewares\Third_Party\FreeRTOS\Source\include\queue.h;Middlewares\Third_Party\FreeRTOS\Source\include\semphr.h;Middlewares\Third_Party\FreeRTOS\Source\include\stack_macros.h;Middlewares\Third_Party\FreeRTOS\Source\include\StackMacros.h;Middlewares\Third_Party\FreeRTOS\Source\include\stream_buffer.h;Middlewares\Third_Party\FreeRTOS\Source\include\task.h;Middlewares\Third_Party\FreeRTOS\Source\include\timers.h;Middlewares\Third_Party\FreeRTOS\Source\include\atomic.h;Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS_V2\cmsis_os2.h;Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS_V2\cmsis_os.h;Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS_V2\freertos_mpool.h;Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS_V2\freertos_os2.h;Middlewares\Third_Party\FreeRTOS\Source\portable\GCC\ARM_CM4F\portmacro.h;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_tim.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_tim_ex.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_cortex.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_rcc.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_rcc_ex.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_flash.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_flash_ex.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_gpio.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_hsem.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_dma.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_dma_ex.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_mdma.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_pwr.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_pwr_ex.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_i2c.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_i2c_ex.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_exti.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_spi.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_spi_ex.c;Middlewares\Third_Party\FreeRTOS\Source\croutine.c;Middlewares\Third_Party\FreeRTOS\Source\event_groups.c;Middlewares\Third_Party\FreeRTOS\Source\list.c;Middlewares\Third_Party\FreeRTOS\Source\queue.c;Middlewares\Third_Party\FreeRTOS\Source\stream_buffer.c;Middlewares\Third_Party\FreeRTOS\Source\tasks.c;Middlewares\Third_Party\FreeRTOS\Source\timers.c;Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS_V2\cmsis_os2.c;Middlewares\Third_Party\FreeRTOS\Source\portable\MemMang\heap_4.c;Middlewares\Third_Party\FreeRTOS\Source\portable\GCC\ARM_CM4F\port.c;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_tim.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_tim_ex.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_cortex.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_cortex.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_rcc.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_rcc_ex.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_bus.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_rcc.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_crs.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_system.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_utils.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_flash.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_flash_ex.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_gpio.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_gpio_ex.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_gpio.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_hsem.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_hsem.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_dma.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_dma_ex.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_dma.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_dmamux.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_mdma.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_pwr.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_pwr_ex.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_pwr.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_def.h;Drivers\STM32H7xx_HAL_Driver\Inc\Legacy\stm32_hal_legacy.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_i2c.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_i2c_ex.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_exti.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_exti.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_i2c.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_spi.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_spi.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_hal_spi_ex.h;Drivers\STM32H7xx_HAL_Driver\Inc\stm32h7xx_ll_tim.h;Middlewares\Third_Party\FreeRTOS\Source\include\croutine.h;Middlewares\Third_Party\FreeRTOS\Source\include\deprecated_definitions.h;Middlewares\Third_Party\FreeRTOS\Source\include\event_groups.h;Middlewares\Third_Party\FreeRTOS\Source\include\FreeRTOS.h;Middlewares\Third_Party\FreeRTOS\Source\include\list.h;Middlewares\Third_Party\FreeRTOS\Source\include\message_buffer.h;Middlewares\Third_Party\FreeRTOS\Source\include\mpu_prototypes.h;Middlewares\Third_Party\FreeRTOS\Source\include\mpu_wrappers.h;Middlewares\Third_Party\FreeRTOS\Source\include\portable.h;Middlewares\Third_Party\FreeRTOS\Source\include\projdefs.h;Middlewares\Third_Party\FreeRTOS\Source\include\queue.h;Middlewares\Third_Party\FreeRTOS\Source\include\semphr.h;Middlewares\Third_Party\FreeRTOS\Source\include\stack_macros.h;Middlewares\Third_Party\FreeRTOS\Source\include\StackMacros.h;Middlewares\Third_Party\FreeRTOS\Source\include\stream_buffer.h;Middlewares\Third_Party\FreeRTOS\Source\include\task.h;Middlewares\Third_Party\FreeRTOS\Source\include\timers.h;Middlewares\Third_Party\FreeRTOS\Source\include\atomic.h;Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS_V2\cmsis_os2.h;Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS_V2\cmsis_os.h;Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS_V2\freertos_mpool.h;Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS_V2\freertos_os2.h;Middlewares\Third_Party\FreeRTOS\Source\portable\GCC\ARM_CM4F\portmacro.h;Drivers\CMSIS\Device\ST\STM32H7xx\Include\stm32h743xx.h;Drivers\CMSIS\Device\ST\STM32H7xx\Include\stm32h7xx.h;Drivers\CMSIS\Device\ST\STM32H7xx\Include\system_stm32h7xx.h;Drivers\CMSIS\Device\ST\STM32H7xx\Include\system_stm32h7xx.h;Drivers\CMSIS\Device\ST\STM32H7xx\Source\Templates\system_stm32h7xx.c;Drivers\CMSIS\Include\cmsis_armcc.h;Drivers\CMSIS\Include\cmsis_armclang.h;Drivers\CMSIS\Include\cmsis_armclang_ltm.h;Drivers\CMSIS\Include\cmsis_compiler.h;Drivers\CMSIS\Include\cmsis_gcc.h;Drivers\CMSIS\Include\cmsis_iccarm.h;Drivers\CMSIS\Include\cmsis_version.h;Drivers\CMSIS\Include\core_armv81mml.h;Drivers\CMSIS\Include\core_armv8mbl.h;Drivers\CMSIS\Include\core_armv8mml.h;Drivers\CMSIS\Include\core_cm0.h;Drivers\CMSIS\Include\core_cm0plus.h;Drivers\CMSIS\Include\core_cm1.h;Drivers\CMSIS\Include\core_cm23.h;Drivers\CMSIS\Include\core_cm3.h;Drivers\CMSIS\Include\core_cm33.h;Drivers\CMSIS\Include\core_cm35p.h;Drivers\CMSIS\Include\core_cm4.h;Drivers\CMSIS\Include\core_cm7.h;Drivers\CMSIS\Include\core_sc000.h;Drivers\CMSIS\Include\core_sc300.h;Drivers\CMSIS\Include\mpu_armv7.h;Drivers\CMSIS\Include\mpu_armv8.h;Drivers\CMSIS\Include\tz_context.h;

[PreviousUsedCubeIDEFiles]
SourceFiles=Core\Src\main.c;Core\Src\gpio.c;Core\Src\freertos.c;Core\Src\dma.c;Core\Src\i2c.c;Core\Src\spi.c;Core\Src\tim.c;Core\Src\stm32h7xx_it.c;Core\Src\stm32h7xx_hal_msp.c;Core\Src\stm32h7xx_hal_timebase_tim.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_tim.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_tim_ex.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_cortex.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_rcc.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_rcc_ex.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_flash.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_flash_ex.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_gpio.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_hsem.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_dma.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_dma_ex.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_mdma.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_pwr.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_pwr_ex.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_i2c.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_i2c_ex.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_exti.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_spi.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_spi_ex.c;Middlewares\Third_Party\FreeRTOS\Source\croutine.c;Middlewares\Third_Party\FreeRTOS\Source\event_groups.c;Middlewares\Third_Party\FreeRTOS\Source\list.c;Middlewares\Third_Party\FreeRTOS\Source\queue.c;Middlewares\Third_Party\FreeRTOS\Source\stream_buffer.c;Middlewares\Third_Party\FreeRTOS\Source\tasks.c;Middlewares\Third_Party\FreeRTOS\Source\timers.c;Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS_V2\cmsis_os2.c;Middlewares\Third_Party\FreeRTOS\Source\portable\MemMang\heap_4.c;Middlewares\Third_Party\FreeRTOS\Source\portable\GCC\ARM_CM4F\port.c;Drivers\CMSIS\Device\ST\STM32H7xx\Source\Templates\system_stm32h7xx.c;Core\Src\system_stm32h7xx.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_tim.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_tim_ex.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_cortex.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_rcc.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_rcc_ex.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_flash.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_flash_ex.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_gpio.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_hsem.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_dma.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_dma_ex.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_mdma.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_pwr.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_pwr_ex.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_i2c.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_i2c_ex.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_exti.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_spi.c;Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_spi_ex.c;Middlewares\Third_Party\FreeRTOS\Source\croutine.c;Middlewares\Third_Party\FreeRTOS\Source\event_groups.c;Middlewares\Third_Party\FreeRTOS\Source\list.c;Middlewares\Third_Party\FreeRTOS\Source\queue.c;Middlewares\Third_Party\FreeRTOS\Source\stream_buffer.c;Middlewares\Third_Party\FreeRTOS\Source\tasks.c;Middlewares\Third_Party\FreeRTOS\Source\timers.c;Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS_V2\cmsis_os2.c;Middlewares\Third_Party\FreeRTOS\Source\portable\MemMang\heap_4.c;Middlewares\Third_Party\FreeRTOS\Source\portable\GCC\ARM_CM4F\port.c;Drivers\CMSIS\Device\ST\STM32H7xx\Source\Templates\system_stm32h7xx.c;Core\Src\system_stm32h7xx.c;;;Middlewares\Third_Party\FreeRTOS\Source\croutine.c;Middlewares\Third_Party\FreeRTOS\Source\event_groups.c;Middlewares\Third_Party\FreeRTOS\Source\list.c;Middlewares\Third_Party\FreeRTOS\Source\queue.c;Middlewares\Third_Party\FreeRTOS\Source\stream_buffer.c;Middlewares\Third_Party\FreeRTOS\Source\tasks.c;Middlewares\Third_Party\FreeRTOS\Source\timers.c;Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS_V2\cmsis_os2.c;Middlewares\Third_Party\FreeRTOS\Source\portable\MemMang\heap_4.c;Middlewares\Third_Party\FreeRTOS\Source\portable\GCC\ARM_CM4F\port.c;
HeaderPath=Drivers\STM32H7xx_HAL_Driver\Inc;Drivers\STM32H7xx_HAL_Driver\Inc\Legacy;Middlewares\Third_Party\FreeRTOS\Source\include;Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS_V2;Middlewares\Third_Party\FreeRTOS\Source\portable\GCC\ARM_CM4F;Drivers\CMSIS\Device\ST\STM32H7xx\Include;Drivers\CMSIS\Include;Core\Inc;
CDefines=USE_PWR_LDO_SUPPLY;USE_PWR_LDO_SUPPLY;USE_HAL_DRIVER;STM32H743xx;USE_HAL_DRIVER;USE_HAL_DRIVER;

[PreviousGenFiles]
AdvancedFolderStructure=true
HeaderFileListSize=9
HeaderFiles#0=..\Core\Inc\gpio.h
HeaderFiles#1=..\Core\Inc\FreeRTOSConfig.h
HeaderFiles#2=..\Core\Inc\dma.h
HeaderFiles#3=..\Core\Inc\i2c.h
HeaderFiles#4=..\Core\Inc\spi.h
HeaderFiles#5=..\Core\Inc\tim.h
HeaderFiles#6=..\Core\Inc\stm32h7xx_it.h
HeaderFiles#7=..\Core\Inc\stm32h7xx_hal_conf.h
HeaderFiles#8=..\Core\Inc\main.h
HeaderFolderListSize=1
HeaderPath#0=..\Core\Inc
HeaderFiles=;
SourceFileListSize=10
SourceFiles#0=..\Core\Src\gpio.c
SourceFiles#1=..\Core\Src\freertos.c
SourceFiles#2=..\Core\Src\dma.c
SourceFiles#3=..\Core\Src\i2c.c
SourceFiles#4=..\Core\Src\spi.c
SourceFiles#5=..\Core\Src\tim.c
SourceFiles#6=..\Core\Src\stm32h7xx_it.c
SourceFiles#7=..\Core\Src\stm32h7xx_hal_msp.c
SourceFiles#8=..\Core\Src\stm32h7xx_hal_timebase_tim.c
SourceFiles#9=..\Core\Src\main.c
SourceFolderListSize=1
SourcePath#0=..\Core\Src
SourceFiles=;
</file>

<file path="Core/Inc/stm32h7xx_it.h">
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    stm32h7xx_it.h
  * @brief   This file contains the headers of the interrupt handlers.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2026 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32H7xx_IT_H
#define __STM32H7xx_IT_H

#ifdef __cplusplus
extern "C" {
#endif

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Exported types ------------------------------------------------------------*/
/* USER CODE BEGIN ET */

/* USER CODE END ET */

/* Exported constants --------------------------------------------------------*/
/* USER CODE BEGIN EC */

/* USER CODE END EC */

/* Exported macro ------------------------------------------------------------*/
/* USER CODE BEGIN EM */

/* USER CODE END EM */

/* Exported functions prototypes ---------------------------------------------*/
void NMI_Handler(void);
void HardFault_Handler(void);
void MemManage_Handler(void);
void BusFault_Handler(void);
void UsageFault_Handler(void);
void DebugMon_Handler(void);
void DMA1_Stream0_IRQHandler(void);
void DMA1_Stream1_IRQHandler(void);
void DMA1_Stream2_IRQHandler(void);
void DMA1_Stream3_IRQHandler(void);
void DMA1_Stream4_IRQHandler(void);
void DMA1_Stream5_IRQHandler(void);
void DMA1_Stream6_IRQHandler(void);
void EXTI9_5_IRQHandler(void);
void I2C1_EV_IRQHandler(void);
void I2C1_ER_IRQHandler(void);
void SPI1_IRQHandler(void);
void SPI2_IRQHandler(void);
void DMA1_Stream7_IRQHandler(void);
void SPI3_IRQHandler(void);
void TIM7_IRQHandler(void);
void DMA2_Stream0_IRQHandler(void);
void DMA2_Stream1_IRQHandler(void);
void SPI4_IRQHandler(void);
/* USER CODE BEGIN EFP */

/* USER CODE END EFP */

#ifdef __cplusplus
}
#endif

#endif /* __STM32H7xx_IT_H */
</file>

<file path="Core/Src/stm32h7xx_it.c">
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    stm32h7xx_it.c
  * @brief   Interrupt Service Routines.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2026 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "stm32h7xx_it.h"
/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN TD */

/* USER CODE END TD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/* External variables --------------------------------------------------------*/
extern DMA_HandleTypeDef hdma_i2c1_rx;
extern DMA_HandleTypeDef hdma_i2c1_tx;
extern I2C_HandleTypeDef hi2c1;
extern DMA_HandleTypeDef hdma_spi1_rx;
extern DMA_HandleTypeDef hdma_spi1_tx;
extern DMA_HandleTypeDef hdma_spi2_rx;
extern DMA_HandleTypeDef hdma_spi2_tx;
extern DMA_HandleTypeDef hdma_spi3_rx;
extern DMA_HandleTypeDef hdma_spi3_tx;
extern DMA_HandleTypeDef hdma_spi4_rx;
extern DMA_HandleTypeDef hdma_spi4_tx;
extern SPI_HandleTypeDef hspi1;
extern SPI_HandleTypeDef hspi2;
extern SPI_HandleTypeDef hspi3;
extern SPI_HandleTypeDef hspi4;
extern TIM_HandleTypeDef htim7;

/* USER CODE BEGIN EV */

/* USER CODE END EV */

/******************************************************************************/
/*           Cortex Processor Interruption and Exception Handlers          */
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
  {
  }
  /* USER CODE END NonMaskableInt_IRQn 1 */
}

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
  {
    /* USER CODE BEGIN W1_HardFault_IRQn 0 */
    /* USER CODE END W1_HardFault_IRQn 0 */
  }
}

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
  {
    /* USER CODE BEGIN W1_MemoryManagement_IRQn 0 */
    /* USER CODE END W1_MemoryManagement_IRQn 0 */
  }
}

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
  {
    /* USER CODE BEGIN W1_BusFault_IRQn 0 */
    /* USER CODE END W1_BusFault_IRQn 0 */
  }
}

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
  {
    /* USER CODE BEGIN W1_UsageFault_IRQn 0 */
    /* USER CODE END W1_UsageFault_IRQn 0 */
  }
}

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
  /* USER CODE BEGIN DebugMonitor_IRQn 0 */

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}

/******************************************************************************/
/* STM32H7xx Peripheral Interrupt Handlers                                    */
/* Add here the Interrupt Handlers for the used peripherals.                  */
/* For the available peripheral interrupt handler names,                      */
/* please refer to the startup file (startup_stm32h7xx.s).                    */
/******************************************************************************/

/**
  * @brief This function handles DMA1 stream0 global interrupt.
  */
void DMA1_Stream0_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Stream0_IRQn 0 */

  /* USER CODE END DMA1_Stream0_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_i2c1_rx);
  /* USER CODE BEGIN DMA1_Stream0_IRQn 1 */

  /* USER CODE END DMA1_Stream0_IRQn 1 */
}

/**
  * @brief This function handles DMA1 stream1 global interrupt.
  */
void DMA1_Stream1_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Stream1_IRQn 0 */

  /* USER CODE END DMA1_Stream1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi1_rx);
  /* USER CODE BEGIN DMA1_Stream1_IRQn 1 */

  /* USER CODE END DMA1_Stream1_IRQn 1 */
}

/**
  * @brief This function handles DMA1 stream2 global interrupt.
  */
void DMA1_Stream2_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Stream2_IRQn 0 */

  /* USER CODE END DMA1_Stream2_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi1_tx);
  /* USER CODE BEGIN DMA1_Stream2_IRQn 1 */

  /* USER CODE END DMA1_Stream2_IRQn 1 */
}

/**
  * @brief This function handles DMA1 stream3 global interrupt.
  */
void DMA1_Stream3_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Stream3_IRQn 0 */

  /* USER CODE END DMA1_Stream3_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi2_rx);
  /* USER CODE BEGIN DMA1_Stream3_IRQn 1 */

  /* USER CODE END DMA1_Stream3_IRQn 1 */
}

/**
  * @brief This function handles DMA1 stream4 global interrupt.
  */
void DMA1_Stream4_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Stream4_IRQn 0 */

  /* USER CODE END DMA1_Stream4_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi2_tx);
  /* USER CODE BEGIN DMA1_Stream4_IRQn 1 */

  /* USER CODE END DMA1_Stream4_IRQn 1 */
}

/**
  * @brief This function handles DMA1 stream5 global interrupt.
  */
void DMA1_Stream5_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Stream5_IRQn 0 */

  /* USER CODE END DMA1_Stream5_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi3_rx);
  /* USER CODE BEGIN DMA1_Stream5_IRQn 1 */

  /* USER CODE END DMA1_Stream5_IRQn 1 */
}

/**
  * @brief This function handles DMA1 stream6 global interrupt.
  */
void DMA1_Stream6_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Stream6_IRQn 0 */

  /* USER CODE END DMA1_Stream6_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi3_tx);
  /* USER CODE BEGIN DMA1_Stream6_IRQn 1 */

  /* USER CODE END DMA1_Stream6_IRQn 1 */
}

/**
  * @brief This function handles EXTI line[9:5] interrupts.
  */
void EXTI9_5_IRQHandler(void)
{
  /* USER CODE BEGIN EXTI9_5_IRQn 0 */

  /* USER CODE END EXTI9_5_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(ICM42688INT_Pin);
  /* USER CODE BEGIN EXTI9_5_IRQn 1 */

  /* USER CODE END EXTI9_5_IRQn 1 */
}

/**
  * @brief This function handles I2C1 event interrupt.
  */
void I2C1_EV_IRQHandler(void)
{
  /* USER CODE BEGIN I2C1_EV_IRQn 0 */

  /* USER CODE END I2C1_EV_IRQn 0 */
  HAL_I2C_EV_IRQHandler(&hi2c1);
  /* USER CODE BEGIN I2C1_EV_IRQn 1 */

  /* USER CODE END I2C1_EV_IRQn 1 */
}

/**
  * @brief This function handles I2C1 error interrupt.
  */
void I2C1_ER_IRQHandler(void)
{
  /* USER CODE BEGIN I2C1_ER_IRQn 0 */

  /* USER CODE END I2C1_ER_IRQn 0 */
  HAL_I2C_ER_IRQHandler(&hi2c1);
  /* USER CODE BEGIN I2C1_ER_IRQn 1 */

  /* USER CODE END I2C1_ER_IRQn 1 */
}

/**
  * @brief This function handles SPI1 global interrupt.
  */
void SPI1_IRQHandler(void)
{
  /* USER CODE BEGIN SPI1_IRQn 0 */

  /* USER CODE END SPI1_IRQn 0 */
  HAL_SPI_IRQHandler(&hspi1);
  /* USER CODE BEGIN SPI1_IRQn 1 */

  /* USER CODE END SPI1_IRQn 1 */
}

/**
  * @brief This function handles SPI2 global interrupt.
  */
void SPI2_IRQHandler(void)
{
  /* USER CODE BEGIN SPI2_IRQn 0 */

  /* USER CODE END SPI2_IRQn 0 */
  HAL_SPI_IRQHandler(&hspi2);
  /* USER CODE BEGIN SPI2_IRQn 1 */

  /* USER CODE END SPI2_IRQn 1 */
}

/**
  * @brief This function handles DMA1 stream7 global interrupt.
  */
void DMA1_Stream7_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Stream7_IRQn 0 */

  /* USER CODE END DMA1_Stream7_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_i2c1_tx);
  /* USER CODE BEGIN DMA1_Stream7_IRQn 1 */

  /* USER CODE END DMA1_Stream7_IRQn 1 */
}

/**
  * @brief This function handles SPI3 global interrupt.
  */
void SPI3_IRQHandler(void)
{
  /* USER CODE BEGIN SPI3_IRQn 0 */

  /* USER CODE END SPI3_IRQn 0 */
  HAL_SPI_IRQHandler(&hspi3);
  /* USER CODE BEGIN SPI3_IRQn 1 */

  /* USER CODE END SPI3_IRQn 1 */
}

/**
  * @brief This function handles TIM7 global interrupt.
  */
void TIM7_IRQHandler(void)
{
  /* USER CODE BEGIN TIM7_IRQn 0 */

  /* USER CODE END TIM7_IRQn 0 */
  HAL_TIM_IRQHandler(&htim7);
  /* USER CODE BEGIN TIM7_IRQn 1 */

  /* USER CODE END TIM7_IRQn 1 */
}

/**
  * @brief This function handles DMA2 stream0 global interrupt.
  */
void DMA2_Stream0_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Stream0_IRQn 0 */

  /* USER CODE END DMA2_Stream0_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi4_rx);
  /* USER CODE BEGIN DMA2_Stream0_IRQn 1 */

  /* USER CODE END DMA2_Stream0_IRQn 1 */
}

/**
  * @brief This function handles DMA2 stream1 global interrupt.
  */
void DMA2_Stream1_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Stream1_IRQn 0 */

  /* USER CODE END DMA2_Stream1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi4_tx);
  /* USER CODE BEGIN DMA2_Stream1_IRQn 1 */

  /* USER CODE END DMA2_Stream1_IRQn 1 */
}

/**
  * @brief This function handles SPI4 global interrupt.
  */
void SPI4_IRQHandler(void)
{
  /* USER CODE BEGIN SPI4_IRQn 0 */

  /* USER CODE END SPI4_IRQn 0 */
  HAL_SPI_IRQHandler(&hspi4);
  /* USER CODE BEGIN SPI4_IRQn 1 */

  /* USER CODE END SPI4_IRQn 1 */
}

/* USER CODE BEGIN 1 */

/* USER CODE END 1 */
</file>

<file path="MyCore/Inc/Mydelay.hpp">
#pragma once 
#include "main.h"

#ifdef __cplusplus
extern "C" {
#endif

// 初始化 DWT 计数器和保活机制
void DWT_Time_Init(void);

// 传统的微秒延时 (阻塞式)
void delay_us(uint32_t us);

// 🛑 【核心】获取 64位 纳秒级系统时间戳
// 特性：线程安全、中断安全、584年不溢出
uint64_t Get_System_Time_ns(void);

#ifdef __cplusplus
}
#endif
</file>

<file path="MyCore/Src/Mydelay.cpp">
#include "Mydelay.hpp"
#include "FreeRTOS.h"
#include "task.h"
#include "timers.h" // 引入软件定时器


static volatile uint32_t s_last_cyccnt = 0;
static volatile uint64_t s_total_cycles = 0;

static void TimeBase_KeepAlive_Callback(TimerHandle_t xTimer) {
    (void)xTimer;
    Get_System_Time_ns(); // 仅仅调用一次，利用其内部机制更新 s_total_cycles
}


void DWT_Time_Init(void) {
    // 1. 启用 DWT 硬件
    CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
    DWT->CYCCNT = 0;
    DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
    
    // 初始化静态变量
    s_last_cyccnt = DWT->CYCCNT;
    s_total_cycles = 0;

    TimerHandle_t hTimer = xTimerCreate(
        "TimeGuard",             // 名字
        pdMS_TO_TICKS(4000),     // 周期 4秒 (远小于 8.9秒溢出时间)
        pdTRUE,                  // 自动重载
        (void*)0,                // ID
        TimeBase_KeepAlive_Callback // 回调函数
    );

    if (hTimer != NULL) {
        xTimerStart(hTimer, 0); // 启动定时器
    }
}

void delay_us(uint32_t us) {
    uint32_t start = DWT->CYCCNT;
    uint32_t ticks = us * (SystemCoreClock / 1000000);
    while ((DWT->CYCCNT - start) < ticks);
}

uint64_t Get_System_Time_ns(void) {

    uint32_t isr_mask = portSET_INTERRUPT_MASK_FROM_ISR();

    uint32_t current_cyccnt = DWT->CYCCNT;

    uint32_t delta = current_cyccnt - s_last_cyccnt;
    
    s_total_cycles += delta;
    s_last_cyccnt = current_cyccnt;

    uint64_t cycles_copy = s_total_cycles;

    portCLEAR_INTERRUPT_MASK_FROM_ISR(isr_mask);
    
    uint64_t seconds = cycles_copy / SystemCoreClock;         // 整数秒
    uint64_t fraction = cycles_copy % SystemCoreClock;        // 不足一秒的周期数

    uint64_t time_ns = (seconds * 1000000000ULL) + 
                       ((fraction * 1000000000ULL) / SystemCoreClock);

    return time_ns;
}
</file>

<file path="MyDrone.code-workspace">
{
    "folders": [
        {
            "path": "."
        }
    ],
    "settings": {},
    "extensions": {}
}
</file>

<file path="Core/Src/gpio.c">
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    gpio.c
  * @brief   This file provides code for the configuration
  *          of all used GPIO pins.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2026 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "gpio.h"

/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/*----------------------------------------------------------------------------*/
/* Configure GPIO                                                             */
/*----------------------------------------------------------------------------*/
/* USER CODE BEGIN 1 */

/* USER CODE END 1 */

/** Configure pins
     PH0-OSC_IN (PH0)   ------> RCC_OSC_IN
     PH1-OSC_OUT (PH1)   ------> RCC_OSC_OUT
     PA13 (JTMS/SWDIO)   ------> DEBUG_JTMS-SWDIO
     PA14 (JTCK/SWCLK)   ------> DEBUG_JTCK-SWCLK
*/
void MX_GPIO_Init(void)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(ICM42688GND_GPIO_Port, ICM42688GND_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(ICM42688VCC_GPIO_Port, ICM42688VCC_Pin, GPIO_PIN_SET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, DPS310VCC_Pin|DPS310_NCS_Pin, GPIO_PIN_SET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, DPS310GND_Pin|PMW3901GND_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, PMW3901_NCS_Pin|MMC5983VCC_Pin, GPIO_PIN_SET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, PMW3901VCC_Pin|ICM42688_NCS_Pin, GPIO_PIN_SET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(MMC5983GND_GPIO_Port, MMC5983GND_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pins : ICM42688GND_Pin ICM42688VCC_Pin */
  GPIO_InitStruct.Pin = ICM42688GND_Pin|ICM42688VCC_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);

  /*Configure GPIO pins : DPS310VCC_Pin DPS310GND_Pin PMW3901GND_Pin */
  GPIO_InitStruct.Pin = DPS310VCC_Pin|DPS310GND_Pin|PMW3901GND_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /*Configure GPIO pin : DPS310_NCS_Pin */
  GPIO_InitStruct.Pin = DPS310_NCS_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(DPS310_NCS_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : PMW3901_NCS_Pin */
  GPIO_InitStruct.Pin = PMW3901_NCS_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(PMW3901_NCS_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : PMW3901VCC_Pin */
  GPIO_InitStruct.Pin = PMW3901VCC_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(PMW3901VCC_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : ICM42688INT_Pin */
  GPIO_InitStruct.Pin = ICM42688INT_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(ICM42688INT_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : ICM42688_NCS_Pin */
  GPIO_InitStruct.Pin = ICM42688_NCS_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(ICM42688_NCS_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : MMC5983VCC_Pin MMC5983GND_Pin */
  GPIO_InitStruct.Pin = MMC5983VCC_Pin|MMC5983GND_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI9_5_IRQn, 5, 0);
  HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);

}

/* USER CODE BEGIN 2 */

/* USER CODE END 2 */
</file>

<file path="Core/Src/i2c.c">
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    i2c.c
  * @brief   This file provides code for the configuration
  *          of the I2C instances.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2026 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "i2c.h"

/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

I2C_HandleTypeDef hi2c1;
DMA_HandleTypeDef hdma_i2c1_rx;
DMA_HandleTypeDef hdma_i2c1_tx;

/* I2C1 init function */
void MX_I2C1_Init(void)
{

  /* USER CODE BEGIN I2C1_Init 0 */

  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
  hi2c1.Init.Timing = 0x307075B1;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
  if(i2cHandle->Instance==I2C1)
  {
  /* USER CODE BEGIN I2C1_MspInit 0 */

  /* USER CODE END I2C1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2C1;
    PeriphClkInitStruct.I2c123ClockSelection = RCC_I2C123CLKSOURCE_D2PCLK1;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_RCC_GPIOB_CLK_ENABLE();
    /**I2C1 GPIO Configuration
    PB7     ------> I2C1_SDA
    PB8     ------> I2C1_SCL
    */
    GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    /* I2C1 clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();

    /* I2C1 DMA Init */
    /* I2C1_RX Init */
    hdma_i2c1_rx.Instance = DMA1_Stream0;
    hdma_i2c1_rx.Init.Request = DMA_REQUEST_I2C1_RX;
    hdma_i2c1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_i2c1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_i2c1_rx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_i2c1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_i2c1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_i2c1_rx.Init.Mode = DMA_NORMAL;
    hdma_i2c1_rx.Init.Priority = DMA_PRIORITY_LOW;
    hdma_i2c1_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    if (HAL_DMA_Init(&hdma_i2c1_rx) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_LINKDMA(i2cHandle,hdmarx,hdma_i2c1_rx);

    /* I2C1_TX Init */
    hdma_i2c1_tx.Instance = DMA1_Stream7;
    hdma_i2c1_tx.Init.Request = DMA_REQUEST_I2C1_TX;
    hdma_i2c1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
    hdma_i2c1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_i2c1_tx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_i2c1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_i2c1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_i2c1_tx.Init.Mode = DMA_NORMAL;
    hdma_i2c1_tx.Init.Priority = DMA_PRIORITY_LOW;
    hdma_i2c1_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    if (HAL_DMA_Init(&hdma_i2c1_tx) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_LINKDMA(i2cHandle,hdmatx,hdma_i2c1_tx);

    /* I2C1 interrupt Init */
    HAL_NVIC_SetPriority(I2C1_EV_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(I2C1_EV_IRQn);
    HAL_NVIC_SetPriority(I2C1_ER_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(I2C1_ER_IRQn);
  /* USER CODE BEGIN I2C1_MspInit 1 */

  /* USER CODE END I2C1_MspInit 1 */
  }
}

void HAL_I2C_MspDeInit(I2C_HandleTypeDef* i2cHandle)
{

  if(i2cHandle->Instance==I2C1)
  {
  /* USER CODE BEGIN I2C1_MspDeInit 0 */

  /* USER CODE END I2C1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_I2C1_CLK_DISABLE();

    /**I2C1 GPIO Configuration
    PB7     ------> I2C1_SDA
    PB8     ------> I2C1_SCL
    */
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_7);

    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_8);

    /* I2C1 DMA DeInit */
    HAL_DMA_DeInit(i2cHandle->hdmarx);
    HAL_DMA_DeInit(i2cHandle->hdmatx);

    /* I2C1 interrupt Deinit */
    HAL_NVIC_DisableIRQ(I2C1_EV_IRQn);
    HAL_NVIC_DisableIRQ(I2C1_ER_IRQn);
  /* USER CODE BEGIN I2C1_MspDeInit 1 */

  /* USER CODE END I2C1_MspDeInit 1 */
  }
}

/* USER CODE BEGIN 1 */

/* USER CODE END 1 */
</file>

<file path="Core/Src/spi.c">
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    spi.c
  * @brief   This file provides code for the configuration
  *          of the SPI instances.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2026 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "spi.h"

/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

SPI_HandleTypeDef hspi1;
SPI_HandleTypeDef hspi2;
SPI_HandleTypeDef hspi3;
SPI_HandleTypeDef hspi4;
DMA_HandleTypeDef hdma_spi1_rx;
DMA_HandleTypeDef hdma_spi1_tx;
DMA_HandleTypeDef hdma_spi2_rx;
DMA_HandleTypeDef hdma_spi2_tx;
DMA_HandleTypeDef hdma_spi3_rx;
DMA_HandleTypeDef hdma_spi3_tx;
DMA_HandleTypeDef hdma_spi4_rx;
DMA_HandleTypeDef hdma_spi4_tx;

/* SPI1 init function */
void MX_SPI1_Init(void)
{

  /* USER CODE BEGIN SPI1_Init 0 */

  /* USER CODE END SPI1_Init 0 */

  /* USER CODE BEGIN SPI1_Init 1 */

  /* USER CODE END SPI1_Init 1 */
  hspi1.Instance = SPI1;
  hspi1.Init.Mode = SPI_MODE_MASTER;
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi1.Init.CLKPolarity = SPI_POLARITY_HIGH;
  hspi1.Init.CLKPhase = SPI_PHASE_2EDGE;
  hspi1.Init.NSS = SPI_NSS_SOFT;
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_32;
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi1.Init.CRCPolynomial = 0x0;
  hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
  hspi1.Init.NSSPolarity = SPI_NSS_POLARITY_LOW;
  hspi1.Init.FifoThreshold = SPI_FIFO_THRESHOLD_01DATA;
  hspi1.Init.TxCRCInitializationPattern = SPI_CRC_INITIALIZATION_ALL_ZERO_PATTERN;
  hspi1.Init.RxCRCInitializationPattern = SPI_CRC_INITIALIZATION_ALL_ZERO_PATTERN;
  hspi1.Init.MasterSSIdleness = SPI_MASTER_SS_IDLENESS_00CYCLE;
  hspi1.Init.MasterInterDataIdleness = SPI_MASTER_INTERDATA_IDLENESS_00CYCLE;
  hspi1.Init.MasterReceiverAutoSusp = SPI_MASTER_RX_AUTOSUSP_DISABLE;
  hspi1.Init.MasterKeepIOState = SPI_MASTER_KEEP_IO_STATE_DISABLE;
  hspi1.Init.IOSwap = SPI_IO_SWAP_DISABLE;
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN SPI1_Init 2 */

  /* USER CODE END SPI1_Init 2 */

}
/* SPI2 init function */
void MX_SPI2_Init(void)
{

  /* USER CODE BEGIN SPI2_Init 0 */

  /* USER CODE END SPI2_Init 0 */

  /* USER CODE BEGIN SPI2_Init 1 */

  /* USER CODE END SPI2_Init 1 */
  hspi2.Instance = SPI2;
  hspi2.Init.Mode = SPI_MODE_MASTER;
  hspi2.Init.Direction = SPI_DIRECTION_2LINES;
  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi2.Init.CLKPolarity = SPI_POLARITY_HIGH;
  hspi2.Init.CLKPhase = SPI_PHASE_2EDGE;
  hspi2.Init.NSS = SPI_NSS_SOFT;
  hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_128;
  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi2.Init.CRCPolynomial = 0x0;
  hspi2.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
  hspi2.Init.NSSPolarity = SPI_NSS_POLARITY_LOW;
  hspi2.Init.FifoThreshold = SPI_FIFO_THRESHOLD_01DATA;
  hspi2.Init.TxCRCInitializationPattern = SPI_CRC_INITIALIZATION_ALL_ZERO_PATTERN;
  hspi2.Init.RxCRCInitializationPattern = SPI_CRC_INITIALIZATION_ALL_ZERO_PATTERN;
  hspi2.Init.MasterSSIdleness = SPI_MASTER_SS_IDLENESS_00CYCLE;
  hspi2.Init.MasterInterDataIdleness = SPI_MASTER_INTERDATA_IDLENESS_00CYCLE;
  hspi2.Init.MasterReceiverAutoSusp = SPI_MASTER_RX_AUTOSUSP_DISABLE;
  hspi2.Init.MasterKeepIOState = SPI_MASTER_KEEP_IO_STATE_DISABLE;
  hspi2.Init.IOSwap = SPI_IO_SWAP_DISABLE;
  if (HAL_SPI_Init(&hspi2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN SPI2_Init 2 */

  /* USER CODE END SPI2_Init 2 */

}
/* SPI3 init function */
void MX_SPI3_Init(void)
{

  /* USER CODE BEGIN SPI3_Init 0 */

  /* USER CODE END SPI3_Init 0 */

  /* USER CODE BEGIN SPI3_Init 1 */

  /* USER CODE END SPI3_Init 1 */
  hspi3.Instance = SPI3;
  hspi3.Init.Mode = SPI_MODE_MASTER;
  hspi3.Init.Direction = SPI_DIRECTION_2LINES;
  hspi3.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi3.Init.CLKPolarity = SPI_POLARITY_HIGH;
  hspi3.Init.CLKPhase = SPI_PHASE_2EDGE;
  hspi3.Init.NSS = SPI_NSS_SOFT;
  hspi3.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
  hspi3.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi3.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi3.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi3.Init.CRCPolynomial = 0x0;
  hspi3.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
  hspi3.Init.NSSPolarity = SPI_NSS_POLARITY_LOW;
  hspi3.Init.FifoThreshold = SPI_FIFO_THRESHOLD_01DATA;
  hspi3.Init.TxCRCInitializationPattern = SPI_CRC_INITIALIZATION_ALL_ZERO_PATTERN;
  hspi3.Init.RxCRCInitializationPattern = SPI_CRC_INITIALIZATION_ALL_ZERO_PATTERN;
  hspi3.Init.MasterSSIdleness = SPI_MASTER_SS_IDLENESS_00CYCLE;
  hspi3.Init.MasterInterDataIdleness = SPI_MASTER_INTERDATA_IDLENESS_00CYCLE;
  hspi3.Init.MasterReceiverAutoSusp = SPI_MASTER_RX_AUTOSUSP_DISABLE;
  hspi3.Init.MasterKeepIOState = SPI_MASTER_KEEP_IO_STATE_DISABLE;
  hspi3.Init.IOSwap = SPI_IO_SWAP_DISABLE;
  if (HAL_SPI_Init(&hspi3) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN SPI3_Init 2 */

  /* USER CODE END SPI3_Init 2 */

}
/* SPI4 init function */
void MX_SPI4_Init(void)
{

  /* USER CODE BEGIN SPI4_Init 0 */

  /* USER CODE END SPI4_Init 0 */

  /* USER CODE BEGIN SPI4_Init 1 */

  /* USER CODE END SPI4_Init 1 */
  hspi4.Instance = SPI4;
  hspi4.Init.Mode = SPI_MODE_SLAVE;
  hspi4.Init.Direction = SPI_DIRECTION_2LINES;
  hspi4.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi4.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi4.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi4.Init.NSS = SPI_NSS_HARD_INPUT;
  hspi4.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi4.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi4.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi4.Init.CRCPolynomial = 0x0;
  hspi4.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
  hspi4.Init.NSSPolarity = SPI_NSS_POLARITY_LOW;
  hspi4.Init.FifoThreshold = SPI_FIFO_THRESHOLD_01DATA;
  hspi4.Init.TxCRCInitializationPattern = SPI_CRC_INITIALIZATION_ALL_ZERO_PATTERN;
  hspi4.Init.RxCRCInitializationPattern = SPI_CRC_INITIALIZATION_ALL_ZERO_PATTERN;
  hspi4.Init.MasterSSIdleness = SPI_MASTER_SS_IDLENESS_00CYCLE;
  hspi4.Init.MasterInterDataIdleness = SPI_MASTER_INTERDATA_IDLENESS_00CYCLE;
  hspi4.Init.MasterReceiverAutoSusp = SPI_MASTER_RX_AUTOSUSP_DISABLE;
  hspi4.Init.MasterKeepIOState = SPI_MASTER_KEEP_IO_STATE_DISABLE;
  hspi4.Init.IOSwap = SPI_IO_SWAP_DISABLE;
  if (HAL_SPI_Init(&hspi4) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN SPI4_Init 2 */

  /* USER CODE END SPI4_Init 2 */

}

void HAL_SPI_MspInit(SPI_HandleTypeDef* spiHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
  if(spiHandle->Instance==SPI1)
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SPI1;
    PeriphClkInitStruct.Spi123ClockSelection = RCC_SPI123CLKSOURCE_PLL;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
    {
      Error_Handler();
    }

    /* SPI1 clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();

    __HAL_RCC_GPIOA_CLK_ENABLE();
    /**SPI1 GPIO Configuration
    PA5     ------> SPI1_SCK
    PA6     ------> SPI1_MISO
    PA7     ------> SPI1_MOSI
    */
    GPIO_InitStruct.Pin = DPS310_Pin|GPIO_PIN_6|GPIO_PIN_7;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* SPI1 DMA Init */
    /* SPI1_RX Init */
    hdma_spi1_rx.Instance = DMA1_Stream1;
    hdma_spi1_rx.Init.Request = DMA_REQUEST_SPI1_RX;
    hdma_spi1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_spi1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_spi1_rx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_spi1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi1_rx.Init.Mode = DMA_NORMAL;
    hdma_spi1_rx.Init.Priority = DMA_PRIORITY_LOW;
    hdma_spi1_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    if (HAL_DMA_Init(&hdma_spi1_rx) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_LINKDMA(spiHandle,hdmarx,hdma_spi1_rx);

    /* SPI1_TX Init */
    hdma_spi1_tx.Instance = DMA1_Stream2;
    hdma_spi1_tx.Init.Request = DMA_REQUEST_SPI1_TX;
    hdma_spi1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
    hdma_spi1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_spi1_tx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_spi1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi1_tx.Init.Mode = DMA_NORMAL;
    hdma_spi1_tx.Init.Priority = DMA_PRIORITY_LOW;
    hdma_spi1_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    if (HAL_DMA_Init(&hdma_spi1_tx) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_LINKDMA(spiHandle,hdmatx,hdma_spi1_tx);

    /* SPI1 interrupt Init */
    HAL_NVIC_SetPriority(SPI1_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(SPI1_IRQn);
  /* USER CODE BEGIN SPI1_MspInit 1 */

  /* USER CODE END SPI1_MspInit 1 */
  }
  else if(spiHandle->Instance==SPI2)
  {
  /* USER CODE BEGIN SPI2_MspInit 0 */

  /* USER CODE END SPI2_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SPI2;
    PeriphClkInitStruct.Spi123ClockSelection = RCC_SPI123CLKSOURCE_PLL;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
    {
      Error_Handler();
    }

    /* SPI2 clock enable */
    __HAL_RCC_SPI2_CLK_ENABLE();

    __HAL_RCC_GPIOB_CLK_ENABLE();
    /**SPI2 GPIO Configuration
    PB13     ------> SPI2_SCK
    PB14     ------> SPI2_MISO
    PB15     ------> SPI2_MOSI
    */
    GPIO_InitStruct.Pin = PMW3901_Pin|GPIO_PIN_14|GPIO_PIN_15;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    /* SPI2 DMA Init */
    /* SPI2_RX Init */
    hdma_spi2_rx.Instance = DMA1_Stream3;
    hdma_spi2_rx.Init.Request = DMA_REQUEST_SPI2_RX;
    hdma_spi2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_spi2_rx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_spi2_rx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_spi2_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi2_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi2_rx.Init.Mode = DMA_NORMAL;
    hdma_spi2_rx.Init.Priority = DMA_PRIORITY_LOW;
    hdma_spi2_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    if (HAL_DMA_Init(&hdma_spi2_rx) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_LINKDMA(spiHandle,hdmarx,hdma_spi2_rx);

    /* SPI2_TX Init */
    hdma_spi2_tx.Instance = DMA1_Stream4;
    hdma_spi2_tx.Init.Request = DMA_REQUEST_SPI2_TX;
    hdma_spi2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
    hdma_spi2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_spi2_tx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_spi2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi2_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi2_tx.Init.Mode = DMA_NORMAL;
    hdma_spi2_tx.Init.Priority = DMA_PRIORITY_LOW;
    hdma_spi2_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    if (HAL_DMA_Init(&hdma_spi2_tx) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_LINKDMA(spiHandle,hdmatx,hdma_spi2_tx);

    /* SPI2 interrupt Init */
    HAL_NVIC_SetPriority(SPI2_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(SPI2_IRQn);
  /* USER CODE BEGIN SPI2_MspInit 1 */

  /* USER CODE END SPI2_MspInit 1 */
  }
  else if(spiHandle->Instance==SPI3)
  {
  /* USER CODE BEGIN SPI3_MspInit 0 */

  /* USER CODE END SPI3_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SPI3;
    PeriphClkInitStruct.Spi123ClockSelection = RCC_SPI123CLKSOURCE_PLL;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
    {
      Error_Handler();
    }

    /* SPI3 clock enable */
    __HAL_RCC_SPI3_CLK_ENABLE();

    __HAL_RCC_GPIOC_CLK_ENABLE();
    /**SPI3 GPIO Configuration
    PC10     ------> SPI3_SCK
    PC11     ------> SPI3_MISO
    PC12     ------> SPI3_MOSI
    */
    GPIO_InitStruct.Pin = ICM42688_Pin|GPIO_PIN_11|GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

    /* SPI3 DMA Init */
    /* SPI3_RX Init */
    hdma_spi3_rx.Instance = DMA1_Stream5;
    hdma_spi3_rx.Init.Request = DMA_REQUEST_SPI3_RX;
    hdma_spi3_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_spi3_rx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_spi3_rx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_spi3_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi3_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi3_rx.Init.Mode = DMA_NORMAL;
    hdma_spi3_rx.Init.Priority = DMA_PRIORITY_LOW;
    hdma_spi3_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    if (HAL_DMA_Init(&hdma_spi3_rx) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_LINKDMA(spiHandle,hdmarx,hdma_spi3_rx);

    /* SPI3_TX Init */
    hdma_spi3_tx.Instance = DMA1_Stream6;
    hdma_spi3_tx.Init.Request = DMA_REQUEST_SPI3_TX;
    hdma_spi3_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
    hdma_spi3_tx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_spi3_tx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_spi3_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi3_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi3_tx.Init.Mode = DMA_NORMAL;
    hdma_spi3_tx.Init.Priority = DMA_PRIORITY_LOW;
    hdma_spi3_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    if (HAL_DMA_Init(&hdma_spi3_tx) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_LINKDMA(spiHandle,hdmatx,hdma_spi3_tx);

    /* SPI3 interrupt Init */
    HAL_NVIC_SetPriority(SPI3_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(SPI3_IRQn);
  /* USER CODE BEGIN SPI3_MspInit 1 */

  /* USER CODE END SPI3_MspInit 1 */
  }
  else if(spiHandle->Instance==SPI4)
  {
  /* USER CODE BEGIN SPI4_MspInit 0 */

  /* USER CODE END SPI4_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SPI4;
    PeriphClkInitStruct.Spi45ClockSelection = RCC_SPI45CLKSOURCE_D2PCLK1;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
    {
      Error_Handler();
    }

    /* SPI4 clock enable */
    __HAL_RCC_SPI4_CLK_ENABLE();

    __HAL_RCC_GPIOE_CLK_ENABLE();
    /**SPI4 GPIO Configuration
    PE2     ------> SPI4_SCK
    PE5     ------> SPI4_MISO
    PE6     ------> SPI4_MOSI
    PE11     ------> SPI4_NSS
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_11;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI4;
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);

    /* SPI4 DMA Init */
    /* SPI4_RX Init */
    hdma_spi4_rx.Instance = DMA2_Stream0;
    hdma_spi4_rx.Init.Request = DMA_REQUEST_SPI4_RX;
    hdma_spi4_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_spi4_rx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_spi4_rx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_spi4_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi4_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi4_rx.Init.Mode = DMA_NORMAL;
    hdma_spi4_rx.Init.Priority = DMA_PRIORITY_HIGH;
    hdma_spi4_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    if (HAL_DMA_Init(&hdma_spi4_rx) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_LINKDMA(spiHandle,hdmarx,hdma_spi4_rx);

    /* SPI4_TX Init */
    hdma_spi4_tx.Instance = DMA2_Stream1;
    hdma_spi4_tx.Init.Request = DMA_REQUEST_SPI4_TX;
    hdma_spi4_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
    hdma_spi4_tx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_spi4_tx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_spi4_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi4_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi4_tx.Init.Mode = DMA_NORMAL;
    hdma_spi4_tx.Init.Priority = DMA_PRIORITY_HIGH;
    hdma_spi4_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    if (HAL_DMA_Init(&hdma_spi4_tx) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_LINKDMA(spiHandle,hdmatx,hdma_spi4_tx);

    /* SPI4 interrupt Init */
    HAL_NVIC_SetPriority(SPI4_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(SPI4_IRQn);
  /* USER CODE BEGIN SPI4_MspInit 1 */

  /* USER CODE END SPI4_MspInit 1 */
  }
}

void HAL_SPI_MspDeInit(SPI_HandleTypeDef* spiHandle)
{

  if(spiHandle->Instance==SPI1)
  {
  /* USER CODE BEGIN SPI1_MspDeInit 0 */

  /* USER CODE END SPI1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_SPI1_CLK_DISABLE();

    /**SPI1 GPIO Configuration
    PA5     ------> SPI1_SCK
    PA6     ------> SPI1_MISO
    PA7     ------> SPI1_MOSI
    */
    HAL_GPIO_DeInit(GPIOA, DPS310_Pin|GPIO_PIN_6|GPIO_PIN_7);

    /* SPI1 DMA DeInit */
    HAL_DMA_DeInit(spiHandle->hdmarx);
    HAL_DMA_DeInit(spiHandle->hdmatx);

    /* SPI1 interrupt Deinit */
    HAL_NVIC_DisableIRQ(SPI1_IRQn);
  /* USER CODE BEGIN SPI1_MspDeInit 1 */

  /* USER CODE END SPI1_MspDeInit 1 */
  }
  else if(spiHandle->Instance==SPI2)
  {
  /* USER CODE BEGIN SPI2_MspDeInit 0 */

  /* USER CODE END SPI2_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_SPI2_CLK_DISABLE();

    /**SPI2 GPIO Configuration
    PB13     ------> SPI2_SCK
    PB14     ------> SPI2_MISO
    PB15     ------> SPI2_MOSI
    */
    HAL_GPIO_DeInit(GPIOB, PMW3901_Pin|GPIO_PIN_14|GPIO_PIN_15);

    /* SPI2 DMA DeInit */
    HAL_DMA_DeInit(spiHandle->hdmarx);
    HAL_DMA_DeInit(spiHandle->hdmatx);

    /* SPI2 interrupt Deinit */
    HAL_NVIC_DisableIRQ(SPI2_IRQn);
  /* USER CODE BEGIN SPI2_MspDeInit 1 */

  /* USER CODE END SPI2_MspDeInit 1 */
  }
  else if(spiHandle->Instance==SPI3)
  {
  /* USER CODE BEGIN SPI3_MspDeInit 0 */

  /* USER CODE END SPI3_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_SPI3_CLK_DISABLE();

    /**SPI3 GPIO Configuration
    PC10     ------> SPI3_SCK
    PC11     ------> SPI3_MISO
    PC12     ------> SPI3_MOSI
    */
    HAL_GPIO_DeInit(GPIOC, ICM42688_Pin|GPIO_PIN_11|GPIO_PIN_12);

    /* SPI3 DMA DeInit */
    HAL_DMA_DeInit(spiHandle->hdmarx);
    HAL_DMA_DeInit(spiHandle->hdmatx);

    /* SPI3 interrupt Deinit */
    HAL_NVIC_DisableIRQ(SPI3_IRQn);
  /* USER CODE BEGIN SPI3_MspDeInit 1 */

  /* USER CODE END SPI3_MspDeInit 1 */
  }
  else if(spiHandle->Instance==SPI4)
  {
  /* USER CODE BEGIN SPI4_MspDeInit 0 */

  /* USER CODE END SPI4_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_SPI4_CLK_DISABLE();

    /**SPI4 GPIO Configuration
    PE2     ------> SPI4_SCK
    PE5     ------> SPI4_MISO
    PE6     ------> SPI4_MOSI
    PE11     ------> SPI4_NSS
    */
    HAL_GPIO_DeInit(GPIOE, GPIO_PIN_2|GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_11);

    /* SPI4 DMA DeInit */
    HAL_DMA_DeInit(spiHandle->hdmarx);
    HAL_DMA_DeInit(spiHandle->hdmatx);

    /* SPI4 interrupt Deinit */
    HAL_NVIC_DisableIRQ(SPI4_IRQn);
  /* USER CODE BEGIN SPI4_MspDeInit 1 */

  /* USER CODE END SPI4_MspDeInit 1 */
  }
}

/* USER CODE BEGIN 1 */

/* USER CODE END 1 */
</file>

<file path="MyCore/Inc/Sensors.hpp">
#pragma once

#include "main.h"
#include "i2c.h"
#include "spi.h"
#include "DataStructConfig.hpp"

#define DPS310_PRS_B2     0x00
#define DPS310_TMP_B2     0x03
#define DPS310_PRS_CFG    0x06
#define DPS310_TMP_CFG    0x07
#define DPS310_MEAS_CFG   0x08
#define DPS310_CFG_REG    0x09
#define DPS310_RESET      0x0C
#define DPS310_COEF_START 0x10
#define DPS310_COEF_SRCE  0x28
/*--------------------------------------*DPS310regmap*--------------------------------------*/

#define PMW3901_REG_ID             0x00
#define PMW3901_REG_MOTION         0x02
#define PMW3901_REG_DELTA_X_L      0x03
#define PMW3901_REG_MOTION_BURST   0x16
#define PMW3901_REG_POWER_UP_RESET 0x3A

#define W(reg)                     ((reg) | 0x80) // PMW辅助写入宏
/*--------------------------------------*PMW3901regmap*--------------------------------------*/

#define ICM42688_DEVICE_CONFIG_ADDR 0x11 // 软复位与 SPI 模式配置
#define ICM42688_INT_CONFIG_ADDR    0x14 // INT1/INT2 引脚电平与模式配置
#define ICM42688_FIFO_DATA_ADDR     0x30 // FIFO 数据读出口 (DMA 突发读取地址)
#define ICM42688_PWR_MGMTO_ADDR     0x4E // 电源管理 (开启陀螺仪与加速计)
#define ICM42688_GYRO_CONFIG0_ADDR  0x4F // 陀螺仪 ODR 与量程
#define ICM42688_ACCEL_CONFIG0_ADDR 0x50 // 加速计 ODR 与量程
#define ICM42688_FIFO_CONFIG1_ADDR  0x5F // 启用 20-bit 高分辨率模式 (FIFO_HIRES_EN)
#define ICM42688_INT_SOURCE0_ADDR   0x65 // 中断源映射 (Data Ready 映射至 INT1)
#define ICM42688_WHO_AM_I_ADDR      0x75 // 器件ID验证 (应返回 0x47)
#define ICM42688_INTF_CONFIG5_ADDR  0x7B // 配置引脚 9 为 CLKIN (外部时钟输入)
#define ICM42688_REG_BANK_SEL_ADDR  0x76 // 切换 Bank 0/1/2/3/4
#define ICM42688_FIFO_CONFIG_ADDR   0x16
#define ICM42688_INT_CONFIG1_ADDR   0x64

/*--------------------------------------*ICM42688regmap*--------------------------------------*/

#define MMC5983_REG_XOUT0      0x00
#define MMC5983_REG_STATUS     0x08
#define MMC5983_REG_CTRL0      0x09
#define MMC5983_REG_CTRL1      0x0A
#define MMC5983_REG_CTRL2      0x0B
#define MMC5983_REG_CTRL3      0x0C
#define MMC5983_REG_PRODUCT_ID 0x2F
/*--------------------------------------*MMC5983regmap*--------------------------------------*/

class DPS310 : public SensorBase
{
public:
    DPS310(SensorID_e id, BusDriver *bus, uint8_t *tx, uint8_t *rx,
           GPIO_TypeDef *cs_port, uint16_t cs_pin);
    void init_regs(); // 初始化任务中调用
    bool read_data(); // 周期性调用 (如 32Hz)
    void process_in_task() override;

private:
    struct Coeffs {
        int32_t c0, c1;
        int32_t c00, c10, c01, c11, c20, c21, c30;
    } m_coeffs;
    float m_kp;
    float m_kt;
    int32_t get_twos_complement(uint32_t val, uint8_t length);
    void parse_coeffs();
    float compensate_pressure(int32_t raw_p, int32_t raw_t);
    float compensate_temperature(int32_t raw_t);
};

class PMW3901 : public SensorBase
{
public:
    // 构造函数
    PMW3901(SensorID_e id, BusDriver *bus, uint8_t *tx, uint8_t *rx,
            GPIO_TypeDef *cs_port, uint16_t cs_pin);

    // 接口函数
    void init_regs();                // 初始化序列
    bool read_data();                // 触发 Burst 读取
    void process_in_task() override; // 数据解析

private:
    // 内部使用的寄存器配置结构
    struct RegCfg {
        uint8_t addr;
        uint8_t val;
    };

    // 静态优化参数序列 (存储在 Flash 中)
    static const RegCfg opt_seq_part1[];
    static const RegCfg opt_seq_part2[];

    // 批量写入辅助函数
    void write_block(const RegCfg *seq, size_t len);
};

class ICM42688 : public SensorBase
{
public:
    ICM42688(SensorID_e id, BusDriver *bus, uint8_t *tx, uint8_t *rx,
             GPIO_TypeDef *cs_port, uint16_t cs_pin);
    void init_regs();
    bool read_fifo();
    void process_in_task() override;

private:
    int32_t parse_20bit(uint8_t h, uint8_t l, uint8_t ext, uint8_t shift);
};
// --- MMC5983 (I2C) ---
class MMC5983 : public SensorBase
{
public:
    MMC5983(SensorID_e id, BusDriver *bus, uint8_t *tx, uint8_t *rx, uint16_t i2c_addr);
    void init_regs();
    bool read_mag();
    void process_in_task() override;
};
</file>

<file path="Core/Inc/main.h">
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.h
  * @brief          : Header for main.c file.
  *                   This file contains the common defines of the application.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2026 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __MAIN_H
#define __MAIN_H

#ifdef __cplusplus
extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "stm32h7xx_hal.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
extern volatile float Mag_Gauss_x;
extern volatile float Mag_Gauss_y;
extern volatile float Mag_Gauss_z;
/* USER CODE END Includes */

/* Exported types ------------------------------------------------------------*/
/* USER CODE BEGIN ET */

/* USER CODE END ET */

/* Exported constants --------------------------------------------------------*/
/* USER CODE BEGIN EC */

/* USER CODE END EC */

/* Exported macro ------------------------------------------------------------*/
/* USER CODE BEGIN EM */

/* USER CODE END EM */

/* Exported functions prototypes ---------------------------------------------*/
void Error_Handler(void);

/* USER CODE BEGIN EFP */

/* USER CODE END EFP */

/* Private defines -----------------------------------------------------------*/
#define ICM42688GND_Pin GPIO_PIN_3
#define ICM42688GND_GPIO_Port GPIOE
#define ICM42688VCC_Pin GPIO_PIN_4
#define ICM42688VCC_GPIO_Port GPIOE
#define DPS310VCC_Pin GPIO_PIN_2
#define DPS310VCC_GPIO_Port GPIOA
#define DPS310GND_Pin GPIO_PIN_3
#define DPS310GND_GPIO_Port GPIOA
#define DPS310_NCS_Pin GPIO_PIN_4
#define DPS310_NCS_GPIO_Port GPIOA
#define DPS310_Pin GPIO_PIN_5
#define DPS310_GPIO_Port GPIOA
#define PMW3901_NCS_Pin GPIO_PIN_12
#define PMW3901_NCS_GPIO_Port GPIOB
#define PMW3901_Pin GPIO_PIN_13
#define PMW3901_GPIO_Port GPIOB
#define PMW3901VCC_Pin GPIO_PIN_14
#define PMW3901VCC_GPIO_Port GPIOD
#define ICM42688INT_Pin GPIO_PIN_8
#define ICM42688INT_GPIO_Port GPIOC
#define ICM42688INT_EXTI_IRQn EXTI9_5_IRQn
#define PMW3901GND_Pin GPIO_PIN_15
#define PMW3901GND_GPIO_Port GPIOA
#define ICM42688_Pin GPIO_PIN_10
#define ICM42688_GPIO_Port GPIOC
#define ICM42688_NCS_Pin GPIO_PIN_2
#define ICM42688_NCS_GPIO_Port GPIOD
#define MMC5983VCC_Pin GPIO_PIN_4
#define MMC5983VCC_GPIO_Port GPIOB
#define MMC5983GND_Pin GPIO_PIN_5
#define MMC5983GND_GPIO_Port GPIOB

/* USER CODE BEGIN Private defines */

/* USER CODE END Private defines */

#ifdef __cplusplus
}
#endif

#endif /* __MAIN_H */
</file>

<file path="Core/Src/main.c">
/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2026 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "cmsis_os.h"
#include "dma.h"
#include "gpio.h"
#include "i2c.h"
#include "spi.h"
#include "tim.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "DTCMinit.h"
#include "Mydelay.hpp"
#include "TaskConfig.hpp"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */
volatile float Mag_Gauss_x = 0;
volatile float Mag_Gauss_y = 0;
volatile float Mag_Gauss_z = 0;
/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MPU_Config(void);
void MX_FREERTOS_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void)
{

    /* USER CODE BEGIN 1 */
    System_DTCM_Init(); // 初始化 DTCM 内存
    /* USER CODE END 1 */

    /* MPU Configuration--------------------------------------------------------*/
    MPU_Config();

    /* Enable the CPU Cache */

    /* Enable I-Cache---------------------------------------------------------*/
    SCB_EnableICache();

    /* Enable D-Cache---------------------------------------------------------*/
    SCB_EnableDCache();

    /* MCU Configuration--------------------------------------------------------*/

    /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
    HAL_Init();

    /* USER CODE BEGIN Init */

    /* USER CODE END Init */

    /* Configure the system clock */
    SystemClock_Config();

    /* USER CODE BEGIN SysInit */
    DWT_Time_Init(); // 初始化 DWT 计数器
    /* USER CODE END SysInit */

    /* Initialize all configured peripherals */
    MX_GPIO_Init();
    MX_DMA_Init();
    MX_SPI1_Init();
    MX_SPI2_Init();
    MX_SPI3_Init();
    MX_TIM2_Init();
    MX_TIM4_Init();
    MX_I2C1_Init();
    MX_SPI4_Init();
    /* USER CODE BEGIN 2 */
    Bridge_SystemSensors_Init(); // 初始化传感器系统
    /* USER CODE END 2 */

    /* Init scheduler */
    osKernelInitialize(); /* Call init function for freertos objects (in cmsis_os2.c) */
    MX_FREERTOS_Init();

    /* Start scheduler */
    osKernelStart();

    /* We should never get here as control is now taken by the scheduler */

    /* Infinite loop */
    /* USER CODE BEGIN WHILE */
    while (1)
    {
        /* USER CODE END WHILE */

        /* USER CODE BEGIN 3 */
    }
    /* USER CODE END 3 */
}

/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void)
{
    RCC_OscInitTypeDef RCC_OscInitStruct = {0};
    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

    /** Supply configuration update enable
     */
    HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);

    /** Configure the main internal regulator output voltage
     */
    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);

    while (!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY))
    {
    }

    /** Initializes the RCC Oscillators according to the specified parameters
     * in the RCC_OscInitTypeDef structure.
     */
    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
    RCC_OscInitStruct.HSEState = RCC_HSE_ON;
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
    RCC_OscInitStruct.PLL.PLLM = 5;
    RCC_OscInitStruct.PLL.PLLN = 192;
    RCC_OscInitStruct.PLL.PLLP = 2;
    RCC_OscInitStruct.PLL.PLLQ = 5;
    RCC_OscInitStruct.PLL.PLLR = 2;
    RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;
    RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
    RCC_OscInitStruct.PLL.PLLFRACN = 0;
    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
    {
        Error_Handler();
    }

    /** Initializes the CPU, AHB and APB buses clocks
     */
    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 | RCC_CLOCKTYPE_D3PCLK1 | RCC_CLOCKTYPE_D1PCLK1;
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
    RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
    RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
    RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
    RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
    RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
    RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;

    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
    {
        Error_Handler();
    }
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/* MPU Configuration */

void MPU_Config(void)
{
    MPU_Region_InitTypeDef MPU_InitStruct = {0};

    /* Disables the MPU */
    HAL_MPU_Disable();

    /** Initializes and configures the Region and the memory to be protected
     */
    MPU_InitStruct.Enable = MPU_REGION_ENABLE;
    MPU_InitStruct.Number = MPU_REGION_NUMBER0;
    MPU_InitStruct.BaseAddress = 0x0;
    MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;
    MPU_InitStruct.SubRegionDisable = 0x87;
    MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
    MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS;
    MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
    MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
    MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
    MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;

    HAL_MPU_ConfigRegion(&MPU_InitStruct);
    /* Enables the MPU */
    HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
}

/**
 * @brief  Period elapsed callback in non blocking mode
 * @note   This function is called  when TIM7 interrupt took place, inside
 * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment
 * a global variable "uwTick" used as application time base.
 * @param  htim : TIM handle
 * @retval None
 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    /* USER CODE BEGIN Callback 0 */

    /* USER CODE END Callback 0 */
    if (htim->Instance == TIM7)
    {
        HAL_IncTick();
    }
    /* USER CODE BEGIN Callback 1 */

    /* USER CODE END Callback 1 */
}

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void)
{
    /* USER CODE BEGIN Error_Handler_Debug */
    /* User can add his own implementation to report the HAL error return state */
    __disable_irq();
    while (1)
    {
    }
    /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
 * @brief  Reports the name of the source file and the source line number
 *         where the assert_param error has occurred.
 * @param  file: pointer to the source file name
 * @param  line: assert_param error line source number
 * @retval None
 */
void assert_failed(uint8_t *file, uint32_t line)
{
    /* USER CODE BEGIN 6 */
    /* User can add his own implementation to report the file name and line number,
       ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
    /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
</file>

<file path="MyCore/Src/DataStructConfig.cpp">
#include "DataStructConfig.hpp"

// BusDriver 实现
BusDriver::BusDriver() : lock(NULL), active_device(nullptr), is_read_op(false)
{
}

void BusDriver::init()
{
    lock = xSemaphoreCreateBinary();
    if (lock != NULL) {
        xSemaphoreGive(lock);
    }
}

// SensorBase 实现
SensorBase::SensorBase(SensorID_e id, BusDriver *bus, uint8_t *tx, uint8_t *rx)
    : _id(id), _bus(bus), _tx_buf(tx), _rx_buf(rx)
{
}

void SensorBase::notify_task_ISR()
{
    // 1. 针对 H7 的 AXI SRAM，失效 Cache 确保 CPU 读到最新 DMA 数据
    SCB_InvalidateDCache_by_Addr((uint32_t *)_rx_buf, 32);

    // 2. 发送任务通知唤醒处理任务
    if (_data_task_handle != nullptr) {
        BaseType_t xHigherPriorityTaskWoken = pdFALSE;
        vTaskNotifyGiveFromISR(_data_task_handle, &xHigherPriorityTaskWoken);
        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    }
}

bool SensorBase::read_regs(uint8_t reg, uint16_t len)
{
    _bus->active_device = this; //  告知总线当前使用者
    return _bus->transfer(_config, reg, _tx_buf, _rx_buf, len, true);
}

bool SensorBase::write_regs(uint8_t reg, uint8_t *data, uint16_t len)
{
    _bus->active_device = this;
    if (len > 30) return false;

    // 借用 rx_buf 暂存数据，根据子类中的通信协议传入_tx_buf
    memcpy(_rx_buf, data, len);
    return _bus->transfer(_config, reg, _tx_buf, _rx_buf, len, false);
}

bool SensorBase::write_reg(uint8_t reg, uint8_t val)
{
    return write_regs(reg, &val, 1);
}

SPIBus::SPIBus(SPI_HandleTypeDef *h) : hspi(h)
{
}

bool SPIBus::transfer(const DeviceConfig &cfg, uint8_t reg, uint8_t *tx, uint8_t *rx, uint16_t len, bool is_read)
{
    if (lock == NULL) return false;
    if (xSemaphoreTake(lock, pdMS_TO_TICKS(2)) != pdTRUE) return false;

    this->current_cfg = cfg;
    this->is_read_op  = is_read;
    if (is_read) {
        if (cfg.spi.read_sets_bit) {
            tx[0] = reg | 0x80; // 标准模式 (ICM42688): Read = 1
        } else {
            tx[0] = reg & 0x7F; // 反向模式 (PMW3901): Read = 0
        }
        memset(&tx[1], 0, len);
    } else {
        if (cfg.spi.read_sets_bit) {
            tx[0] = reg & 0x7F; // 标准模式: Write = 0
        } else {
            tx[0] = reg | 0x80; // 反向模式: Write = 1
        }
        memcpy(&tx[1], rx, len);
    }

    SCB_CleanDCache_by_Addr((uint32_t *)tx, 32);
    SCB_InvalidateDCache_by_Addr((uint32_t *)rx, 32);

    HAL_GPIO_WritePin(cfg.spi.port, cfg.spi.pin, GPIO_PIN_RESET);
    if (HAL_SPI_TransmitReceive_DMA(hspi, tx, rx, len + 1) != HAL_OK) {
        HAL_GPIO_WritePin(cfg.spi.port, cfg.spi.pin, GPIO_PIN_SET);
        xSemaphoreGive(lock);
        return false;
    }
    return true;
}

void SPIBus::irq_handler()
{
    HAL_GPIO_WritePin(current_cfg.spi.port, current_cfg.spi.pin, GPIO_PIN_SET);
    if (active_device && is_read_op) {
        active_device->notify_task_ISR();
    }
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    xSemaphoreGiveFromISR(lock, &xHigherPriorityTaskWoken);
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

I2CBus::I2CBus(I2C_HandleTypeDef *h) : hi2c(h)
{
}

bool I2CBus::transfer(const DeviceConfig &cfg, uint8_t reg, uint8_t *tx, uint8_t *rx, uint16_t len, bool is_read)
{
    if (xSemaphoreTake(lock, pdMS_TO_TICKS(5)) != pdTRUE) return false;
    this->is_read_op = is_read;
    if (is_read) {
        SCB_InvalidateDCache_by_Addr((uint32_t *)rx, 32);
        if (HAL_I2C_Mem_Read_DMA(hi2c, cfg.i2c.addr, reg, I2C_MEMADD_SIZE_8BIT, rx, len) != HAL_OK) {
            xSemaphoreGive(lock);
            return false;
        }
    } else {
        memcpy(tx, rx, len); // I2C写需要放到 tx
        SCB_CleanDCache_by_Addr((uint32_t *)tx, 32);
        if (HAL_I2C_Mem_Write_DMA(hi2c, cfg.i2c.addr, reg, I2C_MEMADD_SIZE_8BIT, tx, len) != HAL_OK) {
            xSemaphoreGive(lock);
            return false;
        }
    }
    return true;
}

void I2CBus::irq_handler()
{
    if (active_device && is_read_op) {
        active_device->notify_task_ISR();
    }
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    xSemaphoreGiveFromISR(lock, &xHigherPriorityTaskWoken);
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}
</file>

<file path="MyDrone.ioc">
#MicroXplorer Configuration settings - do not modify
CAD.formats=
CAD.pinconfig=
CAD.provider=
CORTEX_M7.CPU_DCache=Enabled
CORTEX_M7.CPU_ICache=Enabled
CORTEX_M7.IPParameters=default_mode_Activation,CPU_ICache,CPU_DCache
CORTEX_M7.default_mode_Activation=1
Dma.I2C1_RX.6.Direction=DMA_PERIPH_TO_MEMORY
Dma.I2C1_RX.6.EventEnable=DISABLE
Dma.I2C1_RX.6.FIFOMode=DMA_FIFOMODE_DISABLE
Dma.I2C1_RX.6.Instance=DMA1_Stream0
Dma.I2C1_RX.6.MemDataAlignment=DMA_MDATAALIGN_BYTE
Dma.I2C1_RX.6.MemInc=DMA_MINC_ENABLE
Dma.I2C1_RX.6.Mode=DMA_NORMAL
Dma.I2C1_RX.6.PeriphDataAlignment=DMA_PDATAALIGN_BYTE
Dma.I2C1_RX.6.PeriphInc=DMA_PINC_DISABLE
Dma.I2C1_RX.6.Polarity=HAL_DMAMUX_REQ_GEN_RISING
Dma.I2C1_RX.6.Priority=DMA_PRIORITY_LOW
Dma.I2C1_RX.6.RequestNumber=1
Dma.I2C1_RX.6.RequestParameters=Instance,Direction,PeriphInc,MemInc,PeriphDataAlignment,MemDataAlignment,Mode,Priority,FIFOMode,SignalID,Polarity,RequestNumber,SyncSignalID,SyncPolarity,SyncEnable,EventEnable,SyncRequestNumber
Dma.I2C1_RX.6.SignalID=NONE
Dma.I2C1_RX.6.SyncEnable=DISABLE
Dma.I2C1_RX.6.SyncPolarity=HAL_DMAMUX_SYNC_NO_EVENT
Dma.I2C1_RX.6.SyncRequestNumber=1
Dma.I2C1_RX.6.SyncSignalID=NONE
Dma.I2C1_TX.7.Direction=DMA_MEMORY_TO_PERIPH
Dma.I2C1_TX.7.EventEnable=DISABLE
Dma.I2C1_TX.7.FIFOMode=DMA_FIFOMODE_DISABLE
Dma.I2C1_TX.7.Instance=DMA1_Stream7
Dma.I2C1_TX.7.MemDataAlignment=DMA_MDATAALIGN_BYTE
Dma.I2C1_TX.7.MemInc=DMA_MINC_ENABLE
Dma.I2C1_TX.7.Mode=DMA_NORMAL
Dma.I2C1_TX.7.PeriphDataAlignment=DMA_PDATAALIGN_BYTE
Dma.I2C1_TX.7.PeriphInc=DMA_PINC_DISABLE
Dma.I2C1_TX.7.Polarity=HAL_DMAMUX_REQ_GEN_RISING
Dma.I2C1_TX.7.Priority=DMA_PRIORITY_LOW
Dma.I2C1_TX.7.RequestNumber=1
Dma.I2C1_TX.7.RequestParameters=Instance,Direction,PeriphInc,MemInc,PeriphDataAlignment,MemDataAlignment,Mode,Priority,FIFOMode,SignalID,Polarity,RequestNumber,SyncSignalID,SyncPolarity,SyncEnable,EventEnable,SyncRequestNumber
Dma.I2C1_TX.7.SignalID=NONE
Dma.I2C1_TX.7.SyncEnable=DISABLE
Dma.I2C1_TX.7.SyncPolarity=HAL_DMAMUX_SYNC_NO_EVENT
Dma.I2C1_TX.7.SyncRequestNumber=1
Dma.I2C1_TX.7.SyncSignalID=NONE
Dma.Request0=SPI1_RX
Dma.Request1=SPI1_TX
Dma.Request2=SPI2_RX
Dma.Request3=SPI2_TX
Dma.Request4=SPI3_RX
Dma.Request5=SPI3_TX
Dma.Request6=I2C1_RX
Dma.Request7=I2C1_TX
Dma.Request8=SPI4_RX
Dma.Request9=SPI4_TX
Dma.RequestsNb=10
Dma.SPI1_RX.0.Direction=DMA_PERIPH_TO_MEMORY
Dma.SPI1_RX.0.EventEnable=DISABLE
Dma.SPI1_RX.0.FIFOMode=DMA_FIFOMODE_DISABLE
Dma.SPI1_RX.0.Instance=DMA1_Stream1
Dma.SPI1_RX.0.MemDataAlignment=DMA_MDATAALIGN_BYTE
Dma.SPI1_RX.0.MemInc=DMA_MINC_ENABLE
Dma.SPI1_RX.0.Mode=DMA_NORMAL
Dma.SPI1_RX.0.PeriphDataAlignment=DMA_PDATAALIGN_BYTE
Dma.SPI1_RX.0.PeriphInc=DMA_PINC_DISABLE
Dma.SPI1_RX.0.Polarity=HAL_DMAMUX_REQ_GEN_RISING
Dma.SPI1_RX.0.Priority=DMA_PRIORITY_LOW
Dma.SPI1_RX.0.RequestNumber=1
Dma.SPI1_RX.0.RequestParameters=Instance,Direction,PeriphInc,MemInc,PeriphDataAlignment,MemDataAlignment,Mode,Priority,FIFOMode,SignalID,Polarity,RequestNumber,SyncSignalID,SyncPolarity,SyncEnable,EventEnable,SyncRequestNumber
Dma.SPI1_RX.0.SignalID=NONE
Dma.SPI1_RX.0.SyncEnable=DISABLE
Dma.SPI1_RX.0.SyncPolarity=HAL_DMAMUX_SYNC_NO_EVENT
Dma.SPI1_RX.0.SyncRequestNumber=1
Dma.SPI1_RX.0.SyncSignalID=NONE
Dma.SPI1_TX.1.Direction=DMA_MEMORY_TO_PERIPH
Dma.SPI1_TX.1.EventEnable=DISABLE
Dma.SPI1_TX.1.FIFOMode=DMA_FIFOMODE_DISABLE
Dma.SPI1_TX.1.Instance=DMA1_Stream2
Dma.SPI1_TX.1.MemDataAlignment=DMA_MDATAALIGN_BYTE
Dma.SPI1_TX.1.MemInc=DMA_MINC_ENABLE
Dma.SPI1_TX.1.Mode=DMA_NORMAL
Dma.SPI1_TX.1.PeriphDataAlignment=DMA_PDATAALIGN_BYTE
Dma.SPI1_TX.1.PeriphInc=DMA_PINC_DISABLE
Dma.SPI1_TX.1.Polarity=HAL_DMAMUX_REQ_GEN_RISING
Dma.SPI1_TX.1.Priority=DMA_PRIORITY_LOW
Dma.SPI1_TX.1.RequestNumber=1
Dma.SPI1_TX.1.RequestParameters=Instance,Direction,PeriphInc,MemInc,PeriphDataAlignment,MemDataAlignment,Mode,Priority,FIFOMode,SignalID,Polarity,RequestNumber,SyncSignalID,SyncPolarity,SyncEnable,EventEnable,SyncRequestNumber
Dma.SPI1_TX.1.SignalID=NONE
Dma.SPI1_TX.1.SyncEnable=DISABLE
Dma.SPI1_TX.1.SyncPolarity=HAL_DMAMUX_SYNC_NO_EVENT
Dma.SPI1_TX.1.SyncRequestNumber=1
Dma.SPI1_TX.1.SyncSignalID=NONE
Dma.SPI2_RX.2.Direction=DMA_PERIPH_TO_MEMORY
Dma.SPI2_RX.2.EventEnable=DISABLE
Dma.SPI2_RX.2.FIFOMode=DMA_FIFOMODE_DISABLE
Dma.SPI2_RX.2.Instance=DMA1_Stream3
Dma.SPI2_RX.2.MemDataAlignment=DMA_MDATAALIGN_BYTE
Dma.SPI2_RX.2.MemInc=DMA_MINC_ENABLE
Dma.SPI2_RX.2.Mode=DMA_NORMAL
Dma.SPI2_RX.2.PeriphDataAlignment=DMA_PDATAALIGN_BYTE
Dma.SPI2_RX.2.PeriphInc=DMA_PINC_DISABLE
Dma.SPI2_RX.2.Polarity=HAL_DMAMUX_REQ_GEN_RISING
Dma.SPI2_RX.2.Priority=DMA_PRIORITY_LOW
Dma.SPI2_RX.2.RequestNumber=1
Dma.SPI2_RX.2.RequestParameters=Instance,Direction,PeriphInc,MemInc,PeriphDataAlignment,MemDataAlignment,Mode,Priority,FIFOMode,SignalID,Polarity,RequestNumber,SyncSignalID,SyncPolarity,SyncEnable,EventEnable,SyncRequestNumber
Dma.SPI2_RX.2.SignalID=NONE
Dma.SPI2_RX.2.SyncEnable=DISABLE
Dma.SPI2_RX.2.SyncPolarity=HAL_DMAMUX_SYNC_NO_EVENT
Dma.SPI2_RX.2.SyncRequestNumber=1
Dma.SPI2_RX.2.SyncSignalID=NONE
Dma.SPI2_TX.3.Direction=DMA_MEMORY_TO_PERIPH
Dma.SPI2_TX.3.EventEnable=DISABLE
Dma.SPI2_TX.3.FIFOMode=DMA_FIFOMODE_DISABLE
Dma.SPI2_TX.3.Instance=DMA1_Stream4
Dma.SPI2_TX.3.MemDataAlignment=DMA_MDATAALIGN_BYTE
Dma.SPI2_TX.3.MemInc=DMA_MINC_ENABLE
Dma.SPI2_TX.3.Mode=DMA_NORMAL
Dma.SPI2_TX.3.PeriphDataAlignment=DMA_PDATAALIGN_BYTE
Dma.SPI2_TX.3.PeriphInc=DMA_PINC_DISABLE
Dma.SPI2_TX.3.Polarity=HAL_DMAMUX_REQ_GEN_RISING
Dma.SPI2_TX.3.Priority=DMA_PRIORITY_LOW
Dma.SPI2_TX.3.RequestNumber=1
Dma.SPI2_TX.3.RequestParameters=Instance,Direction,PeriphInc,MemInc,PeriphDataAlignment,MemDataAlignment,Mode,Priority,FIFOMode,SignalID,Polarity,RequestNumber,SyncSignalID,SyncPolarity,SyncEnable,EventEnable,SyncRequestNumber
Dma.SPI2_TX.3.SignalID=NONE
Dma.SPI2_TX.3.SyncEnable=DISABLE
Dma.SPI2_TX.3.SyncPolarity=HAL_DMAMUX_SYNC_NO_EVENT
Dma.SPI2_TX.3.SyncRequestNumber=1
Dma.SPI2_TX.3.SyncSignalID=NONE
Dma.SPI3_RX.4.Direction=DMA_PERIPH_TO_MEMORY
Dma.SPI3_RX.4.EventEnable=DISABLE
Dma.SPI3_RX.4.FIFOMode=DMA_FIFOMODE_DISABLE
Dma.SPI3_RX.4.Instance=DMA1_Stream5
Dma.SPI3_RX.4.MemDataAlignment=DMA_MDATAALIGN_BYTE
Dma.SPI3_RX.4.MemInc=DMA_MINC_ENABLE
Dma.SPI3_RX.4.Mode=DMA_NORMAL
Dma.SPI3_RX.4.PeriphDataAlignment=DMA_PDATAALIGN_BYTE
Dma.SPI3_RX.4.PeriphInc=DMA_PINC_DISABLE
Dma.SPI3_RX.4.Polarity=HAL_DMAMUX_REQ_GEN_RISING
Dma.SPI3_RX.4.Priority=DMA_PRIORITY_LOW
Dma.SPI3_RX.4.RequestNumber=1
Dma.SPI3_RX.4.RequestParameters=Instance,Direction,PeriphInc,MemInc,PeriphDataAlignment,MemDataAlignment,Mode,Priority,FIFOMode,SignalID,Polarity,RequestNumber,SyncSignalID,SyncPolarity,SyncEnable,EventEnable,SyncRequestNumber
Dma.SPI3_RX.4.SignalID=NONE
Dma.SPI3_RX.4.SyncEnable=DISABLE
Dma.SPI3_RX.4.SyncPolarity=HAL_DMAMUX_SYNC_NO_EVENT
Dma.SPI3_RX.4.SyncRequestNumber=1
Dma.SPI3_RX.4.SyncSignalID=NONE
Dma.SPI3_TX.5.Direction=DMA_MEMORY_TO_PERIPH
Dma.SPI3_TX.5.EventEnable=DISABLE
Dma.SPI3_TX.5.FIFOMode=DMA_FIFOMODE_DISABLE
Dma.SPI3_TX.5.Instance=DMA1_Stream6
Dma.SPI3_TX.5.MemDataAlignment=DMA_MDATAALIGN_BYTE
Dma.SPI3_TX.5.MemInc=DMA_MINC_ENABLE
Dma.SPI3_TX.5.Mode=DMA_NORMAL
Dma.SPI3_TX.5.PeriphDataAlignment=DMA_PDATAALIGN_BYTE
Dma.SPI3_TX.5.PeriphInc=DMA_PINC_DISABLE
Dma.SPI3_TX.5.Polarity=HAL_DMAMUX_REQ_GEN_RISING
Dma.SPI3_TX.5.Priority=DMA_PRIORITY_LOW
Dma.SPI3_TX.5.RequestNumber=1
Dma.SPI3_TX.5.RequestParameters=Instance,Direction,PeriphInc,MemInc,PeriphDataAlignment,MemDataAlignment,Mode,Priority,FIFOMode,SignalID,Polarity,RequestNumber,SyncSignalID,SyncPolarity,SyncEnable,EventEnable,SyncRequestNumber
Dma.SPI3_TX.5.SignalID=NONE
Dma.SPI3_TX.5.SyncEnable=DISABLE
Dma.SPI3_TX.5.SyncPolarity=HAL_DMAMUX_SYNC_NO_EVENT
Dma.SPI3_TX.5.SyncRequestNumber=1
Dma.SPI3_TX.5.SyncSignalID=NONE
Dma.SPI4_RX.8.Direction=DMA_PERIPH_TO_MEMORY
Dma.SPI4_RX.8.EventEnable=DISABLE
Dma.SPI4_RX.8.FIFOMode=DMA_FIFOMODE_DISABLE
Dma.SPI4_RX.8.Instance=DMA2_Stream0
Dma.SPI4_RX.8.MemDataAlignment=DMA_MDATAALIGN_BYTE
Dma.SPI4_RX.8.MemInc=DMA_MINC_ENABLE
Dma.SPI4_RX.8.Mode=DMA_NORMAL
Dma.SPI4_RX.8.PeriphDataAlignment=DMA_PDATAALIGN_BYTE
Dma.SPI4_RX.8.PeriphInc=DMA_PINC_DISABLE
Dma.SPI4_RX.8.Polarity=HAL_DMAMUX_REQ_GEN_RISING
Dma.SPI4_RX.8.Priority=DMA_PRIORITY_HIGH
Dma.SPI4_RX.8.RequestNumber=1
Dma.SPI4_RX.8.RequestParameters=Instance,Direction,PeriphInc,MemInc,PeriphDataAlignment,MemDataAlignment,Mode,Priority,FIFOMode,SignalID,Polarity,RequestNumber,SyncSignalID,SyncPolarity,SyncEnable,EventEnable,SyncRequestNumber
Dma.SPI4_RX.8.SignalID=NONE
Dma.SPI4_RX.8.SyncEnable=DISABLE
Dma.SPI4_RX.8.SyncPolarity=HAL_DMAMUX_SYNC_NO_EVENT
Dma.SPI4_RX.8.SyncRequestNumber=1
Dma.SPI4_RX.8.SyncSignalID=NONE
Dma.SPI4_TX.9.Direction=DMA_MEMORY_TO_PERIPH
Dma.SPI4_TX.9.EventEnable=DISABLE
Dma.SPI4_TX.9.FIFOMode=DMA_FIFOMODE_DISABLE
Dma.SPI4_TX.9.Instance=DMA2_Stream1
Dma.SPI4_TX.9.MemDataAlignment=DMA_MDATAALIGN_BYTE
Dma.SPI4_TX.9.MemInc=DMA_MINC_ENABLE
Dma.SPI4_TX.9.Mode=DMA_NORMAL
Dma.SPI4_TX.9.PeriphDataAlignment=DMA_PDATAALIGN_BYTE
Dma.SPI4_TX.9.PeriphInc=DMA_PINC_DISABLE
Dma.SPI4_TX.9.Polarity=HAL_DMAMUX_REQ_GEN_RISING
Dma.SPI4_TX.9.Priority=DMA_PRIORITY_HIGH
Dma.SPI4_TX.9.RequestNumber=1
Dma.SPI4_TX.9.RequestParameters=Instance,Direction,PeriphInc,MemInc,PeriphDataAlignment,MemDataAlignment,Mode,Priority,FIFOMode,SignalID,Polarity,RequestNumber,SyncSignalID,SyncPolarity,SyncEnable,EventEnable,SyncRequestNumber
Dma.SPI4_TX.9.SignalID=NONE
Dma.SPI4_TX.9.SyncEnable=DISABLE
Dma.SPI4_TX.9.SyncPolarity=HAL_DMAMUX_SYNC_NO_EVENT
Dma.SPI4_TX.9.SyncRequestNumber=1
Dma.SPI4_TX.9.SyncSignalID=NONE
FREERTOS.HEAP_NUMBER=4
FREERTOS.IPParameters=Tasks01,configENABLE_FPU,configTOTAL_HEAP_SIZE,configCHECK_FOR_STACK_OVERFLOW,configTIMER_TASK_PRIORITY,HEAP_NUMBER
FREERTOS.Tasks01=defaultTask,24,128,StartDefaultTask,Default,NULL,Dynamic,NULL,NULL
FREERTOS.configCHECK_FOR_STACK_OVERFLOW=2
FREERTOS.configENABLE_FPU=1
FREERTOS.configTIMER_TASK_PRIORITY=40
FREERTOS.configTOTAL_HEAP_SIZE=131072
File.Version=6
GPIO.groupedBy=Show All
I2C1.IPParameters=Timing
I2C1.Timing=0x307075B1
KeepUserPlacement=false
MMTAppRegionsCount=0
MMTConfigApplied=false
MMTSectionSuffix=
Mcu.CPN=STM32H743VIT6
Mcu.Family=STM32H7
Mcu.IP0=CORTEX_M7
Mcu.IP1=DEBUG
Mcu.IP10=SPI3
Mcu.IP11=SPI4
Mcu.IP12=SYS
Mcu.IP13=TIM2
Mcu.IP14=TIM4
Mcu.IP2=DMA
Mcu.IP3=FREERTOS
Mcu.IP4=I2C1
Mcu.IP5=MEMORYMAP
Mcu.IP6=NVIC
Mcu.IP7=RCC
Mcu.IP8=SPI1
Mcu.IP9=SPI2
Mcu.IPNb=15
Mcu.Name=STM32H743VITx
Mcu.Package=LQFP100
Mcu.Pin0=PE2
Mcu.Pin1=PE3
Mcu.Pin10=PA3
Mcu.Pin11=PA4
Mcu.Pin12=PA5
Mcu.Pin13=PA6
Mcu.Pin14=PA7
Mcu.Pin15=PE11
Mcu.Pin16=PB12
Mcu.Pin17=PB13
Mcu.Pin18=PB14
Mcu.Pin19=PB15
Mcu.Pin2=PE4
Mcu.Pin20=PD12
Mcu.Pin21=PD13
Mcu.Pin22=PD14
Mcu.Pin23=PC8
Mcu.Pin24=PA13 (JTMS/SWDIO)
Mcu.Pin25=PA14 (JTCK/SWCLK)
Mcu.Pin26=PA15 (JTDI)
Mcu.Pin27=PC10
Mcu.Pin28=PC11
Mcu.Pin29=PC12
Mcu.Pin3=PE5
Mcu.Pin30=PD2
Mcu.Pin31=PB4 (NJTRST)
Mcu.Pin32=PB5
Mcu.Pin33=PB7
Mcu.Pin34=PB8
Mcu.Pin35=VP_FREERTOS_VS_CMSIS_V2
Mcu.Pin36=VP_SYS_VS_tim7
Mcu.Pin37=VP_MEMORYMAP_VS_MEMORYMAP
Mcu.Pin4=PE6
Mcu.Pin5=PH0-OSC_IN (PH0)
Mcu.Pin6=PH1-OSC_OUT (PH1)
Mcu.Pin7=PA0
Mcu.Pin8=PA1
Mcu.Pin9=PA2
Mcu.PinsNb=38
Mcu.ThirdPartyNb=0
Mcu.UserConstants=
Mcu.UserName=STM32H743VITx
MxCube.Version=6.16.1
MxDb.Version=DB.6.0.161
NVIC.BusFault_IRQn=true\:0\:0\:false\:false\:true\:false\:false\:false\:false
NVIC.DMA1_Stream0_IRQn=true\:5\:0\:false\:false\:true\:true\:false\:true\:true
NVIC.DMA1_Stream1_IRQn=true\:5\:0\:false\:false\:true\:true\:false\:true\:true
NVIC.DMA1_Stream2_IRQn=true\:5\:0\:false\:false\:true\:true\:false\:true\:true
NVIC.DMA1_Stream3_IRQn=true\:5\:0\:false\:false\:true\:true\:false\:true\:true
NVIC.DMA1_Stream4_IRQn=true\:5\:0\:false\:false\:true\:true\:false\:true\:true
NVIC.DMA1_Stream5_IRQn=true\:5\:0\:false\:false\:true\:true\:false\:true\:true
NVIC.DMA1_Stream6_IRQn=true\:5\:0\:false\:false\:true\:true\:false\:true\:true
NVIC.DMA1_Stream7_IRQn=true\:5\:0\:false\:false\:true\:true\:false\:true\:true
NVIC.DMA2_Stream0_IRQn=true\:5\:0\:false\:false\:true\:true\:false\:true\:true
NVIC.DMA2_Stream1_IRQn=true\:5\:0\:false\:false\:true\:true\:false\:true\:true
NVIC.DebugMonitor_IRQn=true\:0\:0\:false\:false\:true\:false\:false\:false\:false
NVIC.EXTI9_5_IRQn=true\:5\:0\:false\:false\:true\:true\:true\:true\:true
NVIC.ForceEnableDMAVector=true
NVIC.HardFault_IRQn=true\:0\:0\:false\:false\:true\:false\:false\:false\:false
NVIC.I2C1_ER_IRQn=true\:5\:0\:false\:false\:true\:true\:true\:true\:true
NVIC.I2C1_EV_IRQn=true\:5\:0\:false\:false\:true\:true\:true\:true\:true
NVIC.MemoryManagement_IRQn=true\:0\:0\:false\:false\:true\:false\:false\:false\:false
NVIC.NonMaskableInt_IRQn=true\:0\:0\:false\:false\:true\:false\:false\:false\:false
NVIC.PendSV_IRQn=true\:15\:0\:false\:false\:false\:true\:false\:false\:false
NVIC.PriorityGroup=NVIC_PRIORITYGROUP_4
NVIC.SPI1_IRQn=true\:5\:0\:false\:false\:true\:true\:false\:true\:true
NVIC.SPI2_IRQn=true\:5\:0\:false\:false\:true\:true\:false\:true\:true
NVIC.SPI3_IRQn=true\:5\:0\:false\:false\:true\:true\:false\:true\:true
NVIC.SPI4_IRQn=true\:5\:0\:false\:false\:true\:true\:false\:true\:true
NVIC.SVCall_IRQn=true\:0\:0\:false\:false\:false\:false\:false\:false\:false
NVIC.SavedPendsvIrqHandlerGenerated=true
NVIC.SavedSvcallIrqHandlerGenerated=true
NVIC.SavedSystickIrqHandlerGenerated=true
NVIC.SysTick_IRQn=true\:15\:0\:false\:false\:false\:true\:false\:true\:false
NVIC.TIM7_IRQn=true\:15\:0\:true\:false\:true\:false\:false\:true\:true
NVIC.TimeBase=TIM7_IRQn
NVIC.TimeBaseIP=TIM7
NVIC.UsageFault_IRQn=true\:0\:0\:false\:false\:true\:false\:false\:false\:false
PA0.Locked=true
PA0.Signal=S_TIM2_CH1_ETR
PA1.Signal=S_TIM2_CH2
PA13\ (JTMS/SWDIO).Mode=Serial_Wire
PA13\ (JTMS/SWDIO).Signal=DEBUG_JTMS-SWDIO
PA14\ (JTCK/SWCLK).Mode=Serial_Wire
PA14\ (JTCK/SWCLK).Signal=DEBUG_JTCK-SWCLK
PA15\ (JTDI).GPIOParameters=GPIO_Label
PA15\ (JTDI).GPIO_Label=PMW3901GND
PA15\ (JTDI).Locked=true
PA15\ (JTDI).Signal=GPIO_Output
PA2.GPIOParameters=PinState,GPIO_Label
PA2.GPIO_Label=DPS310VCC
PA2.Locked=true
PA2.PinState=GPIO_PIN_SET
PA2.Signal=GPIO_Output
PA3.GPIOParameters=GPIO_Label
PA3.GPIO_Label=DPS310GND
PA3.Locked=true
PA3.Signal=GPIO_Output
PA4.GPIOParameters=GPIO_Speed,PinState,GPIO_Label
PA4.GPIO_Label=DPS310_NCS
PA4.GPIO_Speed=GPIO_SPEED_FREQ_VERY_HIGH
PA4.Locked=true
PA4.PinState=GPIO_PIN_SET
PA4.Signal=GPIO_Output
PA5.GPIOParameters=GPIO_Label
PA5.GPIO_Label=DPS310
PA5.Mode=Full_Duplex_Master
PA5.Signal=SPI1_SCK
PA6.Mode=Full_Duplex_Master
PA6.Signal=SPI1_MISO
PA7.Mode=Full_Duplex_Master
PA7.Signal=SPI1_MOSI
PB12.GPIOParameters=GPIO_Speed,PinState,GPIO_Label
PB12.GPIO_Label=PMW3901_NCS
PB12.GPIO_Speed=GPIO_SPEED_FREQ_VERY_HIGH
PB12.Locked=true
PB12.PinState=GPIO_PIN_SET
PB12.Signal=GPIO_Output
PB13.GPIOParameters=GPIO_Label
PB13.GPIO_Label=PMW3901
PB13.Locked=true
PB13.Mode=Full_Duplex_Master
PB13.Signal=SPI2_SCK
PB14.Locked=true
PB14.Mode=Full_Duplex_Master
PB14.Signal=SPI2_MISO
PB15.Locked=true
PB15.Mode=Full_Duplex_Master
PB15.Signal=SPI2_MOSI
PB4\ (NJTRST).GPIOParameters=PinState,GPIO_Label
PB4\ (NJTRST).GPIO_Label=MMC5983VCC
PB4\ (NJTRST).Locked=true
PB4\ (NJTRST).PinState=GPIO_PIN_SET
PB4\ (NJTRST).Signal=GPIO_Output
PB5.GPIOParameters=GPIO_Label
PB5.GPIO_Label=MMC5983GND
PB5.Locked=true
PB5.Signal=GPIO_Output
PB7.GPIOParameters=GPIO_Speed
PB7.GPIO_Speed=GPIO_SPEED_FREQ_VERY_HIGH
PB7.Mode=I2C
PB7.Signal=I2C1_SDA
PB8.GPIOParameters=GPIO_Speed
PB8.GPIO_Speed=GPIO_SPEED_FREQ_VERY_HIGH
PB8.Locked=true
PB8.Mode=I2C
PB8.Signal=I2C1_SCL
PC10.GPIOParameters=GPIO_Label
PC10.GPIO_Label=ICM42688
PC10.Mode=Full_Duplex_Master
PC10.Signal=SPI3_SCK
PC11.Mode=Full_Duplex_Master
PC11.Signal=SPI3_MISO
PC12.Locked=true
PC12.Mode=Full_Duplex_Master
PC12.Signal=SPI3_MOSI
PC8.GPIOParameters=GPIO_Label
PC8.GPIO_Label=ICM42688INT
PC8.Locked=true
PC8.Signal=GPXTI8
PD12.Signal=S_TIM4_CH1
PD13.Signal=S_TIM4_CH2
PD14.GPIOParameters=PinState,GPIO_Label
PD14.GPIO_Label=PMW3901VCC
PD14.Locked=true
PD14.PinState=GPIO_PIN_SET
PD14.Signal=GPIO_Output
PD2.GPIOParameters=GPIO_Speed,PinState,GPIO_Label
PD2.GPIO_Label=ICM42688_NCS
PD2.GPIO_Speed=GPIO_SPEED_FREQ_VERY_HIGH
PD2.Locked=true
PD2.PinState=GPIO_PIN_SET
PD2.Signal=GPIO_Output
PE11.Mode=NSS_Signal_Hard_Input
PE11.Signal=SPI4_NSS
PE2.Mode=Full_Duplex_Slave
PE2.Signal=SPI4_SCK
PE3.GPIOParameters=GPIO_Label
PE3.GPIO_Label=ICM42688GND
PE3.Locked=true
PE3.Signal=GPIO_Output
PE4.GPIOParameters=PinState,GPIO_Label
PE4.GPIO_Label=ICM42688VCC
PE4.Locked=true
PE4.PinState=GPIO_PIN_SET
PE4.Signal=GPIO_Output
PE5.Mode=Full_Duplex_Slave
PE5.Signal=SPI4_MISO
PE6.Mode=Full_Duplex_Slave
PE6.Signal=SPI4_MOSI
PH0-OSC_IN\ (PH0).Mode=HSE-External-Oscillator
PH0-OSC_IN\ (PH0).Signal=RCC_OSC_IN
PH1-OSC_OUT\ (PH1).Mode=HSE-External-Oscillator
PH1-OSC_OUT\ (PH1).Signal=RCC_OSC_OUT
PinOutPanel.RotationAngle=0
ProjectManager.AskForMigrate=true
ProjectManager.BackupPrevious=false
ProjectManager.CompilerLinker=GCC
ProjectManager.CompilerOptimize=6
ProjectManager.ComputerToolchain=false
ProjectManager.CoupleFile=true
ProjectManager.CustomerFirmwarePackage=
ProjectManager.DefaultFWLocation=true
ProjectManager.DeletePrevious=true
ProjectManager.DeviceId=STM32H743VITx
ProjectManager.FirmwarePackage=STM32Cube FW_H7 V1.12.1
ProjectManager.FreePins=false
ProjectManager.FreePinsContext=
ProjectManager.HalAssertFull=false
ProjectManager.HeapSize=0x200
ProjectManager.KeepUserCode=true
ProjectManager.LastFirmware=true
ProjectManager.LibraryCopy=1
ProjectManager.MainLocation=Core/Src
ProjectManager.NoMain=false
ProjectManager.PreviousToolchain=STM32CubeIDE
ProjectManager.ProjectBuild=false
ProjectManager.ProjectFileName=MyDrone.ioc
ProjectManager.ProjectName=MyDrone
ProjectManager.ProjectStructure=
ProjectManager.RegisterCallBack=
ProjectManager.StackSize=0x400
ProjectManager.TargetToolchain=STM32CubeIDE
ProjectManager.ToolChainLocation=
ProjectManager.UAScriptAfterPath=
ProjectManager.UAScriptBeforePath=
ProjectManager.UnderRoot=true
ProjectManager.functionlistsort=1-SystemClock_Config-RCC-false-HAL-false,2-MX_GPIO_Init-GPIO-false-HAL-true,3-MX_DMA_Init-DMA-false-HAL-true,4-MX_SPI1_Init-SPI1-false-HAL-true,5-MX_SPI2_Init-SPI2-false-HAL-true,6-MX_SPI3_Init-SPI3-false-HAL-true,7-MX_TIM2_Init-TIM2-false-HAL-true,8-MX_TIM4_Init-TIM4-false-HAL-true,9-MX_I2C1_Init-I2C1-false-HAL-true,10-MX_SPI4_Init-SPI4-false-HAL-true,0-MX_CORTEX_M7_Init-CORTEX_M7-false-HAL-true
RCC.ADCFreq_Value=50390625
RCC.AHB12Freq_Value=240000000
RCC.AHB4Freq_Value=240000000
RCC.APB1Freq_Value=120000000
RCC.APB2Freq_Value=120000000
RCC.APB3Freq_Value=120000000
RCC.APB4Freq_Value=120000000
RCC.AXIClockFreq_Value=240000000
RCC.CECFreq_Value=32000
RCC.CKPERFreq_Value=64000000
RCC.CortexFreq_Value=480000000
RCC.CpuClockFreq_Value=480000000
RCC.D1CPREFreq_Value=480000000
RCC.D1PPRE=RCC_APB3_DIV2
RCC.D2PPRE1=RCC_APB1_DIV2
RCC.D2PPRE2=RCC_APB2_DIV2
RCC.D3PPRE=RCC_APB4_DIV2
RCC.DFSDMACLkFreq_Value=192000000
RCC.DFSDMFreq_Value=120000000
RCC.DIVM1=5
RCC.DIVN1=192
RCC.DIVP1Freq_Value=480000000
RCC.DIVP2Freq_Value=50390625
RCC.DIVP3Freq_Value=50390625
RCC.DIVQ1=5
RCC.DIVQ1Freq_Value=192000000
RCC.DIVQ2Freq_Value=50390625
RCC.DIVQ3Freq_Value=50390625
RCC.DIVR1Freq_Value=480000000
RCC.DIVR2Freq_Value=50390625
RCC.DIVR3Freq_Value=50390625
RCC.FDCANFreq_Value=192000000
RCC.FMCFreq_Value=240000000
RCC.FamilyName=M
RCC.HCLK3ClockFreq_Value=240000000
RCC.HCLKFreq_Value=240000000
RCC.HPRE=RCC_HCLK_DIV2
RCC.HRTIMFreq_Value=240000000
RCC.I2C123Freq_Value=120000000
RCC.I2C4Freq_Value=120000000
RCC.IPParameters=ADCFreq_Value,AHB12Freq_Value,AHB4Freq_Value,APB1Freq_Value,APB2Freq_Value,APB3Freq_Value,APB4Freq_Value,AXIClockFreq_Value,CECFreq_Value,CKPERFreq_Value,CortexFreq_Value,CpuClockFreq_Value,D1CPREFreq_Value,D1PPRE,D2PPRE1,D2PPRE2,D3PPRE,DFSDMACLkFreq_Value,DFSDMFreq_Value,DIVM1,DIVN1,DIVP1Freq_Value,DIVP2Freq_Value,DIVP3Freq_Value,DIVQ1,DIVQ1Freq_Value,DIVQ2Freq_Value,DIVQ3Freq_Value,DIVR1Freq_Value,DIVR2Freq_Value,DIVR3Freq_Value,FDCANFreq_Value,FMCFreq_Value,FamilyName,HCLK3ClockFreq_Value,HCLKFreq_Value,HPRE,HRTIMFreq_Value,I2C123Freq_Value,I2C4Freq_Value,LPTIM1Freq_Value,LPTIM2Freq_Value,LPTIM345Freq_Value,LPUART1Freq_Value,LTDCFreq_Value,MCO1PinFreq_Value,MCO2PinFreq_Value,PLLFRACN,PLLSourceVirtual,PWR_Regulator_Voltage_Scale,QSPIFreq_Value,RNGFreq_Value,RTCFreq_Value,SAI1Freq_Value,SAI23Freq_Value,SAI4AFreq_Value,SAI4BFreq_Value,SDMMCFreq_Value,SPDIFRXFreq_Value,SPI123Freq_Value,SPI45Freq_Value,SPI6Freq_Value,SWPMI1Freq_Value,SYSCLKFreq_VALUE,SYSCLKSource,Tim1OutputFreq_Value,Tim2OutputFreq_Value,TraceFreq_Value,USART16Freq_Value,USART234578Freq_Value,USBFreq_Value,VCO1OutputFreq_Value,VCO2OutputFreq_Value,VCO3OutputFreq_Value,VCOInput1Freq_Value,VCOInput2Freq_Value,VCOInput3Freq_Value
RCC.LPTIM1Freq_Value=120000000
RCC.LPTIM2Freq_Value=120000000
RCC.LPTIM345Freq_Value=120000000
RCC.LPUART1Freq_Value=120000000
RCC.LTDCFreq_Value=50390625
RCC.MCO1PinFreq_Value=64000000
RCC.MCO2PinFreq_Value=480000000
RCC.PLLFRACN=0
RCC.PLLSourceVirtual=RCC_PLLSOURCE_HSE
RCC.PWR_Regulator_Voltage_Scale=PWR_REGULATOR_VOLTAGE_SCALE0
RCC.QSPIFreq_Value=240000000
RCC.RNGFreq_Value=48000000
RCC.RTCFreq_Value=32000
RCC.SAI1Freq_Value=192000000
RCC.SAI23Freq_Value=192000000
RCC.SAI4AFreq_Value=192000000
RCC.SAI4BFreq_Value=192000000
RCC.SDMMCFreq_Value=192000000
RCC.SPDIFRXFreq_Value=192000000
RCC.SPI123Freq_Value=192000000
RCC.SPI45Freq_Value=120000000
RCC.SPI6Freq_Value=120000000
RCC.SWPMI1Freq_Value=120000000
RCC.SYSCLKFreq_VALUE=480000000
RCC.SYSCLKSource=RCC_SYSCLKSOURCE_PLLCLK
RCC.Tim1OutputFreq_Value=240000000
RCC.Tim2OutputFreq_Value=240000000
RCC.TraceFreq_Value=480000000
RCC.USART16Freq_Value=120000000
RCC.USART234578Freq_Value=120000000
RCC.USBFreq_Value=192000000
RCC.VCO1OutputFreq_Value=960000000
RCC.VCO2OutputFreq_Value=100781250
RCC.VCO3OutputFreq_Value=100781250
RCC.VCOInput1Freq_Value=5000000
RCC.VCOInput2Freq_Value=781250
RCC.VCOInput3Freq_Value=781250
SH.GPXTI8.0=GPIO_EXTI8
SH.GPXTI8.ConfNb=1
SH.S_TIM2_CH1_ETR.0=TIM2_CH1,PWM Generation1 CH1
SH.S_TIM2_CH1_ETR.ConfNb=1
SH.S_TIM2_CH2.0=TIM2_CH2,PWM Generation2 CH2
SH.S_TIM2_CH2.ConfNb=1
SH.S_TIM4_CH1.0=TIM4_CH1,PWM Generation1 CH1
SH.S_TIM4_CH1.ConfNb=1
SH.S_TIM4_CH2.0=TIM4_CH2,PWM Generation2 CH2
SH.S_TIM4_CH2.ConfNb=1
SPI1.BaudRatePrescaler=SPI_BAUDRATEPRESCALER_32
SPI1.CLKPhase=SPI_PHASE_2EDGE
SPI1.CLKPolarity=SPI_POLARITY_HIGH
SPI1.CalculateBaudRate=6.0 MBits/s
SPI1.DataSize=SPI_DATASIZE_8BIT
SPI1.Direction=SPI_DIRECTION_2LINES
SPI1.IPParameters=VirtualType,Mode,Direction,BaudRatePrescaler,CalculateBaudRate,CLKPolarity,CLKPhase,DataSize
SPI1.Mode=SPI_MODE_MASTER
SPI1.VirtualType=VM_MASTER
SPI2.BaudRatePrescaler=SPI_BAUDRATEPRESCALER_128
SPI2.CLKPhase=SPI_PHASE_2EDGE
SPI2.CLKPolarity=SPI_POLARITY_HIGH
SPI2.CalculateBaudRate=1.5 MBits/s
SPI2.DataSize=SPI_DATASIZE_8BIT
SPI2.Direction=SPI_DIRECTION_2LINES
SPI2.IPParameters=VirtualType,Mode,Direction,BaudRatePrescaler,CalculateBaudRate,DataSize,CLKPolarity,CLKPhase
SPI2.Mode=SPI_MODE_MASTER
SPI2.VirtualType=VM_MASTER
SPI3.BaudRatePrescaler=SPI_BAUDRATEPRESCALER_16
SPI3.CLKPhase=SPI_PHASE_2EDGE
SPI3.CLKPolarity=SPI_POLARITY_HIGH
SPI3.CalculateBaudRate=12.0 MBits/s
SPI3.DataSize=SPI_DATASIZE_8BIT
SPI3.Direction=SPI_DIRECTION_2LINES
SPI3.IPParameters=VirtualType,Mode,Direction,BaudRatePrescaler,CalculateBaudRate,DataSize,CLKPolarity,CLKPhase
SPI3.Mode=SPI_MODE_MASTER
SPI3.VirtualType=VM_MASTER
SPI4.DataSize=SPI_DATASIZE_8BIT
SPI4.Direction=SPI_DIRECTION_2LINES
SPI4.IPParameters=VirtualType,Mode,Direction,DataSize,VirtualNSS
SPI4.Mode=SPI_MODE_SLAVE
SPI4.VirtualNSS=VM_NSSHARD
SPI4.VirtualType=VM_SLAVE
TIM2.Channel-PWM\ Generation1\ CH1=TIM_CHANNEL_1
TIM2.Channel-PWM\ Generation2\ CH2=TIM_CHANNEL_2
TIM2.IPParameters=Channel-PWM Generation1 CH1,Channel-PWM Generation2 CH2,Prescaler,Period,Pulse-PWM Generation1 CH1,Pulse-PWM Generation2 CH2
TIM2.Period=20000
TIM2.Prescaler=240-1
TIM2.Pulse-PWM\ Generation1\ CH1=1500
TIM2.Pulse-PWM\ Generation2\ CH2=1500
TIM4.Channel-PWM\ Generation1\ CH1=TIM_CHANNEL_1
TIM4.Channel-PWM\ Generation2\ CH2=TIM_CHANNEL_2
TIM4.IPParameters=Channel-PWM Generation1 CH1,Channel-PWM Generation2 CH2,Prescaler,Period,Pulse-PWM Generation1 CH1,Pulse-PWM Generation2 CH2
TIM4.Period=20000
TIM4.Prescaler=240-1
TIM4.Pulse-PWM\ Generation1\ CH1=1500
TIM4.Pulse-PWM\ Generation2\ CH2=1500
VP_FREERTOS_VS_CMSIS_V2.Mode=CMSIS_V2
VP_FREERTOS_VS_CMSIS_V2.Signal=FREERTOS_VS_CMSIS_V2
VP_MEMORYMAP_VS_MEMORYMAP.Mode=CurAppReg
VP_MEMORYMAP_VS_MEMORYMAP.Signal=MEMORYMAP_VS_MEMORYMAP
VP_SYS_VS_tim7.Mode=TIM7
VP_SYS_VS_tim7.Signal=SYS_VS_tim7
board=custom
rtos.0.ip=FREERTOS
</file>

<file path="MyCore/Inc/TaskConfig.hpp">
#pragma once
#include "main.h"
#ifdef __cplusplus
extern "C" {
#endif

void Bridge_SystemSensors_Init(void); //

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus

#include "FreeRTOS.h"
#include "task.h"
#include "spi.h"
#include "i2c.h"
#include "QueueConfig.hpp"
#include "Sensors.hpp"
#include "DataStructConfig.hpp"
#include "Mydelay.hpp"
#define ICM42688_Buffer_Length 32
#define MMC5983_Buffer_Length  32
#define DPS310_Buffer_Length   32
#define PMW3901_Buffer_Length  32

extern SPIBus spi1_bus;
extern SPIBus spi2_bus;
extern SPIBus spi3_bus;
extern I2CBus i2c1_bus;

extern AXI_SRAM uint8_t ICM42688RxBuffer[ICM42688_Buffer_Length];
extern AXI_SRAM uint8_t ICM42688TxBuffer[ICM42688_Buffer_Length];
extern AXI_SRAM uint8_t MMC5983RxBuffer[MMC5983_Buffer_Length];
extern AXI_SRAM uint8_t MMC5983TxBuffer[MMC5983_Buffer_Length];
extern AXI_SRAM uint8_t DPS310RxBuffer[DPS310_Buffer_Length];
extern AXI_SRAM uint8_t DPS310TxBuffer[DPS310_Buffer_Length];
extern AXI_SRAM uint8_t PMW3901RxBuffer[PMW3901_Buffer_Length];
extern AXI_SRAM uint8_t PMW3901TxBuffer[PMW3901_Buffer_Length];

extern ICM42688 icm42688_sensor;
extern MMC5983 mmc5983_sensor;
extern DPS310 dps310_sensor;
extern PMW3901 pmw3901_sensor;

extern TaskHandle_t ICM42688ReadTaskHandle;
extern TaskHandle_t ICM42688ProcessTaskHandle;
extern TaskHandle_t MMC5983ReadTaskHandle;
extern TaskHandle_t MMC5983ProcessTaskHandle;
extern TaskHandle_t DPS310ReadTaskHandle;
extern TaskHandle_t DPS310ProcessTaskHandle;
extern TaskHandle_t PMW3901ReadTaskHandle;
extern TaskHandle_t PMW3901ProcessTaskHandle;

void SystemSensors_Init();                     // 初始化函数，负责创建初始化任务
void SystemSensors_Init_Entry(void *argument); // 初始化任务，负责对总线和传感器进行初始化并创建读取和数据处理任务,以及姿态解算和控制任务
void DPS310ReadTaskEntry(void *argument);      // DPS310 读取任务入口函数
void DPS310ProcessTaskEntry(void *argument);   // DPS310 数据处理任务入口函数
void PMW3901ReadTaskEntry(void *argument);     // PMW3901 读取任务入口函数
void PMW3901ProcessTaskEntry(void *argument);  // PMW3901 数据处理任务入口函数
void ICM42688ReadTaskEntry(void *argument);    // ICM42688 读取任务入口函数
void ICM42688ProcessTaskEntry(void *argument); // ICM42688 数据处理任务入口函数
void MMC5983ReadTaskEntry(void *argument);     // MMC5983 读取任务入口函数
void MMC5983ProcessTaskEntry(void *argument);  // MMC5983 数据处理任务入口函数

#endif
</file>

<file path="MyCore/Src/Callback.cpp">
#include "TaskConfig.hpp"
#include "main.h"
extern "C" {

void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
{
    if (hspi == &hspi1) {
        spi1_bus.irq_handler();
    } else if (hspi == &hspi2) {
        spi2_bus.irq_handler();
    } else if (hspi == &hspi3) {
        spi3_bus.irq_handler();
    }
}

void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
    if (hi2c == &hi2c1) {
        i2c1_bus.irq_handler();
    }
}

void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
    if (hi2c == &hi2c1) {
        i2c1_bus.irq_handler();
    }
}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
    if (GPIO_Pin == GPIO_PIN_8) {
        if (ICM42688ReadTaskHandle != NULL) {
            BaseType_t xWoken = pdFALSE;
            vTaskNotifyGiveFromISR(ICM42688ReadTaskHandle, &xWoken);
            portYIELD_FROM_ISR(xWoken);
        }
    }
}

void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
    if (hi2c == &hi2c1) {
        i2c1_bus.irq_handler();
    }
}

void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
{
    if (hspi == &hspi1) {
        spi1_bus.irq_handler();
    } else if (hspi == &hspi2) {
        spi2_bus.irq_handler();
    } else if (hspi == &hspi3) {
        spi3_bus.irq_handler();
    }
}
} // extern "C" 结束
</file>

<file path="MyCore/Src/Sensors.cpp">
#include "Sensors.hpp"
#include "QueueConfig.hpp"
#include "DebugMonitor.hpp"
#include "Mydelay.hpp"
DPS310::DPS310(SensorID_e id, BusDriver *bus, uint8_t *tx, uint8_t *rx,
               GPIO_TypeDef *cs_port, uint16_t cs_pin)
    : SensorBase(id, bus, tx, rx)
{
    _config.spi.port          = cs_port;
    _config.spi.pin           = cs_pin;
    _config.spi.read_sets_bit = true; // 标准模式: 读置1/写清0
}
void DPS310::init_regs()
{
    write_reg(DPS310_RESET, 0x09);
    vTaskDelay(pdMS_TO_TICKS(40));

    uint8_t ready = 0;
    while ((ready & 0x80) == 0) {
        read_regs(DPS310_MEAS_CFG, 1);
        vTaskDelay(pdMS_TO_TICKS(10));
        ready = _rx_buf[1]; // SPI 必须跳过第 0 字节(Dummy)
    }
    read_regs(DPS310_COEF_SRCE, 1);
    vTaskDelay(pdMS_TO_TICKS(10));
    uint8_t coef_srce = _rx_buf[1]; // 必须是 _rx_buf[1]
    bool use_ext_temp = (coef_srce & 0x80) != 0;

    // 读取系数并解析
    read_regs(DPS310_COEF_START, 18);
    vTaskDelay(pdMS_TO_TICKS(20));
    parse_coeffs();

    // 3. 【新增】解决 Infineon 芯片温度读取异常的官方隐藏序列 (Erratum)
    write_reg(0x0E, 0xA5);
    write_reg(0x0F, 0x96);
    write_reg(0x62, 0x02);
    write_reg(0x0E, 0x00);
    write_reg(0x0F, 0x00);
    vTaskDelay(pdMS_TO_TICKS(10));

    // 后续的 PRS_CFG 等保持你的原样即可
    uint8_t prs_cfg = (0x05 << 4) | 0x04;
    m_kp            = 253952.0f;
    write_reg(DPS310_PRS_CFG, prs_cfg);
    vTaskDelay(pdMS_TO_TICKS(10));

    uint8_t tmp_cfg = (0x05 << 4) | 0x01;
    if (use_ext_temp) tmp_cfg |= 0x80;
    m_kt = 1572864.0f;
    write_reg(DPS310_TMP_CFG, tmp_cfg);
    vTaskDelay(pdMS_TO_TICKS(10));

    uint8_t cfg_reg = (1 << 2) | (1 << 4);
    write_reg(DPS310_CFG_REG, cfg_reg);
    vTaskDelay(pdMS_TO_TICKS(10));

    write_reg(DPS310_MEAS_CFG, 0x07);
    vTaskDelay(pdMS_TO_TICKS(10));
}
bool DPS310::read_data()
{
    return read_regs(DPS310_PRS_B2, 6);
}
void DPS310::process_in_task()
{
    Sensor_Packet_t packet;
    // 1. 解析原始数据 (24-bit 补码)
    int32_t raw_p = get_twos_complement(
        ((uint32_t)_rx_buf[1] << 16) | ((uint32_t)_rx_buf[2] << 8) | _rx_buf[3], 24);

    int32_t raw_t = get_twos_complement(
        ((uint32_t)_rx_buf[4] << 16) | ((uint32_t)_rx_buf[5] << 8) | _rx_buf[6], 24);

    if (raw_p == 0 || raw_p == 0x800000) {
        DBG_MON_ERROR(_id);
        return;
    }

    // 2. 执行补偿计算 (转为 float)
    float pressure    = compensate_pressure(raw_p, raw_t);
    float temperature = compensate_temperature(raw_t);

    packet.tag                     = _id;
    packet.timestamp               = Get_System_Time_ns(); // 或者使用微秒级时间戳
    packet.data.DPS310.pressure    = pressure;             // 单位: Pa
    packet.data.DPS310.temperature = temperature;          // 单位: Celsius

    // 4. 推送到队列 (非阻塞发送，保持实时性)
    if (SensorsDataHub != NULL) {
        xQueueSend(SensorsDataHub, &packet, 0);
        DBG_MON_SUCCESS(_id, &packet);
    }
}
void DPS310::parse_coeffs()
{
    uint8_t *b   = &_rx_buf[1];
    m_coeffs.c0  = get_twos_complement((b[0] << 4) | (b[1] >> 4), 12);
    m_coeffs.c1  = get_twos_complement(((b[1] & 0x0F) << 8) | b[2], 12);
    m_coeffs.c00 = get_twos_complement(((uint32_t)b[3] << 12) | ((uint32_t)b[4] << 4) | (b[5] >> 4), 20);
    m_coeffs.c10 = get_twos_complement(((uint32_t)(b[5] & 0x0F) << 16) | ((uint32_t)b[6] << 8) | b[7], 20);
    m_coeffs.c01 = get_twos_complement((b[8] << 8) | b[9], 16);
    m_coeffs.c11 = get_twos_complement((b[10] << 8) | b[11], 16);
    m_coeffs.c20 = get_twos_complement((b[12] << 8) | b[13], 16);
    m_coeffs.c21 = get_twos_complement((b[14] << 8) | b[15], 16);
    m_coeffs.c30 = get_twos_complement((b[16] << 8) | b[17], 16);
}

int32_t DPS310::get_twos_complement(uint32_t val, uint8_t length)
{
    if (val & ((uint32_t)1 << (length - 1))) {
        return (int32_t)(val - ((uint32_t)1 << length));
    }
    return (int32_t)val;
}
// 压力补偿公式 [cite: 358]
float DPS310::compensate_pressure(int32_t raw_p, int32_t raw_t)
{
    float p_sc = (float)raw_p / m_kp;
    float t_sc = (float)raw_t / m_kt;

    // Pcomp = c00 + P_sc*(c10 + P_sc*(c20 + P_sc*c30)) + T_sc*c01 + T_sc*P_sc*(c11 + P_sc*c21)
    float term_p  = m_coeffs.c10 + p_sc * (m_coeffs.c20 + p_sc * m_coeffs.c30);
    float term_t  = t_sc * m_coeffs.c01;
    float term_tp = t_sc * p_sc * (m_coeffs.c11 + p_sc * m_coeffs.c21);

    return m_coeffs.c00 + p_sc * term_p + term_t + term_tp;
}

// 温度补偿公式 [cite: 377]
float DPS310::compensate_temperature(int32_t raw_t)
{
    float t_sc = (float)raw_t / m_kt;
    // Tcomp = c0 * 0.5 + c1 * T_sc
    return (float)m_coeffs.c0 * 0.5f + (float)m_coeffs.c1 * t_sc;
}

// 第一阶段序列 (在 10ms 延时之前)
const PMW3901::RegCfg PMW3901::opt_seq_part1[] = {
    {0x7F, 0x00}, {0x61, 0xAD}, {0x7F, 0x03}, {0x40, 0x00}, {0x7F, 0x05}, {0x41, 0xB3}, {0x43, 0xF1}, {0x45, 0x14}, {0x5B, 0x32}, {0x5F, 0x34}, {0x7B, 0x08}, {0x7F, 0x06}, {0x44, 0x1B}, {0x40, 0xBF}, {0x4E, 0x3F}, {0x7F, 0x08}, {0x65, 0x20}, {0x6A, 0x18}, {0x7F, 0x09}, {0x4F, 0xAF}, {0x5F, 0x40}, {0x48, 0x80}, {0x49, 0x80}, {0x57, 0x77}, {0x60, 0x78}, {0x61, 0x78}, {0x62, 0x08}, {0x63, 0x50}, {0x7F, 0x0A}, {0x45, 0x60}, {0x7F, 0x00}, {0x4D, 0x11}, {0x55, 0x80}, {0x74, 0x1F}, {0x75, 0x1F}, {0x4A, 0x78}, {0x4B, 0x78}, {0x44, 0x08}, {0x45, 0x50}, {0x64, 0xFF}, {0x65, 0x1F}, {0x7F, 0x14}, {0x65, 0x67}, {0x66, 0x08}, {0x63, 0x70}, {0x7F, 0x15}, {0x48, 0x48}, {0x7F, 0x07}, {0x41, 0x0D}, {0x43, 0x14}, {0x4B, 0x0E}, {0x45, 0x0F}, {0x44, 0x42}, {0x4C, 0x80}, {0x7F, 0x10}, {0x5B, 0x02}, {0x7F, 0x07}, {0x40, 0x41}, {0x70, 0x00}};

// 第二阶段序列 (在 10ms 延时之后)
const PMW3901::RegCfg PMW3901::opt_seq_part2[] = {
    {0x32, 0x44}, {0x7F, 0x07}, {0x40, 0x40}, {0x7F, 0x06}, {0x62, 0xF0}, {0x63, 0x00}, {0x7F, 0x0D}, {0x48, 0xC0}, {0x6F, 0xD5}, {0x7F, 0x00}, {0x5B, 0xA0}, {0x4E, 0xA8}, {0x5A, 0x50}, {0x40, 0x80}};

// =================================================================================
// 2. 函数实现
// =================================================================================

PMW3901::PMW3901(SensorID_e id, BusDriver *bus, uint8_t *tx, uint8_t *rx,
                 GPIO_TypeDef *cs_port, uint16_t cs_pin)
    : SensorBase(id, bus, tx, rx)
{
    _config.spi.port          = cs_port;
    _config.spi.pin           = cs_pin;
    _config.spi.read_sets_bit = false;
}

void PMW3901::write_block(const RegCfg *seq, size_t len)
{
    for (size_t i = 0; i < len; i++) {
        // 直接写入，底层驱动会根据 read_sets_bit=false 自动处理 MSB
        write_reg(seq[i].addr, seq[i].val);
    }
}

void PMW3901::init_regs()
{
    vTaskDelay(pdMS_TO_TICKS(5)); // 等待复位完成

    // 读取 Product ID (0x00) 验证 SPI 通讯 (应返回 0x49)
    read_regs(PMW3901_REG_ID, 1);

    // 读取寄存器 0x02-0x06 一次 (Datasheet 要求初始化必须读一次)
    read_regs(PMW3901_REG_MOTION, 5);

    write_reg(0x7F, 0x00);
    write_reg(0x55, 0x01);
    write_reg(0x50, 0x07);
    write_reg(0x7F, 0x0E);
    write_reg(0x43, 0x10);

    // 检查 0x67 位 7 (Datasheet 分支逻辑)
    read_regs(0x67, 1);
    if (_rx_buf[1] & 0x80) {
        write_reg(0x48, 0x04);
    } else {
        write_reg(0x48, 0x02);
    }

    write_reg(0x7F, 0x00);
    write_reg(0x51, 0x7B);
    write_reg(0x50, 0x00);
    write_reg(0x55, 0x00);
    write_reg(0x7F, 0x0E);

    // 检查 0x73 (Datasheet 分支逻辑)
    read_regs(0x73, 1);
    if (_rx_buf[1] == 0x00) {
        // C1/C2 计算逻辑
        read_regs(0x70, 1);
        uint8_t c1 = _rx_buf[1];
        if (c1 <= 28)
            c1 += 14;
        else
            c1 += 11;
        if (c1 > 0x3F) c1 = 0x3F; // Cap at 0x3F

        read_regs(0x71, 1);
        uint8_t c2 = _rx_buf[1];
        c2         = (c2 * 45) / 100;

        write_reg(0x7F, 0x00);
        write_reg(0x61, 0xAD);
        write_reg(0x51, 0x70);
        write_reg(0x7F, 0x0E);
        write_reg(0x70, c1);
        write_reg(0x71, c2);
    }

    // --- 3. 性能优化序列 (静态部分 1) ---
    write_block(opt_seq_part1, sizeof(opt_seq_part1) / sizeof(RegCfg));

    vTaskDelay(pdMS_TO_TICKS(10));

    // --- 4. 性能优化序列 (静态部分 2) ---
    write_block(opt_seq_part2, sizeof(opt_seq_part2) / sizeof(RegCfg));

    // 初始化完成
}

bool PMW3901::read_data()
{
    return read_regs(PMW3901_REG_MOTION_BURST, 12);
}

void PMW3901::process_in_task()
{
    Sensor_Packet_t packet;
    uint8_t *p                  = &_rx_buf[1];
    int16_t raw_dx              = (int16_t)(p[2] | (p[3] << 8));
    int16_t raw_dy              = (int16_t)(p[4] | (p[5] << 8));
    uint8_t squal               = p[6];
    packet.tag                  = _id;
    packet.timestamp            = Get_System_Time_ns();
    packet.data.PMW3901.delta_x = (float)raw_dx;
    packet.data.PMW3901.delta_y = (float)raw_dy;
    packet.data.PMW3901.squal   = (float)squal; // 表面纹理质量
    if (SensorsDataHub != NULL) {
        xQueueSend(SensorsDataHub, &packet, 0);
        DBG_MON_SUCCESS(_id, &packet);
    }
}

ICM42688::ICM42688(SensorID_e id, BusDriver *bus, uint8_t *tx, uint8_t *rx,
                   GPIO_TypeDef *cs_port, uint16_t cs_pin)
    : SensorBase(id, bus, tx, rx)
{
    _config.spi.port          = cs_port;
    _config.spi.pin           = cs_pin;
    _config.spi.read_sets_bit = true; // 标准模式: 读置1/写清0
}
void ICM42688::init_regs()
{
    write_reg(ICM42688_REG_BANK_SEL_ADDR, 0x00);
    vTaskDelay(pdMS_TO_TICKS(40));

    write_reg(ICM42688_DEVICE_CONFIG_ADDR, 0x01); // 触发软复位
    vTaskDelay(pdMS_TO_TICKS(40));

    // 3. 返回 Bank 0 进行主配置
    write_reg(ICM42688_REG_BANK_SEL_ADDR, 0x00); // 切换回 Bank 0
    vTaskDelay(pdMS_TO_TICKS(40));

    // 4. 配置 ODR 和量程
    // 陀螺仪: 2000dps, 1kHz (0x01)
    write_reg(ICM42688_GYRO_CONFIG0_ADDR, 0x06);
    vTaskDelay(pdMS_TO_TICKS(40));

    // 加速计: 16g, 1kHz (0x01)
    write_reg(ICM42688_ACCEL_CONFIG0_ADDR, 0x06);
    vTaskDelay(pdMS_TO_TICKS(40));

    write_reg(ICM42688_INT_CONFIG_ADDR, 0x03);
    vTaskDelay(pdMS_TO_TICKS(40));

    write_reg(ICM42688_INT_CONFIG1_ADDR, 0x60);
    vTaskDelay(pdMS_TO_TICKS(40));

    // 5. 配置中断引脚：将 UI Data Ready 路由至 INT1
    write_reg(ICM42688_INT_SOURCE0_ADDR, 0x08);
    vTaskDelay(pdMS_TO_TICKS(40));

    // 6. 启用 20-bit 高分辨率模式及传感器 FIFO 写入
    write_reg(ICM42688_FIFO_CONFIG1_ADDR, 0x17);
    vTaskDelay(pdMS_TO_TICKS(40));

    write_reg(ICM42688_FIFO_CONFIG_ADDR, 0x40);
    vTaskDelay(pdMS_TO_TICKS(40));

    // 7. 开启 6 轴低噪声模式 (LN Mode)
    write_reg(ICM42688_PWR_MGMTO_ADDR, 0x0F);
    vTaskDelay(pdMS_TO_TICKS(40));

    // 启动通常需要 30ms，等待传感器稳定
}
bool ICM42688::read_fifo()
{
    // 在 EXTI 触发的 FreeRTOS 任务中调用此函数
    return read_regs(ICM42688_FIFO_DATA_ADDR, 20);
}

void ICM42688::process_in_task()
{
    // _rx_buf[0] 是 SPI 指令回显，真实数据从 _rx_buf[1] 开始 [cite: 1363, 1364]
    uint8_t *p = &_rx_buf[1];

    // 检查 FIFO Header (Packet 4 结构)
    // 如果 Bit 7 为 1，代表 FIFO 为空 [cite: 923]
    if (p[0] & 0x80) {
        DBG_MON_ERROR(_id);
        return;
    }

    Sensor_Packet_t packet;

    /* --- 20-bit 数据解析与物理量转换 --- */
    int32_t raw_ax = parse_20bit(p[1], p[2], p[17], 4);
    int32_t raw_ay = parse_20bit(p[3], p[4], p[17], 0);
    int32_t raw_az = parse_20bit(p[5], p[6], p[18], 4);

    int32_t raw_gx = parse_20bit(p[7], p[8], p[18], 0);
    int32_t raw_gy = parse_20bit(p[9], p[10], p[19], 4);
    int32_t raw_gz = parse_20bit(p[11], p[12], p[19], 0);

    int16_t raw_temp = (int16_t)((p[13] << 8) | p[14]);

    /* 物理量转换逻辑 */
    packet.tag       = _id;
    packet.timestamp = Get_System_Time_ns(); // 使用 DWT 周期计数器作为高精度时间戳
    // 加速度计：20-bit 模式下，±16g 量程的灵敏度为 8192 LSB/g
    packet.data.ICM42688.acc[0] = (float)raw_ax / 32768.0f;
    packet.data.ICM42688.acc[1] = (float)raw_ay / 32768.0f;
    packet.data.ICM42688.acc[2] = (float)raw_az / 32768.0f;

    // 陀螺仪：16-bit 时为 131 LSB/dps，20-bit 模式数据左移了 4 位，故灵敏度为 131 * 16 = 2096 LSB/dps [cite: 881, 165]
    packet.data.ICM42688.gyro[0] = (float)raw_gx / 262.4f;
    packet.data.ICM42688.gyro[1] = (float)raw_gy / 262.4f;
    packet.data.ICM42688.gyro[2] = (float)raw_gz / 262.4f;

    // 温度：公式为 (TEMP_DATA / 132.48) + 25

    packet.data.ICM42688.temp_raw = ((float)raw_temp / 132.48f) + 25.0f;

    // 发送到传感器数据总线
    if (SensorsDataHub != NULL) {
        xQueueSend(SensorsDataHub, &packet, 0);
        DBG_MON_SUCCESS(_id, &packet);
    }
}

int32_t ICM42688::parse_20bit(uint8_t h, uint8_t l, uint8_t ext, uint8_t shift)
{
    // 1. 拼接数据：[19:12]高位 | [11:4]中位 | [3:0]扩展位
    // 逻辑：将高位左移 12 位，中位左移 4 位，并提取扩展字节中对应的 4 位低位
    int32_t val = (int32_t)((h << 12) | (l << 4) | ((ext >> shift) & 0x0F));

    // 2. 符号扩展 (Sign Extension)
    // ICM42688 的 20 位补码符号位在第 19 位 (即 0x80000)
    // 如果该位为 1，说明是负数，需要将 32 位整型的高 12 位全部补 1
    if (val & 0x80000) {
        val |= 0xFFF00000;
    }

    return val;
}

MMC5983::MMC5983(SensorID_e id, BusDriver *bus, uint8_t *tx, uint8_t *rx, uint16_t i2c_addr)
    : SensorBase(id, bus, tx, rx)
{
    // 配置 I2C 地址
    // Datasheet Page 9: 7-bit address 0110000 (0x30)
    // HAL库需要左移1位: 0x30 << 1 = 0x60
    _config.i2c.addr = (i2c_addr << 1);
}

void MMC5983::init_regs()
{
    write_reg(MMC5983_REG_CTRL1, 0x80); // SW Reset 软件复位
    vTaskDelay(pdMS_TO_TICKS(15));

    write_reg(MMC5983_REG_CTRL3, 0x00);
    vTaskDelay(pdMS_TO_TICKS(5));

    write_reg(MMC5983_REG_CTRL0, 0x08); // SET
    vTaskDelay(pdMS_TO_TICKS(10));
}
bool MMC5983::read_mag()
{
    if (!write_reg(MMC5983_REG_CTRL0, 0x01)) {
        return false;
    }//触发单次测量

    vTaskDelay(pdMS_TO_TICKS(10));

    return read_regs(MMC5983_REG_XOUT0, 7);
}
void MMC5983::process_in_task()
{

    uint32_t x_raw = ((uint32_t)_rx_buf[0] << 10) |
                     ((uint32_t)_rx_buf[1] << 2) |
                     ((_rx_buf[6] & 0xC0) >> 6);

    uint32_t y_raw = ((uint32_t)_rx_buf[2] << 10) |
                     ((uint32_t)_rx_buf[3] << 2) |
                     ((_rx_buf[6] & 0x30) >> 4);

    uint32_t z_raw = ((uint32_t)_rx_buf[4] << 10) |
                     ((uint32_t)_rx_buf[5] << 2) |
                     ((_rx_buf[6] & 0x0C) >> 2);

    // 注意：这里必须转为带符号浮点数
    float x_gauss = ((float)x_raw - 131072.0f) / 16384.0f;
    float y_gauss = ((float)y_raw - 131072.0f) / 16384.0f;
    float z_gauss = ((float)z_raw - 131072.0f) / 16384.0f;

    // 3. 数据打包 (填充父类定义的结构体)
    Sensor_Packet_t packet;
    packet.tag = _id;
    // 获取当前时间戳 (假设 FreeRTOS tick)
    packet.timestamp = Get_System_Time_ns();

    packet.data.MMC5983.mag[0] = x_gauss;
    packet.data.MMC5983.mag[1] = y_gauss;
    packet.data.MMC5983.mag[2] = z_gauss;
    Mag_Gauss_x                = x_gauss;
    Mag_Gauss_y                = y_gauss;
    Mag_Gauss_z                = z_gauss;

    if (SensorsDataHub != NULL) {
        xQueueSend(SensorsDataHub, &packet, 0);
        DBG_MON_SUCCESS(_id, &packet);
    }
}
</file>

<file path="MyCore/Inc/DataStructConfig.hpp">
#pragma once
#include "main.h"
#include "FreeRTOS.h"
#include "semphr.h"
#include "cmsis_os2.h"
#include "string.h"
#include "stdbool.h"

#define AXI_SRAM  __attribute__((aligned(32)))
#define DTCM_DATA __attribute__((section(".dtcm_data"))) alignas(4)
// 传感器 ID 枚举
typedef enum {
    SENSOR_ID_NONE = 0,
    SENSOR_ID_DPS310,
    SENSOR_ID_PMW3901,
    SENSOR_ID_ICM42688,
    SENSOR_ID_MMC5983,
    SENSOR_COUNT // 用于数组计数
} SensorID_e;

// 传感器数据包结构 (推送到队列的数据)
typedef struct {
    SensorID_e tag;
    uint64_t timestamp;
    union {
        struct {
            float pressure;
            float temperature;
        } DPS310;
        struct {
            float delta_x; // X轴相对位移计数值
            float delta_y; // Y轴相对位移计数值
            float squal;   // 表面质量指标 (用于数据有效性过滤)
        } PMW3901;
        struct {
            float acc[3];  // 20-bit 扩展后
            float gyro[3]; // 20-bit 扩展后
            float temp_raw;
        } ICM42688;
        struct {
            float mag[3];
        } MMC5983;
    } data;
} Sensor_Packet_t;
// --- 补充在 MyCore/Inc/DataStructConfig.hpp 尾部 ---

// 飞控 15维 ESKF 解算输出状态 (供后续 PID 姿态与位置控制器使用)
typedef struct {
    uint64_t timestamp;
    float roll, pitch, yaw; // 欧拉角 (rad 弧度)
    float q[4];             // 四元数: w, x, y, z
    float position[3];      // NED位置 (m): 北、东、下 (注意：向下为正)
    float velocity[3];      // NED速度 (m/s): 北、东、下
    float accel_bias[3];    // 实时收敛的加速度计零偏 (m/s^2)
    float gyro_bias[3];     // 实时收敛的陀螺仪零偏 (rad/s)
} VehicleState_t;

struct DeviceConfig {
    union {
        struct {
            GPIO_TypeDef *port;
            uint16_t pin;
            bool read_sets_bit; // 新增标志: true = 读置1/写清0 (标准); false = 读清0/写置1 (PMW3901)
        } spi;
        struct {
            uint16_t addr;
        } i2c;
    };
};

class SensorBase; // 前向声明

class BusDriver
{
public:
    SemaphoreHandle_t lock;
    SensorBase *active_device;
    bool is_read_op;
    BusDriver();
    virtual void init(); // 创建互斥量

    // 纯虚函数：统一传输接口
    virtual bool transfer(const DeviceConfig &cfg, uint8_t reg,
                          uint8_t *tx, uint8_t *rx,
                          uint16_t len, bool is_read) = 0;

    // 纯虚函数：中断处理
    virtual void irq_handler() = 0;
    virtual ~BusDriver()
    {
    }
};

// ==========================================
// 传感器基类
// ==========================================
class SensorBase
{
protected:
    // 家族遗产：子类直接使用
    SensorID_e _id;
    BusDriver *_bus;
    uint8_t *_tx_buf;
    uint8_t *_rx_buf;
    DeviceConfig _config;
    TaskHandle_t _data_task_handle = nullptr; // 存储对应的处理任务句柄

public:
    SensorBase(SensorID_e id, BusDriver *bus, uint8_t *tx, uint8_t *rx);
    virtual ~SensorBase()
    {
    }

    bool read_regs(uint8_t reg, uint16_t len);
    bool write_reg(uint8_t reg, uint8_t val);
    bool write_regs(uint8_t reg, uint8_t *data, uint16_t len);
    void set_task_handle(TaskHandle_t handle)
    {
        _data_task_handle = handle;
    } // 绑定唤醒任务句柄
    virtual void notify_task_ISR(); //
    virtual void process_in_task() = 0;
};

// ==========================================
// 具体总线类声明
// ==========================================
class SPIBus : public BusDriver
{
private:
    SPI_HandleTypeDef *hspi;
    DeviceConfig current_cfg; // 中断里用
public:
    SPIBus(SPI_HandleTypeDef *h);
    bool transfer(const DeviceConfig &cfg, uint8_t reg, uint8_t *tx, uint8_t *rx, uint16_t len, bool is_read) override;
    void irq_handler() override;
};

class I2CBus : public BusDriver
{
private:
    I2C_HandleTypeDef *hi2c;

public:
    I2CBus(I2C_HandleTypeDef *h);
    bool transfer(const DeviceConfig &cfg, uint8_t reg, uint8_t *tx, uint8_t *rx, uint16_t len, bool is_read) override;
    void irq_handler() override;
};
</file>

<file path="MyCore/Src/TaskConfig.cpp">
#include "TaskConfig.hpp"
#include "DebugMonitor.hpp"
#include "AttitudeESKF.hpp"
SPIBus spi1_bus(&hspi1);
SPIBus spi2_bus(&hspi2);
SPIBus spi3_bus(&hspi3);
I2CBus i2c1_bus(&hi2c1);

AXI_SRAM uint8_t ICM42688RxBuffer[ICM42688_Buffer_Length];
AXI_SRAM uint8_t ICM42688TxBuffer[ICM42688_Buffer_Length];
AXI_SRAM uint8_t MMC5983RxBuffer[MMC5983_Buffer_Length];
AXI_SRAM uint8_t MMC5983TxBuffer[MMC5983_Buffer_Length];
AXI_SRAM uint8_t DPS310RxBuffer[DPS310_Buffer_Length];
AXI_SRAM uint8_t DPS310TxBuffer[DPS310_Buffer_Length];
AXI_SRAM uint8_t PMW3901RxBuffer[PMW3901_Buffer_Length];
AXI_SRAM uint8_t PMW3901TxBuffer[PMW3901_Buffer_Length];

DPS310 dps310_sensor(
    SENSOR_ID_DPS310,
    &spi1_bus,
    DPS310TxBuffer,
    DPS310RxBuffer,
    GPIOA,
    GPIO_PIN_4);
PMW3901 pmw3901_sensor(
    SENSOR_ID_PMW3901,
    &spi2_bus,
    PMW3901TxBuffer,
    PMW3901RxBuffer,
    GPIOB,
    GPIO_PIN_12);
ICM42688 icm42688_sensor(
    SENSOR_ID_ICM42688,
    &spi3_bus,
    ICM42688TxBuffer,
    ICM42688RxBuffer,
    GPIOD,
    GPIO_PIN_2);
MMC5983 mmc5983_sensor(
    SENSOR_ID_MMC5983,
    &i2c1_bus,
    MMC5983TxBuffer,
    MMC5983RxBuffer,
    0x30);

DTCM_DATA StackType_t ICM42688ReadTaskStack[128];
DTCM_DATA StaticTask_t ICM42688ReadTaskTCB;
TaskHandle_t ICM42688ReadTaskHandle = NULL;

DTCM_DATA StackType_t ICM42688ProcessTaskStack[128];
DTCM_DATA StaticTask_t ICM42688ProcessTaskTCB;
TaskHandle_t ICM42688ProcessTaskHandle = NULL;

DTCM_DATA StackType_t MMC5983ReadTaskStack[128];
DTCM_DATA StaticTask_t MMC5983ReadTaskTCB;
TaskHandle_t MMC5983ReadTaskHandle = NULL;

DTCM_DATA StackType_t MMC5983ProcessTaskStack[128];
DTCM_DATA StaticTask_t MMC5983ProcessTaskTCB;
TaskHandle_t MMC5983ProcessTaskHandle = NULL;

DTCM_DATA StackType_t DPS310ReadTaskStack[128];
DTCM_DATA StaticTask_t DPS310ReadTaskTCB;
TaskHandle_t DPS310ReadTaskHandle = NULL;

DTCM_DATA StackType_t DPS310ProcessTaskStack[128];
DTCM_DATA StaticTask_t DPS310ProcessTaskTCB;
TaskHandle_t DPS310ProcessTaskHandle = NULL;

DTCM_DATA StackType_t PMW3901ReadTaskStack[128];
DTCM_DATA StaticTask_t PMW3901ReadTaskTCB;
TaskHandle_t PMW3901ReadTaskHandle = NULL;

DTCM_DATA StackType_t PMW3901ProcessTaskStack[128];
DTCM_DATA StaticTask_t PMW3901ProcessTaskTCB;
TaskHandle_t PMW3901ProcessTaskHandle = NULL;

// 以上为传感器读取和数据处理任务

void Bridge_SystemSensors_Init(void)
{
    SystemSensors_Init();
}

void SystemSensors_Init()
{
    xTaskCreate(
        SystemSensors_Init_Entry,
        "SensorInit",
        256,
        NULL,
        configMAX_PRIORITIES - 1,
        NULL);
}

void SystemSensors_Init_Entry(void *argument)
{
    // 1. 底层与总线初始化
    spi1_bus.init();
    spi2_bus.init();
    spi3_bus.init();
    i2c1_bus.init();

    // 2. 传感器寄存器初始化
    dps310_sensor.init_regs();
    pmw3901_sensor.init_regs();
    icm42688_sensor.init_regs();
    mmc5983_sensor.init_regs();

    ICM42688ReadTaskHandle = xTaskCreateStatic(
        ICM42688ReadTaskEntry, "ICM42688Read", 128, NULL,
        configMAX_PRIORITIES - 2, // 读取最高
        ICM42688ReadTaskStack, &ICM42688ReadTaskTCB);

    ICM42688ProcessTaskHandle = xTaskCreateStatic(
        ICM42688ProcessTaskEntry, "ICM42688Proc", 128, NULL,
        configMAX_PRIORITIES - 3, // 解析紧随其后
        ICM42688ProcessTaskStack, &ICM42688ProcessTaskTCB);

    // --- 导航：PMW3901 光流 (较高优先级) ---
    PMW3901ReadTaskHandle = xTaskCreateStatic(
        PMW3901ReadTaskEntry, "PMW3901Read", 128, NULL,
        configMAX_PRIORITIES - 4,
        PMW3901ReadTaskStack, &PMW3901ReadTaskTCB);

    PMW3901ProcessTaskHandle = xTaskCreateStatic(
        PMW3901ProcessTaskEntry, "PMW3901Proc", 128, NULL,
        configMAX_PRIORITIES - 5,
        PMW3901ProcessTaskStack, &PMW3901ProcessTaskTCB);

    // --- 辅助：MMC5983 磁力计 (中等优先级) ---
    MMC5983ReadTaskHandle = xTaskCreateStatic(
        MMC5983ReadTaskEntry, "MMC5983Read", 128, NULL,
        configMAX_PRIORITIES - 6,
        MMC5983ReadTaskStack, &MMC5983ReadTaskTCB);

    MMC5983ProcessTaskHandle = xTaskCreateStatic(
        MMC5983ProcessTaskEntry, "MMC5983Proc", 128, NULL,
        configMAX_PRIORITIES - 7,
        MMC5983ProcessTaskStack, &MMC5983ProcessTaskTCB);

    // --- 辅助：DPS310 气压计 (中等优先级) ---
    DPS310ReadTaskHandle = xTaskCreateStatic(
        DPS310ReadTaskEntry, "DPS310Read", 128, NULL,
        configMAX_PRIORITIES - 6, // 气压和磁力计同一级别即可
        DPS310ReadTaskStack, &DPS310ReadTaskTCB);

    DPS310ProcessTaskHandle = xTaskCreateStatic(
        DPS310ProcessTaskEntry, "DPS310Proc", 128, NULL,
        configMAX_PRIORITIES - 7,
        DPS310ProcessTaskStack, &DPS310ProcessTaskTCB);

    // ==========================================
    // 4. 绑定 DMA 中断唤醒的解析任务句柄
    // ==========================================
    dps310_sensor.set_task_handle(DPS310ProcessTaskHandle);
    pmw3901_sensor.set_task_handle(PMW3901ProcessTaskHandle);
    icm42688_sensor.set_task_handle(ICM42688ProcessTaskHandle);
    mmc5983_sensor.set_task_handle(MMC5983ProcessTaskHandle);

    SystemQueueInit();
    DBG_MON_INIT();
    AttitudeEstimator_Init();
    // 5. 初始化完毕，释放内存
    vTaskDelete(NULL);
}

void DPS310ReadTaskEntry(void *argument)
{
    TickType_t xLastWakeTime    = xTaskGetTickCount();
    const TickType_t xFrequency = pdMS_TO_TICKS(10); // 100Hz
    while (1) {
        DBG_MON_ATTEMPT(SENSOR_ID_DPS310);

        if (!dps310_sensor.read_data()) {
            DBG_MON_ERROR(SENSOR_ID_DPS310);
        }
        vTaskDelayUntil(&xLastWakeTime, xFrequency);
    }
} // DPS310 读取任务入口函数
void DPS310ProcessTaskEntry(void *argument)
{
    while (1) {
        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
        dps310_sensor.process_in_task();
    }

} // DPS310 数据处理任务入口函数
void PMW3901ReadTaskEntry(void *argument)
{
    TickType_t xLastWakeTime    = xTaskGetTickCount();
    const TickType_t xFrequency = pdMS_TO_TICKS(20); // 50Hz
    while (1) {
        DBG_MON_ATTEMPT(SENSOR_ID_PMW3901);
        if (!pmw3901_sensor.read_data()) {
            DBG_MON_ERROR(SENSOR_ID_PMW3901);
        }
        vTaskDelayUntil(&xLastWakeTime, xFrequency);
    }

} // PMW3901 读取任务入口函数
void PMW3901ProcessTaskEntry(void *argument)
{
    while (1) {
        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
        pmw3901_sensor.process_in_task();
    }

} // PMW3901 数据处理任务入口函数
void ICM42688ReadTaskEntry(void *argument)
{
    while (1) {
        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
        DBG_MON_ATTEMPT(SENSOR_ID_ICM42688);
        if (!icm42688_sensor.read_fifo()) {
            DBG_MON_ERROR(SENSOR_ID_ICM42688);
        }
    }

} // ICM42688 读取任务入口函数
void ICM42688ProcessTaskEntry(void *argument)
{

    while (1) {
        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
        icm42688_sensor.process_in_task();
    }

} // ICM42688 数据处理任务入口函数
void MMC5983ReadTaskEntry(void *argument)
{
    TickType_t xLastWakeTime    = xTaskGetTickCount();
    const TickType_t xFrequency = pdMS_TO_TICKS(20); // 50Hz
    while (1) {
        DBG_MON_ATTEMPT(SENSOR_ID_MMC5983);
        if (!mmc5983_sensor.read_mag()) {
            DBG_MON_ERROR(SENSOR_ID_MMC5983);
        }
        vTaskDelayUntil(&xLastWakeTime, xFrequency);
    }

} // MMC5983 读取任务入口函数
void MMC5983ProcessTaskEntry(void *argument)
{
    while (1) {
        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
        mmc5983_sensor.process_in_task();
    }

} // MMC5983 数据处理任务入口函数
</file>

</files>
